{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0001","title":"/dev/mem full physical read when STRICT_DEVMEM off","attacker_model":"local_unprivileged","preconditions":["CONFIG_STRICT_DEVMEM disabled","Attacker can open /dev/mem"],"description":"With strict devmem disabled, page_is_allowed() always returns true, letting any user read arbitrary physical memory via read_mem(). This enables harvesting kernel secrets, credentials, or MMIO regions directly from userspace.","classification":"info-leak","impact":"Kernel memory disclosure and potential key theft","likelihood":"high","verdict":"confirmed_vuln","context":"driver","evidence":["drivers/char/mem.c:59-69","drivers/char/mem.c:78-167"],"derived_from":[],"proposed_fix_summary":"Keep CONFIG_STRICT_DEVMEM enabled by default or require CAP_SYS_RAWIO for /dev/mem access."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0002","title":"/dev/mem write bypass through restricted pages returning success","attacker_model":"local_unprivileged","preconditions":["CONFIG_STRICT_DEVMEM=Y","page_is_allowed returns 2 for restricted range"],"description":"write_mem() treats allowed==1 as writable and skips when allowed==0. When allowed==2 (restricted), the function silently skips writing but still advances file position and written count, allowing an attacker to probe physical address validity and bypass expected write failures to mislead higher-level code.","classification":"info-leak","impact":"Physical address probing and logic confusion","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:197-236"],"derived_from":[],"proposed_fix_summary":"Return -EPERM for restricted pages instead of silently succeeding and advancing offsets."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0003","title":"Race between mmap_mem_prepare and revocation of devmem range","attacker_model":"local_unprivileged","preconditions":["Attacker can mmap /dev/mem","Security module updates devmem_is_allowed concurrently"],"description":"mmap_mem_prepare() validates the pfn range and range_is_allowed() once before establishing the VMA. If a security module revokes permission between validation and actual mapping, the attacker keeps stale access, enabling time-of-check/time-of-use bypass for MMIO regions.","classification":"race-condition","impact":"Unauthorized persistent mapping of revoked physical pages","likelihood":"low","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:330-361","drivers/char/mem.c:59-69"],"derived_from":[],"proposed_fix_summary":"Revalidate range in mmap fault handler or hold permissions across mapping setup with blocking notifiers."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0004","title":"clear_user disclosure via partial fault on low addresses","attacker_model":"local_unprivileged","preconditions":["__ARCH_HAS_NO_PAGE_ZERO_MAPPED defined","Attacker reads near address 0"],"description":"read_mem() clears user buffer for low physical addresses on architectures without page zero mapped. An attacker can distinguish mapped vs unmapped regions by timing the clear or observing return sizes, turning /dev/mem into a side-channel for kernel memory layout even when not allowed to read actual data.","classification":"info-leak","impact":"Kernel layout inference and KASLR reduction","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:97-109"],"derived_from":[],"proposed_fix_summary":"Return uniform errors for disallowed low addresses instead of zeroing user buffers."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0005","title":"Bounce buffer reuse leaks previous physical contents","attacker_model":"local_unprivileged","preconditions":["Attacker repeatedly reads restricted addresses causing copy_from_kernel_nofault failures"],"description":"read_mem() allocates a PAGE_SIZE bounce buffer and frees it after use without scrubbing. If copy_from_kernel_nofault fails and control flow hits failed:, the buffer contents are not zeroed. Subsequent allocations may return the same page to another context, leaking fragments of physical memory previously copied.","classification":"info-leak","impact":"Potential disclosure of sensitive MMIO or kernel data","likelihood":"low","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:112-167"],"derived_from":[],"proposed_fix_summary":"Memset bounce buffers on failure paths or use kzalloc() to avoid stale data reuse."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0006","title":"Out-of-bounds ppos change detection bypass","attacker_model":"local_unprivileged","preconditions":["Attacker can use pread/pwrite with negative offsets"],"description":"read_mem() returns 0 if *ppos changes during the operation, but ppos is not validated against signed overflow. A crafted negative offset converted to phys_addr_t may wrap to high memory, enabling access beyond intended checks and defeating valid_phys_addr_range() on some architectures.","classification":"integer-overflow","impact":"Potential arbitrary physical access despite range checks","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:82-99"],"derived_from":[],"proposed_fix_summary":"Validate loff_t ppos range and reject negative or overflowing offsets before casting to phys_addr_t."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0007","title":"write_mem lacks copy_from_user fault rollback","attacker_model":"local_unprivileged","preconditions":["Attacker writes to partially inaccessible buffer","CONFIG_STRICT_DEVMEM=Y"],"description":"When copy_from_user into xlate_dev_mem_ptr succeeds partially, write_mem() returns written bytes and advances the file offset. Attackers can use faulting buffers to probe write success byte-by-byte, discovering which physical addresses are writable and inferring device layout.","classification":"info-leak","impact":"Physical address probing via partial writes","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:197-236"],"derived_from":[],"proposed_fix_summary":"Return consistent -EFAULT for partial copies or avoid advancing offsets when faults occur."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0008","title":"O_DSYNC opens force uncached mapping leak timing","attacker_model":"local_unprivileged","preconditions":["Attacker opens /dev/mem with O_DSYNC","Device behind cache-coherent bus"],"description":"uncached_access() forces pgprot_noncached when O_DSYNC is set, enabling a user to observe timing differences between cached and uncached mappings to infer physical address classification and MMIO presence without CAP_SYS_RAWIO.","classification":"info-leak","impact":"Hardware topology and MMIO discovery","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:242-279"],"derived_from":[],"proposed_fix_summary":"Require capabilities for O_DSYNC-triggered uncached mappings or mask the flag for /dev/mem."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0009","title":"Non-MMU private mapping acceptance bypass","attacker_model":"local_unprivileged","preconditions":["CONFIG_MMU=n","Attacker requests MAP_PRIVATE"],"description":"On NOMMU builds, private_mapping_ok() rejects non-shared mappings for /dev/mem, but the hook relies on descriptors in struct vm_area_desc that may be malleable through unusual flags. If a desc lacks NOMMU_MAP_COPY, the code may still proceed, permitting private mappings of device memory and enabling copy-on-write emulation bugs.","classification":"logic-bypass","impact":"Unauthorized private mapping of physical memory","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:282-318"],"derived_from":[],"proposed_fix_summary":"Explicitly reject MAP_PRIVATE for /dev/mem on NOMMU regardless of flags."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0010","title":"range_is_allowed checked only once for mmap","attacker_model":"local_unprivileged","preconditions":["CONFIG_STRICT_DEVMEM enabled","Attacker can create long-lived VMA"],"description":"mmap_mem_prepare() calls range_is_allowed() during setup but does not hook into page fault paths. If firmware marks a range disallowed after mapping, the VMA continues to permit access until revoked manually, allowing race window exploitation for hardware registers.","classification":"race-condition","impact":"Persistent access to revoked MMIO pages","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:330-361"],"derived_from":[],"proposed_fix_summary":"Add VMA close or fault hooks to revalidate devmem policy dynamically."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0011","title":"/dev/port write iterator lacks capability gating","attacker_model":"local_unprivileged","preconditions":["CONFIG_DEVPORT enabled","Attacker opens /dev/port"],"description":"write_port() iterates writes directly to I/O ports using outb without checking CAP_SYS_RAWIO beyond open-time inode permissions. A user with read-only devnode permissions could misuse inherited descriptors to poke hardware, causing device misconfiguration or DMA to arbitrary memory.","classification":"hw-io","impact":"Hardware misuse and potential privilege escalation via DMA","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:388-412"],"derived_from":[],"proposed_fix_summary":"Enforce CAP_SYS_RAWIO on read/write iterators regardless of device node permissions."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0012","title":"/dev/null splice bypasses accounting for huge pipes","attacker_model":"local_unprivileged","preconditions":["Attacker controls pipe length","Uses splice_write_null"],"description":"splice_write_null() blindly returns sd->len, allowing an attacker to splice arbitrarily large amounts of data to /dev/null without any backpressure or accounting. This can inflate pipe buffer allocations and CPU usage elsewhere, enabling a DoS when combined with FUSE or network-backed pipes.","classification":"resource-exhaustion","impact":"Memory/CPU exhaustion via unbounded splice","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:439-449"],"derived_from":[],"proposed_fix_summary":"Limit splice lengths or charge accounted bytes to originating pipe/cgroup."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0013","title":"/dev/zero MAP_PRIVATE anonymity abuses COW behavior","attacker_model":"local_unprivileged","preconditions":["Attacker mmaps /dev/zero MAP_PRIVATE","Fork-heavy workload"],"description":"mmap_zero_private_success marks MAP_PRIVATE mappings of /dev/zero as anonymous, enabling an attacker to create large anonymous regions without accounting to tmpfs or shmem. Fork bombs can then exploit copy-on-write fault handling to pressure memory management without visible backing store usage.","classification":"resource-exhaustion","impact":"System memory pressure and swap thrash","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:507-516"],"derived_from":[],"proposed_fix_summary":"Charge MAP_PRIVATE /dev/zero mappings to shmem or enforce RLIMIT_AS/VMEM cgroup limits on creation."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0014","title":"read_zero loop can stall forever under userfaultfd","attacker_model":"local_unprivileged","preconditions":["Userfaultfd registered on buffer","Large read from /dev/zero"],"description":"read_zero() repeatedly clears user buffers and checks signal_pending() but will continue until count is satisfied. By arming userfaultfd on the destination pages, an attacker can block the copy indefinitely while holding the file descriptor, tying up CPU in kernel context and blocking other readers due to scheduler starvation.","classification":"DoS","impact":"CPU exhaustion via stuck /dev/zero read","likelihood":"high","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:480-505"],"derived_from":[],"proposed_fix_summary":"Add copy timeouts or yield when userfaultfd faulting delays progress; allow NOWAIT semantics for zero device."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0015","title":"read_iter_zero ignores IOCB_NOWAIT for first chunk","attacker_model":"local_unprivileged","preconditions":["Attacker issues nonblocking io_uring read"],"description":"read_iter_zero() honors IOCB_NOWAIT only after processing at least one chunk, performing synchronous zeroing before returning -EAGAIN. This allows attackers to force unexpected blocking in supposed nonblocking contexts, delaying high-priority threads and causing latency spikes.","classification":"logic-bypass","impact":"Latency DoS in nonblocking I/O paths","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:456-478"],"derived_from":[],"proposed_fix_summary":"Check IOCB_NOWAIT before any zeroing work and return -EAGAIN immediately."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0016","title":"mmap_mem_ops lacks .fault hook for cache attributes","attacker_model":"local_unprivileged","preconditions":["CONFIG_HAVE_IOREMAP_PROT","Attacker maps /dev/mem"],"description":"mmap_mem_ops exposes only .access handler; faults rely on default behavior. Attackers can manipulate cacheability by racing to change vma->vm_page_prot after mmap but before first fault, potentially enabling cached access to MMIO despite pgprot_noncached selection during prepare.","classification":"race-condition","impact":"Undefined behavior or data corruption on MMIO devices","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:319-361"],"derived_from":[],"proposed_fix_summary":"Install a fault handler that enforces chosen pgprot on every fault or disallow vma prot modifications."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0017","title":"/dev/null write_iter accepts insanely large iov without limits","attacker_model":"local_unprivileged","preconditions":["Attacker controls iov_iter length"],"description":"write_iter_null() advances iov_iter by its full count with no cap, allowing a single write to claim completion of huge lengths. User programs relying on return values for accounting may mis-handle wraparound or overflow, enabling logic bugs or resource accounting bypass in callers such as log pipelines.","classification":"logic-bypass","impact":"Userland accounting corruption and DoS","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:432-437"],"derived_from":[],"proposed_fix_summary":"Clamp accepted length to sane maximums and validate against ssize_t overflow before advancing iter."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0018","title":"phys_mem_access_prot_allowed weak default","attacker_model":"local_unprivileged","preconditions":["Architecture lacks override","Attacker mmaps device memory"],"description":"The weak phys_mem_access_prot_allowed() returns 1 unconditionally when the arch does not override it, meaning any pfn is mappable through /dev/mem. This undermines platform policies that rely on firmware-defined secure regions.","classification":"policy-bypass","impact":"Arbitrary mapping of secure physical regions","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:242-246"],"derived_from":[],"proposed_fix_summary":"Default to rejecting mappings unless the architecture explicitly approves them or CAP_SYS_RAWIO is held."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0019","title":"should_stop_iteration returns true on pending signal without cleanup","attacker_model":"local_unprivileged","preconditions":["Attacker delivers signals during read_mem/write_mem loops"],"description":"Both read_mem and write_mem stop iterating when signal_pending() is true but return partial data without restoring bounce buffers or zeroing unwritten sections, enabling information leak of prior physical contents in partially filled user buffers and making write side effects unpredictable for privileged tools.","classification":"race-condition","impact":"Info leak and inconsistent writes under signal injection","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:71-76","drivers/char/mem.c:112-167","drivers/char/mem.c:197-236"],"derived_from":[],"proposed_fix_summary":"Zero remainder of user buffers and roll back partially applied writes when interrupted by signals."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0020","title":"mmap_filter_error masks real errno to -EAGAIN","attacker_model":"local_unprivileged","preconditions":["Attacker repeatedly attempts invalid mmap on /dev/mem"],"description":"mmap_filter_error() unconditionally returns -EAGAIN, hiding the real reason for failure such as -EPERM or -EINVAL. Attackers can use timing across retries to infer policy changes or flood with retries until policy windows open, while administrators see misleading errno values.","classification":"logic-bypass","impact":"Policy probing and retry storms","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:325-328"],"derived_from":[],"proposed_fix_summary":"Propagate real error codes to callers to discourage blind retry loops and aid auditing."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0021","title":"/dev/mem mmap races with mem_hotplug removing PFNs","attacker_model":"local_unprivileged","preconditions":["CONFIG_MEMORY_HOTPLUG","CAP_SYS_RAWIO granted or lacking STRICT_DEVMEM"],"description":"An attacker mmaps a hotpluggable region via /dev/mem and keeps faulting pages while another CPU offlines the same memory section. The mapping persists because mmap lacks hotplug invalidation hooks, enabling post-removal access to freed PFNs and potential reuse as page tables or slab objects.","classification":"race-condition","impact":"Use-after-free on removed memory leading to corruption or leak","likelihood":"medium","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:303-336: mmap_mem allows mapping arbitrary PFNs with minimal lifetime checks","mm/memory_hotplug.c handles removal without notifying /dev/mem mappings"] ,"derived_from":[],"proposed_fix_summary":"Reject mmap on hotplug memory or register notifier to unmap on removal; require stronger capability checks."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0022","title":"write_mem partial writes leave stale data on signal","attacker_model":"local_unprivileged","preconditions":["Attacker can send signals to privileged process writing /dev/mem"],"description":"write_mem stops when signal_pending() is true but already wrote some bytes. There is no rollback, leaving partially updated device memory. An attacker can repeatedly signal a privileged writer to flip selective bytes in firmware regions, causing controlled corruption.","classification":"race-condition","impact":"Targeted data corruption via interrupted writes","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:135-170: write loop aborts on should_stop_iteration without restore"] ,"derived_from":[],"proposed_fix_summary":"Make writes atomic per chunk or validate completion; on signal roll back or refuse partial writes to sensitive regions."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0023","title":"/dev/kmem compatibility leak via copy_from_kernel_nofault fallback","attacker_model":"local_unprivileged","preconditions":["CONFIG_DEVKMEM enabled","Strict devmem disabled"],"description":"read_kmem uses copy_from_kernel_nofault via xlate_dev_kmem_ptr. On architectures where copy_from_kernel_nofault falls back to memcpy for linear addresses, faults may leak stale cache lines into user buffers after partially failed accesses, giving attackers glimpses of privileged memory.","classification":"info-leak","impact":"Leak of kernel memory through faulting kmem reads","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:248-284: read_kmem uses xlate_dev_kmem_ptr and copy_from_kernel_nofault"] ,"derived_from":[],"proposed_fix_summary":"Harden copy_from_kernel_nofault implementation and zero padding on partial faults for kmem."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0024","title":"/dev/port bypasses iomap checks for MMIO BARs","attacker_model":"local_unprivileged","preconditions":["CAP_SYS_RAWIO missing but arch leaves page_is_allowed=1","Device exposes MMIO BAR in low port range"],"description":"port_mmap/port_read allow access to I/O ports with minimal arch validation. If a PCI BAR is decoded in port space, unprivileged processes can read or write MMIO registers, potentially altering device state or DMA settings for privilege escalation.","classification":"logic-bypass","impact":"Hardware configuration tampering leading to ring escalation via DMA","likelihood":"medium","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:431-492: port operations lack capability checks when page_is_allowed returns 1"] ,"derived_from":[],"proposed_fix_summary":"Require CAP_SYS_RAWIO for /dev/port accesses and validate port ranges against iomap whitelist."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0025","title":"zero_write bypasses RLIMIT_FSIZE and accounting","attacker_model":"local_unprivileged","preconditions":["Process writes huge data to /dev/zero via splice or write"],"description":"zero_write simply returns count without touching memory. A user can bypass cgroup I/O accounting and RLIMIT_FSIZE by writing unbounded bytes to /dev/zero, consuming scheduler time but not being throttled, enabling DoS by monopolizing CPU for huge write loops.","classification":"DoS","impact":"CPU resource exhaustion without accounting","likelihood":"high","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:607-616: zero_write returns count without work"] ,"derived_from":[],"proposed_fix_summary":"Enforce throttling or early return with cond_resched and hook into cgroup accounting for /dev/zero writes."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0026","title":"null_write discards data allowing covert channel","attacker_model":"local_unprivileged","preconditions":["Sandboxed process allowed /dev/null"],"description":"/dev/null write path discards data without rate limit. Combined with signals or scheduling observation, an attacker can build high-bandwidth covert channel to a colluding observer measuring CPU time or scheduler traces, bypassing traditional IPC controls.","classification":"hardening","impact":"Covert channel and potential scheduler DoS","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:593-605: null_write immediately returns count"] ,"derived_from":[],"proposed_fix_summary":"Add rate limits or audit logging for unusual /dev/null bandwidth in restricted sandboxes."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0027","title":"memory remap via mmap_mem ignores pfn_valid for device holes","attacker_model":"local_unprivileged","preconditions":["CONFIG_STRICT_DEVMEM disabled","Attacker maps PFNs in holes"],"description":"mmap_mem directly uses remap_pfn_range for requested PFNs without verifying pfn_valid. Attackers can map device holes pointing to MMIO or firmware and interact with hardware registers that should be inaccessible, potentially achieving DMA or SMM interaction on legacy systems.","classification":"logic-bypass","impact":"Unauthorized MMIO access and potential ring0 compromise","likelihood":"medium","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:303-336: mmap_mem lacks pfn_valid or resource walk checks"] ,"derived_from":[],"proposed_fix_summary":"Validate PFNs against iomem resource tree and pfn_valid before remap; default deny holes."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0028","title":"splice to /dev/mem bypasses security checks","attacker_model":"local_unprivileged","preconditions":["Splice support enabled","No CAP_SYS_RAWIO"],"description":"memsplice lacks explicit capability checks; it relies on read/write helpers which may have been bypassed via vectored splicing. An attacker can splice from pipes into /dev/mem through kernel-internal paths that omit phys_mem_access_prot_allowed enforcement, enabling restricted writes.","classification":"logic-bypass","impact":"Arbitrary physical memory modification","likelihood":"low","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:517-575: mmap_zero and splice paths thin wrappers around helpers without explicit CAP checks"] ,"derived_from":[],"proposed_fix_summary":"Enforce CAP_SYS_RAWIO in splice ioctl path and re-run phys_mem_access_prot_allowed for spliced segments."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0029","title":"read_mem bounce buffer reuse leaks previous contents","attacker_model":"local_unprivileged","preconditions":["Attacker forces allocation failure or partial copy"],"description":"read_mem allocates PAGE_SIZE bounce buffer and returns early on faults without zeroing it. Subsequent successful reads may copy residual bytes from prior physical locations, giving attacker mixed data from multiple pages.","classification":"info-leak","impact":"Cross-physical-page data disclosure","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:61-92: bounce buffer allocated once then reused; failed path does not clear"] ,"derived_from":[],"proposed_fix_summary":"Zero bounce buffer on each iteration or before free, especially on error paths."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0030","title":"write_mem lacks cache coherency for WC mappings","attacker_model":"local_unprivileged","preconditions":["System with write-combining regions","Attacker writes via /dev/mem to WC area"],"description":"write_mem uses copy_from_user without flushing or syncing caches for WC mappings. An attacker can write stale data while DMA engine reads coherent view, causing inconsistent memory visible to devices leading to data corruption or security bypass in IOMMU-less systems.","classification":"hardening","impact":"Device data corruption or code execution via stale writes","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:112-167: write_mem copies without cache maintenance for special mappings"] ,"derived_from":[],"proposed_fix_summary":"Invoke arch-specific cache flush for WC or IO mappings or disallow such writes without CAP_SYS_RAWIO."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0031","title":"vmalloc_fault in mmap_zero leaks physical layout timing","attacker_model":"local_unprivileged","preconditions":["Huge mmap of /dev/zero with MAP_POPULATE"],"description":"mmap_zero faults lazily but allows MAP_POPULATE to pre-fault. Timing differences reveal physical page allocator behavior, enabling side-channel mapping of buddy allocator state useful for rowhammer targeting.","classification":"info-leak","impact":"Side-channel on physical allocator","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:345-406: mmap_zero relies on vm_insert_page lazily allocating pages"] ,"derived_from":[],"proposed_fix_summary":"Randomize or throttle page allocation timing for /dev/zero pre-faulting or deny MAP_POPULATE."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0032","title":"fault_in_multipage_pfn missing in read_mem allows partial faults","attacker_model":"local_unprivileged","preconditions":["Attacker maps non-resident user buffer (FUSE) for read"],"description":"read_mem copies from kernel to user without pre-faulting user buffer. An attacker can place destination in FUSE or swap-backed memory to induce many faults while holding /dev/mem mapping, causing prolonged lock retention and potential deadlocks with FUSE daemons handling privileged memory content.","classification":"DoS","impact":"Throughput collapse and potential deadlock with FUSE","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:54-92: copy_to_user inside loop without fault-in or cond_resched except signal path"] ,"derived_from":[],"proposed_fix_summary":"Prefault user buffers or drop locks before lengthy copies; integrate fault_in_pages_writeable."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0033","title":"mmap_zero allows executable zero pages defeating W^X","attacker_model":"local_unprivileged","preconditions":["Arch without strict W^X enforcement on zero mappings","Attacker requests PROT_EXEC"],"description":"mmap_zero uses remap_pfn_range with vma->vm_page_prot derived from request. On lax architectures, attacker can map executable zero-filled pages and then fault-in using self-modifying code or exploiting writable alias elsewhere, undermining W^X policies.","classification":"logic-bypass","impact":"Executable anonymous pages leading to code execution tricks","likelihood":"medium","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:345-406: mmap_zero respects caller protections and inserts shared zero pages"] ,"derived_from":[],"proposed_fix_summary":"Force VM_EXEC to be denied on /dev/zero mappings or apply VM_MAYEXEC restrictions."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0034","title":"/dev/mem mmap doesn't honor memfd seals for shared regions","attacker_model":"container_guest","preconditions":["Host exposes PCI BAR shared into guest","Guest allowed /dev/mem"],"description":"Attacker maps host-shared memory via /dev/mem ignoring memfd or shared memory seals. They can modify sealed regions (e.g., firmware blobs) bypassing intended write protections, impacting host devices or firmware integrity.","classification":"logic-bypass","impact":"Modification of sealed shared memory leading to privilege escalation","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:303-336: mmap_mem lacks integration with seals or memfd restrictions"] ,"derived_from":[],"proposed_fix_summary":"Consult memfd seals or resource attributes before allowing writable /dev/mem mappings to sealed areas."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0035","title":"/dev/mem readable through O_PATH plus splice","attacker_model":"local_unprivileged","preconditions":["Attacker opens /dev/mem with O_PATH via fd passed by privileged helper"],"description":"O_PATH fds bypass open-time checks for read/write. If a privileged process opens /dev/mem O_PATH and hands off, attacker may use splice or ioctl to perform reads because file_operations still allow read/write when file flags are adjusted via fcntl, bypassing CAP_SYS_RAWIO enforcement.","classification":"logic-bypass","impact":"Unauthorized physical memory access","likelihood":"low","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:645-680: mem_fops uses simple llseek/read/write without rechecking capabilities during splice"] ,"derived_from":[],"proposed_fix_summary":"Reject read/write on O_PATH or require capability checks on each operation regardless of open flags."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0036","title":"/dev/full error path leaks uninitialized stack on partial copy","attacker_model":"local_unprivileged","preconditions":["Attacker writes small buffers repeatedly"],"description":"full_write copies from user then returns -ENOSPC after zeroing remainder. If copy_from_user fails partially, leftover stack bytes in bounce buffer may be observed through side channels or repeated attempts, leaking kernel stack content.","classification":"info-leak","impact":"Kernel stack disclosure via bounce buffer reuse","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:582-590: full_write uses get_zeroed_page and copy_from_user without scrub after failure"] ,"derived_from":[],"proposed_fix_summary":"Always zero bounce buffer before free and handle partial copy failures by discarding data."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0037","title":"/dev/port mmap lacks refcounting for ioport regions","attacker_model":"local_unprivileged","preconditions":["I/O port region freed by driver while mapping active"],"description":"port_mmap maps I/O memory with io_remap_pfn_range but does not increment resource refcounts. When driver releases IORESOURCE_IO region, mapping remains valid letting attacker access freed or reallocated port space, potentially interacting with new device using old mapping.","classification":"race-condition","impact":"Unauthorized access to newly allocated device ports","likelihood":"medium","verdict":"probable_vuln","context":"driver","evidence":["drivers/char/mem.c:431-492: port_mmap remaps without refcounting IORESOURCE_IO"] ,"derived_from":[],"proposed_fix_summary":"Tie port mmap lifetime to resource refcounts or revoke mapping on release."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0038","title":"mmap_kmem uses vmap allowing hugepage alias leakage","attacker_model":"local_unprivileged","preconditions":["CONFIG_DEVMEM or DEVKMEM","HugeTLB mappings present"],"description":"mmap_kmem uses vmap to map kernel linear addresses into user VMA for /dev/kmem. If hugepage mappings exist, aliasing may permit observations of page table bits or access to adjacent kernel memory due to hugepage alignment, leaking physical layout.","classification":"info-leak","impact":"Physical layout disclosure and potential write primitives","likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:248-284: mmap_kmem uses vmap of kernel addresses without alignment guards"] ,"derived_from":[],"proposed_fix_summary":"Disallow mapping of hugepage-backed kernel addresses or enforce strict alignment and bounds."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0039","title":"fault_in_multipage_pfn absent in write_mem enables FUSE deadlock","attacker_model":"local_unprivileged","preconditions":["write buffer on FUSE file causing userfaults","/dev/mem write invoked by privileged helper"],"description":"write_mem copies from user buffer without prefault; when buffer resides in FUSE, kernel waits on userspace daemon while holding physical mapping context. Attacker can stall daemon to deadlock privileged write into critical memory regions.","classification":"DoS","impact":"Persistent write hang and potential service disruption","likelihood":"medium","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:112-167: write_mem loop lacks fault_in_pages_readable and cond_resched"] ,"derived_from":[],"proposed_fix_summary":"Prefault user pages or release resources before potentially blocking copies; add cond_resched."}
{"file":"drivers/char/mem.c","scenario_id":"drivers/char/mem.c-0040","title":"read_mem lacks kmap_local for highmem on 32-bit","attacker_model":"local_unprivileged","preconditions":["CONFIG_HIGHMEM","Attacker targets high PFNs on 32-bit"],"description":"read_mem uses xlate_dev_mem_ptr which may return highmem addresses requiring kmap. On 32-bit highmem systems attacker can trigger access without proper kmap leading to BUG or leakage if stale mapping reused.","classification":"hardening","impact":"Kernel crash or stale data exposure on highmem,"likelihood":"low","verdict":"hardening_only","context":"driver","evidence":["drivers/char/mem.c:75-92: copy_from_kernel_nofault on ptr returned by xlate_dev_mem_ptr without highmem handling"] ,"derived_from":[],"proposed_fix_summary":"Use kmap_local_page for highmem PFNs before copying or reject highmem range without support."}
