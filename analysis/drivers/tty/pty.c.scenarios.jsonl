{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0001","title":"Devpts teardown vs pktmode wake race","concept":"Master close frees devpts dentry while packet mode on slave still queues wakeups","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker holds master fd","slave side concurrently closing"],"description":"Setup: attacker opens /dev/ptmx, obtains both ends, and enables packet mode via TIOCPKT. Trigger: attacker forces rapid close of the slave while another thread issues pty_set_pktmode on the master. Mechanism: pty_set_pktmode writes to tty->link->ctrl.pktstatus without holding a ref on the link (lines 155-176), while pty_close on the slave tears down devpts driver_data and eventually releases the tty (47-78). Without synchronization, the packet-mode path can dereference freed link memory leading to UAF of the tty struct and embedded waitqueues.","classification":"UAF","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:155-176: packet mode toggled using link->ctrl without lifetime guard","drivers/tty/pty.c:47-78: slave close tears down link and devpts state without coordination with packet toggles"],"proposed_fix_summary":"Hold tty krefs or link lock while toggling packet mode; prevent toggles once TTY_OTHER_CLOSED is set."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0002","title":"Flush write packet flag on freed link","concept":"Flush path sets pktstatus on counterpart after buffer flush even if link vanishes","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker holds master","concurrent slave hangup"],"description":"Setup: attacker runs traffic to fill buffers, then triggers hangup on slave (close) while another thread calls TCFLSH or similar to hit pty_flush_buffer. Trigger: pty_flush_buffer wakes the other end and sets pktstatus under tty->ctrl.lock but writes into tty->link->ctrl without verifying the link still exists (205-214). Mechanism: if the slave is being destroyed, the flush routine can store into freed pktstatus and wake freed waitqueues, producing a race-based UAF.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:205-214: flush writes pktstatus and wakes link without lifetime guard","drivers/tty/pty.c:47-78: close tears down link asynchronously"] ,"proposed_fix_summary":"Take a stable reference on the peer or bail out when TTY_OTHER_CLOSED is set before touching link state."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0003","title":"Winsize mutex reuse after devpts free","concept":"Resizing while peer closing uses link winsize pointer after devpts_pty_kill","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","master and slave shared across namespaces"],"description":"Setup: attacker opens ptmx and passes the slave fd into another namespace; the slave is closed while the master issues TIOCSWINSZ frequently. Trigger: pty_resize locks winsize_mutex on the calling tty (241-271) and updates tty->link->winsize without verifying the link is alive; in close path, devpts_pty_kill and tty_vhangup run without fencing against concurrent resize. Mechanism: the resize writes into freed or reused tty->link memory, leading to UAF and potential corruption of reused tty objects.","classification":"UAF","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:241-271: resize writes link winsize under only caller mutex","drivers/tty/pty.c:47-78: link freed during master close path"] ,"proposed_fix_summary":"Check TTY_OTHER_CLOSED before touching link winsize and hold tty references across resize."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0004","title":"Packet mode status leak after hangup","concept":"pktstatus bits preserved and exposed to new peer when devpts index reused","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","devpts new index reuse after hangup"],"description":"Setup: attacker opens ptmx, enables packet mode, triggers events setting pktstatus bits (stop/start/ioctl), then closes both ends, leaving pktstatus nonzero. Trigger: rapid reopen of the same devpts index by another user before pktstatus is reinitialized. Mechanism: pty_set_pktmode only clears pktstatus on the peer during enable (155-176) but does not reset after close; pty_common_install allocates new tty structs but relies on kmalloc() without zeroing pktstatus in ctrl, so stale bits can leak through devpts reuse, exposing previous session state to a different namespace tenant.","classification":"info-leak","impact":"info leak","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:155-176: pktstatus reset only when enabling packet mode","drivers/tty/pty.c:407-421: pty_common_install allocates ports but does not zero ctrl fields"] ,"proposed_fix_summary":"Explicitly reset ctrl.pktstatus/packet on allocation or during close before devpts index reuse."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0005","title":"TTY_PTY_LOCK race with slave open bypass","concept":"Slave-open lock bit cleared by attacker thread while master still initializing","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker controls master and separate thread accessing same devpts mount"],"description":"Setup: attacker opens ptmx, obtaining master tty with TTY_PTY_LOCK set (843-856). Trigger: before ptmx_open finishes and before slave driver_data set, another thread calls TIOCSPTLCK on the master to clear the bit, then opens the slave via /dev/pts/N. Mechanism: the lock bit prevents slave open in pty_open (217-227), but clearing it while ptmx_open has not yet completed devpts_pty_new and driver_data assignment allows a window where devpts lookup returns ERR_PTR(-EIO) or stale tty, leading to inconsistent count and possible tty structure reuse without proper init.","classification":"logic-bypass","impact":"data corruption","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:217-227: slave open refuses when TTY_PTY_LOCK set","drivers/tty/pty.c:843-875: ptmx_open sets lock then performs devpts_pty_new, leaving window before driver_data assigned"] ,"proposed_fix_summary":"Defer clearing TTY_PTY_LOCK until after slave side fully initialized or block TIOCSPTLCK during setup."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0006","title":"Devpts index reuse after failed ptmx_open","concept":"Index allocated then not killed on racing reopen after tty_init_dev fails","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","memory pressure causing tty_init_dev failure"],"description":"Setup: attacker induces tty_init_dev to fail via memory pressure right after devpts_new_index assigns an index (820-842). Trigger: failing path jumps to out_put_fsi without devpts_kill_index if tty_init_dev returns ERR_PTR, leaving the index potentially visible in devpts structures. Mechanism: another thread racing to open the same pts number can obtain a partially initialized tty with TTY_PTY_LOCK set but missing port setup, leading to use of uninitialized port pointers when pty_open proceeds.","classification":"logic-bypass","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:820-842: index allocated before tty_init_dev, failure path relies on devpts_kill_index in out labels","drivers/tty/pty.c:831-858: error flow uses goto out/out_put_fsi which may miss index kill on certain ERR_PTR paths"] ,"proposed_fix_summary":"Ensure devpts_kill_index is always executed on tty_init_dev failure before releasing fsi; add robust cleanup ordering."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0007","title":"Pktmode enable without checking peer allocation","concept":"pktstatus zeroing assumes link->ctrl exists and is initialized","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","race during early allocation of link"] ,"description":"Setup: attacker opens master, triggers packet mode immediately before the slave's ctrl fields are initialized (possible if allocation delayed or custom driver). Trigger: pty_set_pktmode zeroes tty->link->ctrl.pktstatus without verifying link->port or ctrl are ready (155-176). Mechanism: when link is partially initialized, writing pktstatus can clobber uninitialized memory or race with ctrl.lock setup, causing corrupted lock state and unpredictable behavior.","classification":"race-condition","impact":"kernel crash","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:155-176: writes link->ctrl without validation","drivers/tty/pty.c:403-436: link allocation happens later in pty_common_install, leaving narrow window"] ,"proposed_fix_summary":"Delay enabling packet mode until peer ctrl struct fully initialized; guard with TTY_OTHER_CLOSED/port presence checks."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0008","title":"Signal delivery after peer hangup","concept":"pty_signal uses stale process group after link teardown","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker controls master","peer group exits concurrently"],"description":"Setup: slave session leader exits causing tty_vhangup; attacker on master calls TIOCSIG repeatedly. Trigger: pty_signal fetches pgrp via tty_get_pgrp without checking TTY_IO_ERROR/OTHER_CLOSED (187-199). Mechanism: if link teardown already freed session data, pgrp pointer may be stale leading to kill_pgrp on recycled PID namespace entry, enabling signal injection into unrelated process groups.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:187-199: signal helper operates without closed checks","drivers/tty/pty.c:47-78: close sets flags but caller does not test them"] ,"proposed_fix_summary":"Reject TIOCSIG when peer flagged TTY_OTHER_CLOSED or IO_ERROR; hold reference to session structs."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0009","title":"Packet IOCTL sideband leak across namespaces","concept":"pktstatus reused across namespace-reopened pts sharing same devpts mount","attacker_model":"container_guest","preconditions":["shared host devpts mount","CONFIG_UNIX98_PTYS","packet mode enabled by host process"],"description":"Setup: host process enables packet mode and toggles flow control, setting pktstatus flags. Trigger: container with access to same devpts mount is allowed to open the reused pts index after host closes it. Mechanism: ctrl.pktstatus is not sanitized on reallocation (155-176, 407-421) and can be read from packet-mode notifications by the container, leaking host TTY activity bits and timing information useful for keystroke side-channels.","classification":"info-leak","impact":"info leak","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:155-176: pktstatus preserved across enable/disable","drivers/tty/pty.c:407-421: tty structs allocated without zeroing ctrl fields"] ,"proposed_fix_summary":"Zero ctrl structures on allocation and after close; namespace-isolate devpts mounts."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0010","title":"Count overflows bypass WARN_ON enforcement","concept":"tty->count increments for both ends without saturation, enabling wrap under heavy reuse","attacker_model":"local_unprivileged","preconditions":["CONFIG_LEGACY_PTYS or UNIX98","repeated open/close via fork bombing"],"description":"Setup: attacker rapidly opens and closes ptmx while holding references to slave through dup/fork, driving tty->count increments. pty_common_install increments both tty->count and o_tty->count without bounds (418-420). Mechanism: count is int; extreme churn could overflow and bypass WARN_ON checks in pty_close (47-55), allowing closure to proceed with active references and triggering use-after-free of tty ports.","classification":"refcount","impact":"kernel crash","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:418-420: count++ without limit","drivers/tty/pty.c:47-55: WARN_ON only covers >1/2 counts"] ,"proposed_fix_summary":"Convert counts to kref or saturating refcount_t to prevent wraparound; enforce close ordering."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0011","title":"Unserialized devpts_kill_index during close vs open","concept":"devpts index freed while tty_init_dev still constructing new tty","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","rapid open/close of same pts number across namespaces"],"description":"Setup: attacker closes a busy pts, triggering pty_unix98_remove which calls devpts_kill_index (700-713). Concurrently another thread opens ptmx and obtains same index from devpts_new_index (820-842) before removal completes. Mechanism: devpts_kill_index and devpts_new_index use devpts_mutex but tty_init_dev happens outside that mutex; a new tty may observe TTY_OTHER_CLOSED set from previous session and carry stale flags, leading to hung opens or bypass of lock-based access control.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:700-713: removal frees index under devpts_mutex","drivers/tty/pty.c:820-842: index allocation protected but tty_init_dev done later without clearing flags"] ,"proposed_fix_summary":"Clear TTY flags during allocation before dropping devpts_mutex or defer user access until flags sanitized."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0012","title":"Packet mode ioctl vs hangup ordering leak","concept":"tty_set_termios sets pktstatus IOCTL bit while peer already hung up","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","packet mode enabled"],"description":"Setup: peer hung up sets TTY_OTHER_CLOSED, but master changes termios (e.g., IXON) triggering pty_set_termios. Mechanism: function updates pktstatus bits and wakes peer (255-276) without checking TTY_OTHER_CLOSED. If peer struct freed, write/wakeup hits freed memory; if peer replaced, ioctl bit leaks prior session's termios change to new peer.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:255-276: set_termios manipulates link pktstatus and wakeups unconditionally","drivers/tty/pty.c:47-78: close sets OTHER_CLOSED but no guard here"] ,"proposed_fix_summary":"Check closed flags before termios-driven pktstatus changes; hold reference to peer when waking."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0013","title":"Winsize mutex held without peer reference","concept":"resizing uses peer pointer without getting tty_port ref allowing port free under mutex","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","peer teardown concurrent"],"description":"Setup: attacker calls TIOCSWINSZ repeatedly while peer closes. Trigger: pty_resize locks winsize_mutex on calling tty only (241-271) and writes peer->winsize without taking tty_port ref. Mechanism: if peer's tty_port is freed in close, resize writes to freed memory or corrupts new object occupying that slab.","classification":"UAF","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:241-271: peer winsize updated without lifetime guard","drivers/tty/pty.c:47-78: peer teardown proceeds without synchronization with resize"] ,"proposed_fix_summary":"Acquire tty_kref on peer before resize or gate on TTY_OTHER_CLOSED."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0014","title":"Master packet wake floods bypass flow control","concept":"unthrottle always sets TTY_THROTTLED and wakes peer regardless of link state","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","packet mode enabled","attacker controls master"],"description":"Setup: attacker enables packet mode and intentionally keeps link throttled by stopping flow; concurrently triggers unthrottle via line discipline. Mechanism: pty_unthrottle sets TTY_THROTTLED and calls tty_wakeup(tty->link) without checking TTY_OTHER_CLOSED (91-95). A malicious user can spam wakeups even after peer hung up, leading to unbounded waitqueue wakeups and softirq CPU burn, causing persistent DoS.","classification":"DoS","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:91-95: unthrottle wakes peer unconditionally","drivers/tty/pty.c:47-78: close sets flags but not checked"] ,"proposed_fix_summary":"Skip wakeups when peer closed; rate-limit unthrottle wakeups under packet mode."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0015","title":"TTY buffer limit assumptions bypass via zeroed port","concept":"tty_buffer_set_limit called before tty_port fully referenced, allowing attacker to race port free","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","kmalloc faults on port init"],"description":"Setup: during pty_common_install ports are kmalloc'ed and tty_buffer_set_limit applied before port is attached to tty_port lifetime management (409-413). Trigger: if allocation fails later and ports freed manually, attacker can race via slab reuse to obtain port object with buffer limit still set, enabling buffer overflow into reused structure on subsequent tty_buffer allocations.","classification":"resource-exhaustion","impact":"data corruption","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:403-423: buffer limits set before port lifetime secured","drivers/tty/pty.c:392-402: error path frees ports without resetting limits"] ,"proposed_fix_summary":"Initialize buffer limits after port fully owned or clear fields before kfree in error paths."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0016","title":"Packet mode shared-memory reuse post devpts_release","concept":"ptmx_open frees fsi on error but leaves link->driver_data pointing to freed devpts struct","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","force devpts_pty_new to fail"],"description":"Setup: attacker triggers devpts_pty_new failure (e.g., permission) after tty allocated and link->driver_data assigned (858-870). Trigger: error path jumps to err_release calling tty_release which puts fsi, but link->driver_data may still reference freed dentry when tty reused later. Mechanism: subsequent users of the tty (e.g., pty_close or pty_unix98_remove) dereference driver_data expecting live devpts entry, leading to UAF.","classification":"UAF","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:858-872: driver_data set before devpts_pty_new may fail","drivers/tty/pty.c:68-76,700-713: close/remove use driver_data without validating lifetime"] ,"proposed_fix_summary":"Clear driver_data on error paths and before tty_release; defer assignment until after devpts_pty_new succeeds."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0017","title":"devpts_fs_info refcount underflow via repeated tty_release","concept":"tty_release called twice on same tty when ptmx_open partially succeeds","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","fault injection causing open errors"],"description":"Setup: attacker uses fault injection to force ptmx_open to fail after tty_add_file succeeds but before returning success. Trigger: err_release path calls tty_release (873-878) while tty_free_file later in out_free_file also executes if retry opens, leading to duplicate release of fsi acquired earlier (809-821). Mechanism: devpts_release called twice under refcounting mismatch causing underflow and potential free while references remain, enabling UAF of devpts_fs_info shared across namespaces.","classification":"refcount","impact":"kernel crash","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:809-842: fsi acquired once per open","drivers/tty/pty.c:873-879: error path calls tty_release which puts fsi; subsequent paths may also call devpts_release"] ,"proposed_fix_summary":"Audit error paths to ensure single fsi put; add state flag to prevent double tty_release/ devpts_release."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0018","title":"Unbounded wakeups from packet stop/start toggling","concept":"pty_start/stop toggles pktstatus without flow control gates, enabling wake storm","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","packet mode enabled"] ,"description":"Setup: attacker triggers rapid tcflow/TIOCSTART/TIOCSTOP on slave while peer is busy-polling. Trigger: pty_start/pty_stop modify pktstatus and wake read_wait with EPOLLIN (288-311) even if peer already closed or not listening. Mechanism: attacker can generate unbounded wakeups causing softirq starvation and DoS on systems with many pts devices.","classification":"DoS","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:288-311: start/stop unconditionally wake peer","drivers/tty/pty.c:47-78: no guard for closed peer"] ,"proposed_fix_summary":"Skip wakeups when peer closed; add rate limiting or backoff for pktstatus notifications."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0019","title":"tty_driver_kref_get imbalance on other driver fail","concept":"module_get success followed by alloc_tty_struct failure leaks ref leading to stale driver reuse","attacker_model":"local_unprivileged","preconditions":["CONFIG_LEGACY_PTYS or UNIX98","fault injection to fail alloc_tty_struct"] ,"description":"Setup: in pty_common_install module_get(driver->other->owner) succeeds (389-395) but alloc_tty_struct may fail (397-401). Trigger: attacker induces allocation failure via memory pressure. Mechanism: error path err_put_module handles module_put, but tty_driver_kref_get(driver->other) executed later even on partial failures? Actually only after alloc success. However if o_tty allocation succeeds but later steps fail, driver krefs may remain elevated causing dangling driver preventing unload and leaking structures, allowing attacker to exhaust module refcounts for DoS.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:389-420: multiple refs acquired, partial error cleanup may leak if later steps fail"] ,"proposed_fix_summary":"Centralize ref accounting with cleanup labels ensuring symmetric put for every get on all failure paths."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0020","title":"Unsafe wakeups after TTY_IO_ERROR set","concept":"close sets IO_ERROR then wakes peer waitqueues without excluding reopened peers","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","devpts index quickly reused"],"description":"Setup: master closes, setting TTY_IO_ERROR and TTY_OTHER_CLOSED on peer then waking its waitqueues (57-78). Trigger: new process rapidly reopens same pts number, inheriting the peer's waitqueue structures before prior wakeups finish. Mechanism: wake_up_interruptible may target waitqueue entries belonging to new peer, causing spurious wakeups and potential exposure of prior session state (packet status, throttled flags), acting as cross-session info leak and synchronization bypass.","classification":"race-condition","impact":"info leak","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:57-78: close sets flags and wakes peer without fencing against reuse","drivers/tty/pty.c:407-423: new tty reuses same port structures if kmalloc recycles"] ,"proposed_fix_summary":"Delay devpts reuse until waitqueue quiesced; add generation counters or reinit waitqueues on allocation."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0021","title":"Peer open during devpts teardown dereferences freed dentry","concept":"ptm_open_peer_file walks tty->link->driver_data without devpts_mutex while master close can free the dentry","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker shares master fd across threads","one thread closing master while another calls TIOCGPTPEER"],"description":"Setup: attacker opens /dev/ptmx and hands the master fd to another thread. Thread A initiates close on the master, executing pty_close and devpts_pty_kill under devpts_mutex (47-78). Thread B concurrently issues TIOCGPTPEER, calling ptm_open_peer_file which fetches tty->link->driver_data without any lock or ref (600-621). Mechanism: devpts_pty_kill can free the dentry while ptm_open_peer_file constructs a path from the stale pointer, leading to dentry_open on freed memory and possible UAF or path confusion across namespaces.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:47-78: master close frees devpts entry under mutex","drivers/tty/pty.c:600-621: ptm_open_peer_file uses tty->link->driver_data without locking or refcount"],"proposed_fix_summary":"Hold devpts_mutex or take a dget on driver_data before using it in ptm_open_peer_file; refuse peer open once TTY_OTHER_CLOSED is set."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0022","title":"ptmx index reuse races TTY_PTY_LOCK gating","concept":"devpts_new_index and lock bit clearing can diverge allowing slave open on partially initialized tty","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker can issue ioctl TIOCSPTLCK","multi-threaded master setup"],"description":"Setup: during ptmx_open, TTY_PTY_LOCK is set before devpts_pty_new assigns driver_data and before ptm open completes (809-823). Trigger: attacker thread clears TTY_PTY_LOCK via TIOCSPTLCK while ptmx_open is still in progress and index reserved (773-823). Mechanism: another thread in a different mount namespace calls open on /dev/pts/N while the master initialization is incomplete; pty_open only checks the flag and count (219-234) and may proceed with partially initialized driver_data, leading to use of uninitialized tty->link or leaked index if ptmx_open later fails and calls tty_release, causing inconsistent refcounts and possible UAF.","classification":"logic-bypass","impact":"data corruption","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:219-234: slave open gated by TTY_PTY_LOCK and count","drivers/tty/pty.c:789-833: ptmx_open sets lock then performs devpts_pty_new and tty_init_dev with later error unwind"],"proposed_fix_summary":"Delay TIOCSPTLCK changes until ptmx_open finishes, or track an initializing flag blocking slave opens until driver_data and link are stable."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0023","title":"Packet status wake after hangup drives freed waitqueues","concept":"pktstatus updates on master wake peer read_wait without checking TTY_OTHER_CLOSED","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","packet mode enabled","concurrent slave hangup"],"description":"Setup: master enables packet mode (155-176). Trigger: slave initiates hangup/close setting TTY_OTHER_CLOSED and freeing peer waitqueues through tty_vhangup (47-78), while master side writes to tty->ctrl.pktstatus in pty_set_termios or pty_stop/start (241-271, 289-318). Mechanism: packet-mode handlers update pktstatus under ctrl.lock but unconditionally wake up tty->link->read_wait (265-268, 299-303) even after the peer has been hung up, causing wake_up on freed waitqueues and UAF.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:47-78: hangup sets TTY_OTHER_CLOSED and vhangup frees peer","drivers/tty/pty.c:253-270: pty_set_termios updates pktstatus and wakes peer without testing TTY_OTHER_CLOSED"] ,"proposed_fix_summary":"Check peer liveness (TTY_OTHER_CLOSED or kref) before waking waitqueues; obtain stable tty ref for peer during pktstatus changes."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0024","title":"Winsize propagation after peer free corrupts reused tty struct","concept":"pty_resize writes pty->winsize without ref or closed check allowing stale pointer corruption","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker controls master and triggers peer close"],"description":"Setup: attacker opens a pty pair; slave is closed in another thread causing tty_vhangup and devpts teardown (47-78). Trigger: master issues frequent TIOCSWINSZ ioctls to hit pty_resize (262-287). Mechanism: pty_resize locks only the caller winsize_mutex then copies winsize to tty->link (273-280) without checking TTY_OTHER_CLOSED or holding a kref. If the peer has been freed or reallocated for another index, the write corrupts the new tty struct, leading to cross-session data corruption or UAF.","classification":"race-condition","impact":"data corruption","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:262-287: winsize copied into peer without lifetime guard","drivers/tty/pty.c:47-78: peer close/hangup frees tty while other thread may still run resize"] ,"proposed_fix_summary":"Bail out or take an active reference on the peer before copying winsize; check TTY_OTHER_CLOSED and link pointer validity."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0025","title":"ptm_open_peer use-after-free via late devpts_kill","concept":"peer-open helper dereferences driver_data after tty_release freed devpts entry","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker holds master fd and can trigger error path release","multi-threaded close + ioctl"],"description":"Setup: master open enters ptmx_open and allocates index; an error later in ptmx_open leads to tty_release freeing the tty and devpts_kill_index (789-840). Trigger: a racing thread still issues TIOCGPTPEER on the same master fd before close completes; ptm_open_peer_file builds a path from tty->link->driver_data without checking TTY_IO_ERROR or driver_data validity (600-621). Mechanism: the error path drops devpts references before file close, so ptm_open_peer_file dereferences a freed dentry pointer resulting in UAF. Because both paths run under the same file descriptor, the attacker can reliably trigger the race to obtain kernel memory disclosure or crash.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"confirmed_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:789-840: ptmx_open error path calls tty_release/devpts_kill_index freeing driver_data","drivers/tty/pty.c:600-621: ptm_open_peer_file dereferences tty->link->driver_data without ref or validity checks"] ,"proposed_fix_summary":"Reject ptm_open_peer_file once TTY_IO_ERROR is set or after ptmx_open error unwind; take reference to driver_data or guard with devpts_mutex before dentry_open."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0026","title":"TTY_THROTTLED misuse leads to peer starvation DoS","concept":"pty_unthrottle forces TTY_THROTTLED set permanently making ldisc rely on wakeups that can be suppressed by lock inversion","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","custom ldisc installed","attacker can block wakeups via epoll busy poll"],"description":"Setup: attacker installs a custom line discipline on the slave that depends on TTY_THROTTLED clearing. pty_unthrottle unconditionally sets TTY_THROTTLED after waking the peer (91-95). Trigger: attacker repeatedly invokes pty_write from master with flow-control toggling while suppressing wakeups via epoll busy-poll on the slave, causing the ldisc to remain throttled. Mechanism: the flag logic assumes wakeups reach the consumer; by keeping TTY_THROTTLED set while starving wakeups, data accumulates and tty_buffer_flush in pty_flush_buffer (204-217) can be forced to run under memory pressure leading to soft lockup or DoS.","classification":"DoS","impact":"persistent DoS","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:91-95: pty_unthrottle sets TTY_THROTTLED permanently after wakeup","drivers/tty/pty.c:204-217: flush path invoked under pressure without re-checking throttle state"] ,"proposed_fix_summary":"Re-evaluate throttling semantics for ptys or avoid re-setting TTY_THROTTLED when flow control disabled; ensure wakeups or timeouts clear throttle."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0027","title":"Signal injection after peer free via pty_signal","concept":"pty_signal uses tty_get_pgrp on peer without liveness check enabling signal to freed task structs","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker holds master","peer closing"],"description":"Setup: peer process exits and triggers tty_vhangup; master still issues TIOCSIG through ioctl calling pty_signal (623-639, 187-202). Mechanism: pty_signal fetches pgrp from tty->link without verifying the link is alive or holding a ref; a concurrent hangup can free tty->link or its termios, leading to use-after-free of struct pid when kill_pgrp is invoked on a stale pointer.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:187-202: pty_signal dereferences tty->link and pid without lifetime guard","drivers/tty/pty.c:47-78: hangup frees peer concurrently"] ,"proposed_fix_summary":"Check TTY_OTHER_CLOSED and hold a ref on the peer before retrieving pgrp; abort signal if peer is closing."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0028","title":"Peer wake during remove touches freed port structures","concept":"pty_remove assumed to run last but wakeups remain possible via packet wake and unthrottle","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker can hold fds on both ends","concurrent tty_release"],"description":"Setup: attacker holds both ends; initiates close on master causing tty_release to schedule pty_unix98_remove once both sides drop references (699-713). Trigger: before remove completes, attacker writes data or toggles packet mode on still-open slave causing wakeups into the master waitqueues (91-95, 253-270). Mechanism: pty_unix98_remove calls devpts_kill_index and devpts_release freeing fsi and port structures (709-712), but wakeups still fire because TTY_IO_ERROR is not set on the surviving end; waitqueue targets may already be freed leading to UAF.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:699-713: pty_unix98_remove frees devpts structures after last close","drivers/tty/pty.c:91-95 and 253-270: wakeups issued without checking removal state"] ,"proposed_fix_summary":"Mark both ends as dead before devpts teardown and block further wakeups; synchronize remove with packet-mode wake sources."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0029","title":"Mount namespace confused peer open after devpts_release","concept":"ptm_open_peer_file uses devpts_mntget on masterâ€™s fsi that may already be released by last close from another namespace","attacker_model":"container_guest","preconditions":["CONFIG_UNIX98_PTYS","shared master fd across namespaces","unprivileged container able to call TIOCGPTPEER"],"description":"Setup: host opens ptmx in init namespace, passes master fd into an unprivileged container. Host closes its references first causing devpts_release(fsi) to drop the mount (782-838). Trigger: container thread calls TIOCGPTPEER; ptm_open_peer_file calls devpts_mntget(master, tty->driver_data) (600-621) assuming fsi is alive. Mechanism: without refcounting or namespace checks, devpts_mntget may return ERR_PTR or stale mount; using tty->link->driver_data from another namespace can open a different inode or freed dentry, enabling cross-namespace escape or UAF.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:600-621: devpts_mntget and dentry_open use cached driver_data without verifying fsi refcount","drivers/tty/pty.c:782-838: devpts_acquire/release manage fsi tied to namespace; release can happen before peer open"] ,"proposed_fix_summary":"Pin fsi and driver_data for the lifetime of master fd or reject TIOCGPTPEER once devpts_release has run; add mount namespace validation."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0030","title":"tty_buffer_flush called with peer NULL after hangup","concept":"pty_flush_buffer assumes tty->link non-NULL once checked, but peer can be cleared by close before wakeup","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker can race slave close with flush ioctl"],"description":"Setup: attacker floods data then closes the slave end causing pty_close to set TTY_OTHER_CLOSED and potentially clear link via tty_vhangup (47-78). Trigger: another thread issues TCFLSH hitting pty_flush_buffer (204-217). Mechanism: after the initial !to check (206-209), the peer can be freed and link pointer zeroed before wake_up_interruptible(&to->read_wait) (214-215), resulting in dereference of NULL/freed waitqueue memory and crash.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:204-217: flush uses 'to' after only early NULL check","drivers/tty/pty.c:47-78: hangup may tear down peer between checks"] ,"proposed_fix_summary":"Hold a reference to peer tty during flush or recheck link before wakeups; bail out if TTY_OTHER_CLOSED set."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0031","title":"Legacy pty install lacks zeroing of ctrl leading to info leak across legacy reopen","concept":"pty_common_install allocates tty_port structs via kmalloc without memset, leaving ctrl/pktstatus stale for legacy driver reuse","attacker_model":"local_unprivileged","preconditions":["CONFIG_LEGACY_PTYS","attacker repeatedly opens /dev/pty*","system reuses kmalloc caches"],"description":"Setup: with legacy ptys enabled, pty_common_install allocates two tty_port structures via kmalloc without zeroing (706-730). When tty structs are reused after close, ctrl fields may retain pktstatus bits from prior user. Trigger: attacker opens same minor repeatedly, reading packet mode indicators via TIOCPKT events or observing wakeups. Mechanism: since ctrl fields inside tty_struct are not reset in legacy path, metadata from previous session can leak, providing info about prior tenant activity or leading to unexpected wakeups.","classification":"info-leak","impact":"info leak","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:706-730: pty_common_install uses kmalloc without memset","drivers/tty/pty.c:155-176: pktstatus set on enable but not globally reset"] ,"proposed_fix_summary":"Zero allocated tty_port/tty_struct control fields on install for legacy ptys or explicitly reset pktstatus on open."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0032","title":"TTY count assumptions bypass via double-open of slave","concept":"pty_open only rejects slave when link->count != 1 allowing reopened slave after racing close before count drops","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker can dup and reopen slave fd"],"description":"Setup: attacker obtains slave fd and dup2s it to keep count elevated. Trigger: close original master triggers pty_close which only warns on master count>1 (47-50) and sets TTY_OTHER_CLOSED. Because pty_open only checks slave count !=1 (228-229), the attacker can reopen the slave via /dev/pts/N while dangling references keep count==1. Mechanism: re-opened slave attaches to a tty whose master has been torn down, enabling operations on a partially freed tty_link and possible corruption.","classification":"logic-bypass","impact":"data corruption","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:47-50: master close assumes count==1 but only warns","drivers/tty/pty.c:228-229: slave open allows proceed if count==1 even if master hung up"] ,"proposed_fix_summary":"Enforce strict count validation and reject slave open when master has set TTY_OTHER_CLOSED regardless of count; synchronize dup/reopen with tty refs."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0033","title":"dentry_open without FMODE path validation leaks capabilities across namespaces","concept":"ptm_open_peer_file opens cached driver_data dentry using current_cred() even if devpts mount differs from caller namespace","attacker_model":"container_guest","preconditions":["CONFIG_UNIX98_PTYS","host shares master fd with container","container lacks access to host devpts"],"description":"Setup: host process opens ptmx in init namespace and hands master fd into container without devpts mounted. Trigger: container calls TIOCGPTPEER invoking ptm_open_peer_file which uses the host driver_data dentry and current_cred to open it (600-621). Mechanism: because dentry comes from host devpts, dentry_open bypasses container mount namespace restrictions and may succeed, leaking a slave fd tied to host devpts allowing container to interact with host ptys or observe host metadata, violating namespace isolation.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:600-621: ptm_open_peer_file reuses driver_data dentry with current_cred","drivers/tty/pty.c:605-613: comment aims for race-free peer open but lacks namespace isolation"] ,"proposed_fix_summary":"Validate caller mount namespace or require devpts_mntget relative to caller namespace; prevent TIOCGPTPEER from exposing host devpts to container credentials."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0034","title":"kill_pgrp on stale pid after pty_close ordering","concept":"pty_close sets TTY_IO_ERROR then wakes waitqueues before tty_vhangup allowing ldisc to call pty_signal on freed pgrp","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","custom ldisc using pty_signal","concurrent master close"],"description":"Setup: custom ldisc on master uses pty_signal to deliver signals to slave pgrp. Master close sets TTY_IO_ERROR and wakes read/write waits (57-67) before calling tty_vhangup (68-78). Trigger: ldisc wake handler runs and calls pty_signal during teardown, fetching pgrp from tty->link that is being freed. Mechanism: pty_signal dereferences the pid without refcount (187-202), so signal delivery can use freed struct pid leading to UAF or sending signals to an unintended process.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:57-77: close wakes waitqueues prior to vhangup and devpts_pty_kill","drivers/tty/pty.c:187-202: pty_signal uses tty_get_pgrp/kill_pgrp without peer liveness checks"] ,"proposed_fix_summary":"Disallow ldisc callbacks once TTY_IO_ERROR set or hold pid references with peer liveness checks during signal dispatch."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0035","title":"devpts_mutex omission around devpts_pty_new/kill allows index reuse race","concept":"ptmx_open releases devpts_mutex before calling devpts_pty_new; concurrent pty_unix98_remove can free same index","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker can open/close ptys rapidly","multi-threaded opens"],"description":"Setup: ptmx_open reserves an index under devpts_mutex (789-793) but drops the mutex before calling devpts_pty_new to create the dentry (814-820). Trigger: another thread closing a different pty triggers pty_unix98_remove and devpts_kill_index under devpts_mutex (699-713), potentially reassigning the same index. Mechanism: because creation and kill are not serialized, devpts_pty_new may create a dentry for an index that has just been freed and reused, leading to aliasing of tty->link->driver_data between two sessions and cross-attachment of master/slave pairs.","classification":"race-condition","impact":"boundary bypass","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:789-820: devpts_mutex held only around index reservation, not dentry creation","drivers/tty/pty.c:699-713: devpts_kill_index frees indices under same mutex"] ,"proposed_fix_summary":"Hold devpts_mutex across devpts_pty_new or add generation counters to prevent aliasing after index reuse."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0036","title":"tty_set_termios race with packet disable loses memory barrier on peer readers","concept":"packet mode disable clears flag without notifying peer that might rely on mb() for ordering, allowing stale pktstatus read","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","packet mode heavy traffic","SMP system"],"description":"Setup: master and slave share packet mode; packet enable path issues smp_mb() before setting ctrl.packet (172-174). Trigger: disable via pty_set_pktmode with want_pktmode=0 clears ctrl.packet without a matching barrier (163-167). Mechanism: on SMP, peer readers may observe ctrl.packet cleared but stale pktstatus bits set due to missing barrier, leading to misinterpreting control events and potential exposure of prior control data across sessions when combined with devpts index reuse.","classification":"hardening","impact":"info leak","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:163-176: enable uses smp_mb but disable lacks matching barrier","drivers/tty/pty.c:253-270: peer reads pktstatus based on ctrl.packet state"] ,"proposed_fix_summary":"Add memory barrier when disabling packet mode to synchronize pktstatus visibility or clear pktstatus under lock with ordering."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0037","title":"ptmx_fops lacks fsnotify filtering for peer opens allowing fanotify info leak","concept":"ptmx_open sets FMODE_NONOTIFY on master file but ptm_open_peer_file opens slave without propagating, enabling fanotify observation of slave creation","attacker_model":"local_unprivileged","preconditions":["CONFIG_FANOTIFY","CONFIG_UNIX98_PTYS","attacker under observation by LSM"],"description":"Setup: ptmx_open calls file_set_fsnotify_mode(FMODE_NONOTIFY) to avoid shared resource fanotify (775-777). Trigger: attacker calls TIOCGPTPEER; ptm_open_peer_file constructs path and uses dentry_open with current_cred (600-621) but does not propagate FMODE_NONOTIFY to the new file. Mechanism: fanotify/fsevents can observe slave creation events, leaking the existence of ptys across namespaces or enabling side-channel timing even though ptmx was intended to be non-notifiable, weakening isolation assumptions.","classification":"info-leak","impact":"info leak","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:775-777: ptmx_open disables fsnotify on master","drivers/tty/pty.c:600-621: ptm_open_peer_file uses dentry_open without disabling notify on peer fd"] ,"proposed_fix_summary":"Mirror FMODE_NONOTIFY or explicitly disable fsnotify when opening the peer file for TIOCGPTPEER."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0038","title":"tty_driver module ref leak allows use after unload attempt","concept":"pty_common_install increments other driver module ref but error path lacks symmetric put when o_tty alloc succeeds yet ports alloc fails","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","module-built pty drivers","attacker can exhaust memory"],"description":"Setup: attacker triggers low-memory state causing kmalloc for one of the ports to fail after try_module_get(driver->other->owner) succeeds (706-722). Trigger: pty_common_install hits err_put_module path only when alloc_tty_struct fails, but not when kmalloc of ports fails after module get; the goto err label returns with module ref held. Mechanism: module refcount leak prevents driver unload but also leaves partially initialized o_tty pointer dangling, which later install attempts may use, creating lifetime mismatches and potential UAF on module removal.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:706-723: try_module_get executed before kmalloc error handling","drivers/tty/pty.c:730-747: err/err_put_module paths do not put module when kmalloc fails after try_module_get"] ,"proposed_fix_summary":"Ensure module_put on all allocation failures after try_module_get succeeds or rearrange allocation order to avoid leaked refs."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0039","title":"devpts_mntget NULL return not checked before dentry assignment","concept":"ptm_open_peer_file may return ERR_PTR mount but still uses tty->link->driver_data for path, potentially passing invalid path to dentry_open","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker manipulates devpts mount removal","master fd retained across unmount"],"description":"Setup: attacker unmounts devpts after obtaining master fd (possible in private namespace). Trigger: TIOCGPTPEER calls ptm_open_peer_file; devpts_mntget(master, tty->driver_data) can return ERR_PTR when mount gone (600-621). Mechanism: code returns ERR_CAST(path.mnt) but leaves path.dentry set from tty->link->driver_data; subsequent caller may misuse partial path or leak stale pointer, causing confusion. Lack of explicit NULLing can propagate garbage to callers leading to unexpected kernel oops when repeated.","classification":"logic-bypass","impact":"kernel crash","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["drivers/tty/pty.c:600-621: devpts_mntget error path returns ERR_CAST but path.dentry already set from driver_data","drivers/tty/pty.c:782-838: devpts_release may unmount devpts while fd remains"] ,"proposed_fix_summary":"Validate mount result before touching driver_data and ensure dentry not used when devpts_mntget fails; clear driver_data on unmount."}
{"file":"drivers/tty/pty.c","scenario_id":"drivers/tty/pty.c-0040","title":"tty_unlock after ptmx_open failure leaves dangling tty on file list","concept":"ptmx_open error path uses tty_release but leaves tty_add_file side effects if tty_init_dev partially succeeded","attacker_model":"local_unprivileged","preconditions":["CONFIG_UNIX98_PTYS","attacker can inject failure after tty_add_file via fault injection (e.g., devpts_pty_new)"],"description":"Setup: attacker uses fault injection to fail devpts_pty_new after tty_add_file has attached tty to filp (812-820). Trigger: error path err_release calls tty_release which expects tty_add_file reference accounting, but file_set_fsnotify_mode remains set and tty_unlock executed (827-833). Mechanism: tty added to filp list then freed, leaving filp->private_data pointing to freed tty when close retries release, leading to UAF on subsequent file operations.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["drivers/tty/pty.c:812-820: tty_add_file executed before devpts_pty_new error handling","drivers/tty/pty.c:829-833: err_release uses tty_release after tty_unlock, leaving filp potentially referencing freed tty"] ,"proposed_fix_summary":"Delay tty_add_file until after devpts_pty_new succeeds or ensure filp is sanitized on failure before tty_release."}
