{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0001",
  "title": "Unbounded Loop in handle_tx_copy",
  "concept": "A malicious guest can stall the vhost worker thread by sending packets that don't trigger the weight limit but keep the loop running.",
  "attacker_model": "container_guest",
  "preconditions": [
    "vhost-net enabled",
    "experimental_zcopytx=0 (default)"
  ],
  "description": "In `handle_tx_copy`, the loop continues `while (likely(!vhost_exceeds_weight(vq, ++sent_pkts, total_len)))`. `vhost_exceeds_weight` checks if `total_len >= VHOST_NET_WEIGHT` or `sent_pkts >= VHOST_NET_PKT_WEIGHT`. If the guest sends many small packets, `sent_pkts` limit (256) will eventually be hit. If the guest sends packets that cause errors (e.g. `get_tx_bufs` returns error), the loop breaks. However, consider the case where `vhost_tx_batch` is used. If `nvq->done_idx` reaches `VHOST_NET_BATCH`, it flushes. This logic seems sound for preventing infinite loops, assuming `vhost_exceeds_weight` works as intended. But what if `get_tx_bufs` returns a value that doesn't increment `sent_pkts` effectively or if the error path doesn't break the loop? The error paths in `handle_tx_copy` mostly `break`. Wait, `vhost_exceeds_weight` checks `++sent_pkts`. So it increments for every iteration. The loop is bounded by 256 packets or 512KB. This seems safe against simple infinite loops.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:980: } while (likely(!vhost_exceeds_weight(vq, ++sent_pkts, total_len)));"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None needed."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0002",
  "title": "Use-After-Free in vhost_net_set_backend failure path",
  "concept": "If `vhost_net_enable_vq` fails, `ubufs` might be double-freed or used after free.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "In `vhost_net_set_backend`: `ubufs` is allocated via `vhost_net_ubuf_alloc`. Then `vhost_vq_init_access` is called. If it fails, jumps to `err_used`. `err_used:` calls `vhost_vq_set_backend(vq, oldsock)` and `vhost_net_enable_vq`. Then `if (ubufs) vhost_net_ubuf_put_wait_and_free(ubufs);`. This frees `ubufs`. But `nvq->ubufs` was set to `ubufs` earlier: `nvq->ubufs = ubufs;`. If we fail, we restore `oldubufs`: `nvq->ubufs` is NOT restored to `oldubufs` in `err_used`. The code sets `nvq->ubufs = ubufs` *before* checking for errors in `vhost_net_enable_vq`. If `vhost_net_enable_vq` fails, we jump to `err_used`. We free `ubufs`. But `nvq->ubufs` still points to the freed `ubufs`. Later usage (e.g. `vhost_net_flush` or `handle_tx_zerocopy`) will access this freed pointer.",
  "classification": "UAF",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1666: nvq->ubufs = ubufs;",
    "drivers/vhost/net.c:1689: vhost_net_ubuf_put_wait_and_free(ubufs);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Restore `nvq->ubufs` to `oldubufs` in the error path."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0003",
  "title": "Memory Leak in vhost_net_open",
  "concept": "If `kmalloc_array` fails for `queue` or `xdp`, `n` and `vqs` are freed, but checks are ordered.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "In `vhost_net_open`: `n` is allocated. `vqs` is allocated. `queue` is allocated. If `queue` fails, `vqs` and `n` are freed. `xdp` is allocated. If `xdp` fails, `vqs`, `n`, and `queue` are freed. This looks correct. No leak.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1320: kfree(queue);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0004",
  "title": "Race Condition in vhost_net_release vs vhost_net_ioctl",
  "concept": "Concurrent access to `vhost_net` structure during release.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_net_release` is called when the file descriptor is closed. `vhost_net_ioctl` is called via ioctl. The kernel ensures `release` is called only when the reference count drops to zero. `ioctl` holds a reference to the file. Thus, they cannot run concurrently for the same file struct. However, `vhost_net_set_backend` accesses `sock`. `sock` is refcounted.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0005",
  "title": "Integer Overflow in vhost_net_build_xdp",
  "concept": "Overflow in `buflen` calculation leads to small allocation and heap overflow.",
  "attacker_model": "container_guest",
  "preconditions": [
    "XDP enabled on socket",
    "Guest controls packet length"
  ],
  "description": "In `vhost_net_build_xdp`, `len` is `iov_iter_count(from)`. `buflen` starts as `SKB_DATA_ALIGN(sizeof(struct skb_shared_info))`. `pad` is calculated. `buflen += SKB_DATA_ALIGN(len + pad)`. If `len` is very large (close to SIZE_MAX), `len + pad` can wrap. `SKB_DATA_ALIGN` might also wrap. However, `iov_iter_count` returns the total length of the iovec. The guest provides the iovec. Vhost limits the total length of descriptors? `vhost_get_vq_desc` limits the number of descriptors, but the length of each buffer can be up to 4GB? The `vhost_virtqueue` `iov` is populated with guest provided lengths. If the guest provides a huge length, `len` is huge. `if (unlikely(len < nvq->sock_hlen))` checks underflow. `if (SKB_DATA_ALIGN(len + pad) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) > PAGE_SIZE)` checks upper bound. Since `PAGE_SIZE` is small (4k/64k), huge `len` will fail this check unless it wraps around to be small. `SKB_DATA_ALIGN` aligns to cache line (usually 64 bytes). `len + pad` wrapping to a small value requires `len` to be `~0 - pad`. `iov_iter_count` sums `size_t`. If guest provides `iov` with total length causing wrap in `iov_iter_count`? No, `iov_iter_init` calculates length. If `len` is huge, `buflen` calculation wraps. But the check `> PAGE_SIZE` uses the wrapped value? No, `len + pad` is promoted to `unsigned long` or `size_t`. If `len` is close to `SIZE_MAX`, `len + pad` wraps to small. Then the check passes. Then `buflen` is small. `page_frag_alloc_align` allocates small buffer. `copy_from_iter` tries to copy `len` bytes. `len` is huge. Copy overflows buffer. OOB write.",
  "classification": "integer-overflow",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:755: if (SKB_DATA_ALIGN(len + pad) + SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) > PAGE_SIZE)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Use `check_add_overflow` for `len + pad` calculation or validate `len` against a reasonable max packet size before alignment."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0006",
  "title": "Permanent TX Queue Stall via Descriptor Leak (DoS)",
  "concept": "If `get_tx_bufs` fails or `sendmsg` fails repeatedly with specific errors, descriptors might be leaked or queue state corrupted, leading to stall.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "In `handle_tx_copy`, if `get_tx_bufs` returns a valid head, we process it. If `sock->ops->sendmsg` fails with `EAGAIN` etc., we call `vhost_discard_vq_desc`. This puts the descriptor back. Correct. But if `get_tx_bufs` fails (returns < 0) but not `vq->num`? It breaks the loop. If `ret == vq->num`, it means queue empty. If `ret < 0`, it means error (e.g. `vhost_get_vq_desc` failed). If `vhost_get_vq_desc` fails, it might be due to `vhost_disable_notify` failing? No. If `get_tx_bufs` returns `-EFAULT`, the loop breaks. The descriptor is not discarded (it wasn't fully retrieved). State is fine. But if `vhost_net_tx_get_vq_desc` calls `vhost_get_vq_desc_n` and gets a head, then flushes batches, then calls `vhost_get_vq_desc_n` again? The first `vhost_get_vq_desc_n` claims a descriptor. If the second one is called, does it overwrite? The code: `r = vhost_get_vq_desc_n(...)`. `if (r == tvq->num && timeout) { ... r = vhost_get_vq_desc_n(...) }`. The first `r` was 'no descriptor'. So it wasn't claimed. It waits, then tries again. Correct.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0007",
  "title": "Zerocopy Descriptor Completion Signal Loss (DoS)",
  "concept": "If `vhost_zerocopy_signal_used` fails to signal all used buffers due to ordering, guest might stall waiting for completion.",
  "attacker_model": "container_guest",
  "preconditions": [
    "experimental_zcopytx=1"
  ],
  "description": "`vhost_zerocopy_signal_used` iterates from `done_idx` to `upend_idx`. It checks `VHOST_DMA_IS_DONE`. It signals contiguous done buffers. If a buffer in the middle takes forever (DMA stuck), `done_idx` doesn't advance. `upend_idx` keeps growing (wrapping). `vhost_exceeds_maxpend` limits pending buffers to `VHOST_MAX_PEND` (128) or `vq->num >> 2`. If one buffer is stuck, `upend_idx` advances until limit. Then `zcopy_used` becomes false. Fallback to copy? `handle_tx_zerocopy`: `zcopy_used = len >= ... && !vhost_exceeds_maxpend`. If limit exceeded, `zcopy_used` is false. It uses copy mode. So it continues working. But the stuck buffer holds a `ubuf` ref. `vhost_net_ubuf_put` is called in `vhost_zerocopy_complete`. If completion never happens (e.g. NIC driver bug or lost interrupt), the refcount never drops. `vhost_net_flush` waits for refcount. This would hang `vhost_net_flush` (e.g. during release/reset). Host process hangs unkillable.",
  "classification": "DoS",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1396: vhost_net_ubuf_put_and_wait(n->vqs[VHOST_NET_VQ_TX].ubufs);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Implement a timeout in `vhost_net_flush` or ensure lower device guarantees completion."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0008",
  "title": "Host Process Hang via Zerocopy Reference Pinning",
  "concept": "Malicious guest or network condition prevents zerocopy completion, hanging `vhost_net_flush`.",
  "attacker_model": "container_guest",
  "preconditions": [
    "experimental_zcopytx=1"
  ],
  "description": "As in Scenario 0007, `vhost_net_flush` waits for `ubufs->refcount` to reach 1. The refcount is incremented for each zerocopy packet submitted. It is decremented in `vhost_zerocopy_complete`. This callback is invoked by `skb_zcopy_clear` when the SKB is freed. If the SKB is leaked or stuck in a queue (e.g. qdisc, device queue) indefinitely, the callback is never called. `vhost_net_release` calls `vhost_net_flush`. The `release` operation (closing `/dev/vhost-net`) will hang. This makes the VMM process (e.g. QEMU) unkillable (D state) if it tries to exit. While this relies on external networking stack behavior, `vhost-net`'s dependency on it for cleanup is a vulnerability.",
  "classification": "DoS",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1396: vhost_net_ubuf_put_and_wait(n->vqs[VHOST_NET_VQ_TX].ubufs);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Use `wait_event_timeout` in `vhost_net_ubuf_put_and_wait` and handle timeout (though cleaning up is hard if SKBs are still alive)."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0009",
  "title": "Double Free in vhost_net_release via vhost_net_stop",
  "concept": "Resources freed in `vhost_net_stop` might be accessed or freed again.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_net_release` calls `vhost_net_stop`, `vhost_net_flush`, `vhost_dev_stop`, `vhost_dev_cleanup`, `vhost_net_vq_reset`. `vhost_net_stop` calls `vhost_net_stop_vq`, which sets backend to NULL and frees things. `vhost_net_vq_reset` calls `vhost_net_clear_ubuf_info`. `vhost_net_flush` calls `vhost_dev_flush`. Sequence seems correct. `vhost_dev_cleanup` cleans up device level. `kfree(n->dev.vqs)` happens at the end. No obvious double free.",
  "classification": "double-free",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0010",
  "title": "Uninitialized Memory Leak in vhost_net_buf_peek",
  "concept": "Peeking length from uninitialized buffer memory.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_net_buf_peek` calls `vhost_net_buf_produce` if empty. `vhost_net_buf_produce` consumes from `ptr_ring`. `vhost_net_buf_peek_len` reads from ptr. `tun_ptr_to_xdp` casts ptr. If `ptr_ring` gives uninitialized ptrs? `ptr_ring` should be safe. `tun` puts valid pointers. `vhost_net` trusts `ptr_ring` content.",
  "classification": "info-leak",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0011",
  "title": "Race in vhost_net_busy_poll trylock",
  "concept": "If `mutex_trylock` fails, busy poll is skipped, potentially affecting performance but not security.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "`vhost_net_busy_poll` tries to lock the paired VQ. If it fails, it returns. This is intentional to avoid deadlocks. No vulnerability.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0012",
  "title": "Use-After-Free in vhost_net_ubuf_put_wait_and_free",
  "concept": "Accessing `ubufs` after `kfree_rcu`?",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_net_ubuf_put_wait_and_free` calls `vhost_net_ubuf_put_and_wait` then `kfree_rcu`. `wait_event` waits until refcount is 0 (actually code checks `!atomic_read`). `vhost_net_ubuf_put` decrements. If refcount hits 0, it wakes up. `kfree_rcu` schedules free. This is safe.",
  "classification": "UAF",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0013",
  "title": "OOB Write in vhost_net_build_xdp via sock_hlen",
  "concept": "Manipulating `sock_hlen` to underflow buffer pointer.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`sock_hlen` is `nvq->sock_hlen`. `buf = page_frag_alloc...`. `copy_from_iter(buf + pad - sock_hlen, ...)`. If `sock_hlen > pad`? `pad = SKB_DATA_ALIGN(VHOST_NET_RX_PAD + headroom + nvq->sock_hlen)`. So `pad` is at least `sock_hlen`. `buf + pad - sock_hlen` is valid. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0014",
  "title": "XDP Packet Truncation Logic Error",
  "concept": "Incorrect XDP buffer preparation leading to data corruption.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`xdp_prepare_buff(xdp, buf, pad, len - sock_hlen, true)`. `len` is total length. `sock_hlen` is header length. `len - sock_hlen` is data length. Looks correct.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0015",
  "title": "Integer Overflow in vhost_net_set_ubuf_info allocation",
  "concept": "Allocation size overflow for `ubuf_info`.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`kmalloc_array(UIO_MAXIOV, sizeof(*n->vqs[i].ubuf_info), GFP_KERNEL)`. `UIO_MAXIOV` is 1024. Size is small. No overflow.",
  "classification": "integer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0016",
  "title": "vhost_net_rx_peek_head_len infinite retry",
  "concept": "Busy loop in peek if `busyloop_intr` handling is broken.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `len` is 0 and timeout set: flushes, busy polls, peeks again. If still 0, returns 0. No infinite loop.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0017",
  "title": "vhost_net_buf_consume NULL dereference",
  "concept": "Consuming empty ring.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_net_buf_consume` increments head. `vhost_net_buf_get_ptr` checks `tail != head`. If called on empty ring, `get_ptr` returns NULL. `consume` increments head anyway. `head` passes `tail`. `rxq->queue` index logic is not modulo-based in `get_ptr`: `rxq->queue[rxq->head]`. If `head` increments indefinitely, it OOBs. `vhost_net_buf_consume` is called in `handle_rx` only if `nvq->rx_ring` is set and (implied?) buffer available? `handle_rx`: `if (nvq->rx_ring) msg.msg_control = vhost_net_buf_consume(&nvq->rxq);`. Prior to this, `sock_len = vhost_net_rx_peek_head_len(...)`. `peek` calls `vhost_net_buf_peek`. `peek` calls `produce` if empty. `produce` consumes from ptr_ring. If `peek` returns len > 0, then `rxq` is not empty. So `consume` is safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0018",
  "title": "vhost_net_ioctl VHOST_RESET_OWNER race",
  "concept": "Reset owner while worker is running.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_net_reset_owner` locks `dev.mutex`. `handle_tx` locks `vq.mutex`. `reset_owner` calls `vhost_net_stop`, which locks `vq.mutex`. Correct locking.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0019",
  "title": "vhost_net_ioctl VHOST_NET_SET_BACKEND index check",
  "concept": "OOB access to `n->vqs`.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `index >= VHOST_NET_VQ_MAX` (2). Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0020",
  "title": "vhost_net_set_features logic error",
  "concept": "Incorrect `hdr_len` calculation.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Sets `hdr_len` based on features. `sizeof(struct virtio_net_hdr_mrg_rxbuf)` vs `sizeof(struct virtio_net_hdr)`. Correct.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0021",
  "title": "vhost_net_set_owner double ownership",
  "concept": "Setting owner twice.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `vhost_dev_has_owner`. Returns `-EBUSY`. Safe.",
  "classification": "state-machine",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0022",
  "title": "vhost_net_open GFP_KERNEL allocation",
  "concept": "Allocation in open path.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Allocates with `GFP_KERNEL`. Standard for open.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0023",
  "title": "vhost_net_set_backend socket check",
  "concept": "Using non-socket file.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`get_socket` -> `get_raw_socket` or `get_tap_socket`. Checks `sock->sk->sk_type` and family. Safe.",
  "classification": "type-confusion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0024",
  "title": "get_raw_socket type confusion",
  "concept": "Passing a socket that isn't raw/packet.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `SOCK_RAW` and `AF_PACKET`. Safe.",
  "classification": "type-confusion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0025",
  "title": "get_tap_socket type confusion",
  "concept": "Passing non-tap file.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`tun_get_socket` and `tap_get_socket` verify file ops. Safe.",
  "classification": "type-confusion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0026",
  "title": "handle_rx overrun check",
  "concept": "Buffer overrun in RX.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `headcount > UIO_MAXIOV`. Truncates if so. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0027",
  "title": "handle_rx recvmsg error handling",
  "concept": "Discarding packet on error.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `recvmsg` returns error or mismatch length, discards descriptor. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0028",
  "title": "handle_rx vnet_hdr write failure",
  "concept": "Failing to write header.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `copy_to_iter` fails, logs error, goes to `out`. Descriptor is used/signalled? No, `out` unlocks and `vhost_net_signal_used` is called with `count`. `count` was incremented before write? `nvq->done_idx` updated *after* write. `count` updated *after* write. So if write fails, `count` is not incremented. Descriptor is leaked (not used)? `headcount` descriptors were allocated. If we go to `out`, they are not added to used ring. `vhost_get_vq_desc_n` advanced avail index. This desyncs avail and used? Yes, descriptors are lost. But guest sees them as 'in use'. Not a security vulns, just packet loss.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0029",
  "title": "get_rx_bufs descriptor loop",
  "concept": "Loops until `quota` or `datalen`. `datalen` decrements. Safe.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Loops.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0030",
  "title": "get_rx_bufs error path",
  "concept": "Discards on error.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Calls `vhost_discard_vq_desc`. Correct.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0031",
  "title": "init_iov_iter zero length",
  "concept": "Empty header check.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`get_tx_bufs` checks `*len == 0`. Returns `-EFAULT`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0032",
  "title": "vhost_net_tx_get_vq_desc busyloop logic",
  "concept": "Busy polling logic.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If empty, polls. Logic seems fine.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0033",
  "title": "vhost_net_busy_poll preemption",
  "concept": "Disables preempt during poll.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Disables preempt. Checks need_resched. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0034",
  "title": "vhost_zerocopy_complete refcount decrement",
  "concept": "Decrement logic.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Atomic sub. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0035",
  "title": "vhost_zerocopy_signal_used loop",
  "concept": "Signaling used buffers.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Loops from `done_idx` to `upend_idx`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0036",
  "title": "vhost_net_tx_packet counts",
  "concept": "Resetting counts.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Resets every 1024 packets. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0037",
  "title": "vhost_net_enable_zcopy mask",
  "concept": "Mask setting.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Sets bit. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0038",
  "title": "vhost_net_ubuf_alloc refcount init",
  "concept": "Init refcount to 1.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Sets to 1. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0039",
  "title": "vhost_net_ubuf_put wakeup",
  "concept": "Wakes up wait queue.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Wakes up if refcount hits 0. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0040",
  "title": "vhost_net_clear_ubuf_info loop",
  "concept": "Clearing info.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Loops MAX VQs. Frees. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0041",
  "title": "vhost_net_set_ubuf_info allocation check",
  "concept": "Checking allocation.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `!n->vqs[i].ubuf_info`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0042",
  "title": "vhost_net_buf_is_empty check",
  "concept": "Empty check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks tail == head. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0043",
  "title": "vhost_net_buf_produce consume batched",
  "concept": "Consuming batched.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Uses `ptr_ring_consume_batched`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0044",
  "title": "vhost_net_buf_unproduce unconsume",
  "concept": "Putting back pointers.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Uses `ptr_ring_unconsume`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0045",
  "title": "vhost_net_buf_peek_len type check",
  "concept": "XDP vs SKB.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `tun_is_xdp_frame`. Safe.",
  "classification": "type-confusion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0046",
  "title": "vhost_net_buf_init indices",
  "concept": "Init indices.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Sets head/tail to 0. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0047",
  "title": "handle_tx_copy MSG_MORE logic",
  "concept": "Setting MSG_MORE.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Sets based on batching. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0048",
  "title": "handle_tx_copy discard on error",
  "concept": "Discarding descriptors on send failure.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_discard_vq_desc`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0049",
  "title": "handle_tx_zerocopy zcopy usage check",
  "concept": "Deciding zcopy.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks length and pending. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0050",
  "title": "handle_tx_zerocopy msg_control",
  "concept": "Setting msg_control.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Sets ubuf info. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0051",
  "title": "handle_tx_zerocopy refcount inc",
  "concept": "Incrementing refcount.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Atomic inc. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0052",
  "title": "handle_tx_zerocopy retry logic",
  "concept": "Retrying on error.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Restores upend_idx. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0053",
  "title": "handle_tx locking",
  "concept": "Locking VQ.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Mutex lock. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0054",
  "title": "handle_tx backend check",
  "concept": "Checking sock.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `!sock`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0055",
  "title": "peek_head_len locking",
  "concept": "Locking queue.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Spin lock irqsave. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0056",
  "title": "vhost_net_rx_peek_head_len flush",
  "concept": "Flushing used.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Signals used if empty. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0057",
  "title": "handle_rx locking",
  "concept": "Locking.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Mutex lock. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0058",
  "title": "handle_rx num_buffers write",
  "concept": "Writing num buffers.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Copy to iter. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0059",
  "title": "handle_rx log write",
  "concept": "Logging dirty pages.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_log_write`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0060",
  "title": "vhost_net_stop_vq locking",
  "concept": "Locking during stop.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Mutex lock. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0061",
  "title": "vhost_net_flush locking",
  "concept": "Locking during flush.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Locks TX VQ. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0062",
  "title": "vhost_net_release RCU sync",
  "concept": "RCU synchronization.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `synchronize_rcu`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0063",
  "title": "get_tap_ptr_ring validity",
  "concept": "Checking ring validity.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `IS_ERR`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0064",
  "title": "vhost_net_set_backend check owner",
  "concept": "Checking ownership.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_dev_check_owner`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0065",
  "title": "vhost_net_set_backend index check",
  "concept": "Index bounds.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `index >= MAX`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0066",
  "title": "vhost_net_set_backend access ok",
  "concept": "Checking ring access.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_vq_access_ok`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0067",
  "title": "vhost_net_reset_owner cleanup",
  "concept": "Cleaning up.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Stops, flushes, resets. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0068",
  "title": "vhost_net_set_features log check",
  "concept": "Checking log access.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_log_access_ok`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0069",
  "title": "vhost_net_set_features iotlb init",
  "concept": "Initializing IOTLB.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_init_device_iotlb`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0070",
  "title": "vhost_net_set_owner check",
  "concept": "Checking existing owner.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `vhost_dev_has_owner`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0071",
  "title": "vhost_net_ioctl copy_from_user",
  "concept": "Copying arguments.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks return values. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0072",
  "title": "vhost_net_ioctl feature checks",
  "concept": "Validating features.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks supported features. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0073",
  "title": "vhost_net_init reg",
  "concept": "Registering device.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `misc_register`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0074",
  "title": "vhost_net_exit dereg",
  "concept": "Deregistering device.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `misc_deregister`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0075",
  "title": "vhost_net_chr_read_iter impl",
  "concept": "Read iter implementation.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_chr_read_iter`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0076",
  "title": "vhost_net_chr_write_iter impl",
  "concept": "Write iter implementation.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_chr_write_iter`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0077",
  "title": "vhost_net_chr_poll impl",
  "concept": "Poll implementation.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_chr_poll`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0078",
  "title": "vhost_net_tx_packet count limit",
  "concept": "Packet counting.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Resets if < 1024. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0079",
  "title": "vhost_net_tx_err increment",
  "concept": "Error counting.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Increments. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0080",
  "title": "vhost_net_tx_select_zcopy heuristic",
  "concept": "Zcopy heuristic.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks flush and error rate. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0081",
  "title": "vhost_sock_zcopy check",
  "concept": "Checking sock zcopy.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks flag. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0082",
  "title": "vhost_sock_xdp check",
  "concept": "Checking sock xdp.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks flag. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0083",
  "title": "vhost_zerocopy_signal_used index wrap",
  "concept": "Index wrapping.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Modulo `UIO_MAXIOV`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0084",
  "title": "vhost_net_disable_vq backend check",
  "concept": "Backend check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `vhost_vq_get_backend`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0085",
  "title": "vhost_net_enable_vq backend check",
  "concept": "Backend check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `sock`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0086",
  "title": "vhost_net_signal_used count check",
  "concept": "Signaling count.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_add_used_and_signal_n`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0087",
  "title": "vhost_tx_batch in_order check",
  "concept": "In order batching.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Sets `len` and `nheads`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0088",
  "title": "vhost_tx_batch empty check",
  "concept": "Empty batch.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `batched_xdp == 0`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0089",
  "title": "vhost_tx_batch error handling",
  "concept": "Error handling.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Frees pages on error. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0090",
  "title": "sock_has_rx_data check",
  "concept": "Rx data check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks peek_len or queue empty. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0091",
  "title": "vhost_net_busy_poll_try_queue check",
  "concept": "Queue check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `vhost_vq_avail_empty`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0092",
  "title": "vhost_net_tx_get_vq_desc flush",
  "concept": "Flushing batch.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `vhost_tx_batch` if poll needed. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0093",
  "title": "vhost_exceeds_maxpend check",
  "concept": "Pending check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `upend_idx` vs `done_idx`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0094",
  "title": "init_iov_iter check",
  "concept": "Init iter.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Calls `iov_iter_init`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0095",
  "title": "get_tx_bufs error checks",
  "concept": "Error checking.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `ret < 0`. Checks `*in`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0096",
  "title": "tx_can_batch check",
  "concept": "Batch check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks weight and avail. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0097",
  "title": "vhost_net_build_xdp len check",
  "concept": "Len check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `len < sock_hlen`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0098",
  "title": "vhost_net_build_xdp alloc check",
  "concept": "Alloc check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `!buf`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0099",
  "title": "vhost_net_build_xdp copy check",
  "concept": "Copy check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks `copied != len`. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0100",
  "title": "vhost_net_build_xdp csum check",
  "concept": "Csum check.",
  "attacker_model": "none",
  "preconditions": [],
  "description": "Checks csum start/offset vs hdr len. Safe.",
  "classification": "other",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
