{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0001",
  "title": "TX Queue Stall via Descriptor Leak in get_tx_bufs Error Path",
  "concept": "Resource Leak / Logic Error",
  "attacker_model": "container_guest",
  "preconditions": [
    "Vhost-net device configured",
    "Guest capable of sending crafted descriptors"
  ],
  "description": "Vulnerability Path: Setup: Standard vhost-net. Trigger: Guest places a writable descriptor (VRING_DESC_F_WRITE) into the TX virtqueue. Mechanism: The worker thread calls `handle_tx_copy` -> `get_tx_bufs`. Inside `get_tx_bufs`, `vhost_net_tx_get_vq_desc` calls `vhost_get_vq_desc_n`, which successfully fetches the descriptor and increments `last_avail_idx` (marking it consumed from the ring). `get_tx_bufs` then checks `if (*in)`. Finding a writable descriptor in TX is invalid, so it calls `vq_err` and returns `-EFAULT`. `handle_tx_copy` sees the error, breaks the loop, and stops processing. Crucially, `vhost_discard_vq_desc` is NOT called to rollback the `last_avail_idx`, nor is `vhost_add_used` called to return it to the guest. The descriptor is permanently leaked.",
  "classification": "resource-exhaustion",
  "impact": "persistent DoS",
  "likelihood": "high",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1083: if (*in) {",
    "drivers/vhost/net.c:1086: return -EFAULT;",
    "drivers/vhost/net.c:1138: if (unlikely(head < 0)) break;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Call vhost_discard_vq_desc in the error path of get_tx_bufs before returning -EFAULT."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0002",
  "title": "Zerocopy Descriptor Stall via Protocol Switch",
  "concept": "State Machine Violation",
  "attacker_model": "local_unprivileged",
  "preconditions": [
    "experimental_zcopytx=1",
    "User owns vhost fd and backend socket fd"
  ],
  "description": "Vulnerability Path: Setup: Enable zerocopy. Trigger: User initiates zerocopy traffic, then disables SOCK_ZEROCOPY on the socket via setsockopt. Mechanism: `handle_tx` switches from `handle_tx_zerocopy` to `handle_tx_copy` because `vhost_sock_zcopy` returns false. `handle_tx_zerocopy` is responsible for signaling used zerocopy buffers (`vhost_zerocopy_signal_used`). `handle_tx_copy` does not do this. Any in-flight zerocopy buffers (tracked by `upend_idx`) will complete DMA, but their completion will never be signaled to the guest as long as the host stays in copy mode. The guest sees these descriptors as pending indefinitely.",
  "classification": "logic-bypass",
  "impact": "DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1278: if (vhost_sock_zcopy(sock)) handle_tx_zerocopy(net, sock); else handle_tx_copy(net, sock);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Ensure vhost_zerocopy_signal_used is called or state is flushed when switching Tx modes."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0003",
  "title": "Host Process Hang via Zerocopy Reference Pinning",
  "concept": "Resource Exhaustion",
  "attacker_model": "local_unprivileged",
  "preconditions": [
    "experimental_zcopytx=1"
  ],
  "description": "Vulnerability Path: Setup: Zerocopy enabled. Trigger: Malicious user sends packets via vhost-net zerocopy to a TAP device, but stops consuming from the TAP device. Then user closes the vhost-net device. Mechanism: `vhost_net_release` calls `vhost_net_flush`. `vhost_net_flush` calls `vhost_net_ubuf_put_and_wait`, which waits for `ubufs->refcount` to drop to 0. The refcount is held by the SKBs sitting in the TAP receive queue. Since the user controls the consumer, they can prevent the refcount from dropping. The `close()` syscall hangs indefinitely in D-state.",
  "classification": "resource-exhaustion",
  "impact": "DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1347: vhost_net_ubuf_put_and_wait(n->vqs[VHOST_NET_VQ_TX].ubufs);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Implement a timeout or mechanism to forcibly revoke ubufs, or document as known limitation of zerocopy."
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0004",
  "title": "Use-After-Free in vhost_net_set_backend Race",
  "concept": "Race Condition",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `vhost_net_set_backend` replaces `ubufs` while `handle_tx_zerocopy` uses them. Mechanism: `vhost_net_set_backend` takes `vq->mutex`. `handle_tx` also takes `vq->mutex`. Analysis: They are mutually exclusive. The `oldubufs` are freed after unlocking, but `handle_tx` cannot run until `set_backend` finishes (or vice versa). Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1479: mutex_lock(&vq->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0005",
  "title": "Integer Overflow in vhost_net_build_xdp",
  "concept": "Integer Overflow",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Hypothesis: Huge `len` causes `buflen` integer overflow leading to heap overflow. Mechanism: `len` is size_t. `buflen` is int. `buflen += SKB_DATA_ALIGN(len + pad)`. If `len` is ~4GB, `buflen` wraps. Analysis: The code checks `if (SKB_DATA_ALIGN(len + pad) + ... > PAGE_SIZE)`. `SKB_DATA_ALIGN` promotes to unsigned long/size_t. `PAGE_SIZE` is 4096. If `len` is huge, this check fails and returns -ENOSPC. The path is protected by the page size limit.",
  "classification": "integer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1115: > PAGE_SIZE"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0006",
  "title": "Double Free in vhost_net_release",
  "concept": "Double Free",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `vhost_net_release` frees resources that might be freed by `vhost_dev_cleanup`. Mechanism: `vhost_dev_cleanup` resets VQs but does not free `rxq.queue` or `xdp`. `vhost_net_release` explicitly frees them. Analysis: Ownership is clear. `vhost_net` owns the arrays. Safe.",
  "classification": "double-free",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0007",
  "title": "UAF via peek_head_len Race",
  "concept": "Race Condition",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `skb_peek` returns a pointer that is freed before access. Mechanism: `peek_head_len` holds `sk->sk_receive_queue.lock` while accessing `head->len`. Analysis: Lock protects the SKB from being dequeued/freed. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/net.c:1301: spin_lock_irqsave"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0008",
  "title": "Buffer Overrun in handle_rx",
  "concept": "Buffer Overflow",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Hypothesis: `headcount` exceeds buffer size. Mechanism: `handle_rx` checks `if (unlikely(headcount > UIO_MAXIOV))`. If true, it discards the packet. Analysis: The check explicitly prevents buffer overrun in `vq->iov` usage (though `iov_iter_init` would just be limited by size). Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0009",
  "title": "Infinite Loop in get_rx_bufs",
  "concept": "DoS",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Hypothesis: `get_rx_bufs` loops forever if `datalen` doesn't decrease. Mechanism: `datalen -= len`. `len` comes from `iov_length`. `vhost_get_vq_desc_n` returns descriptors. If descriptors have 0 length? `datalen` stays same. But `headcount` increments. Loop checks `headcount < quota`. `quota` is `UIO_MAXIOV`. Loop terminates. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0010",
  "title": "vhost_net_tx_err Race Condition",
  "concept": "Race Condition",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `tx_zcopy_err` increment is racy. Mechanism: Incremented in `vhost_zerocopy_signal_used`. Reset in `vhost_net_set_backend`. Both hold `vq->mutex`. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0011",
  "title": "Infinite Loop in handle_tx",
  "concept": "DoS",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Hypothesis: `handle_tx` loops forever. Mechanism: `vhost_exceeds_weight` limits iterations. If that fails, `get_tx_bufs` returns error or empty. Loop breaks. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0012",
  "title": "Race in vhost_net_set_features",
  "concept": "Race Condition",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: Changing features (header length) while IO running corrupts state. Mechanism: `vhost_net_set_features` holds `vq->mutex` for each VQ. `handle_tx/rx` hold `vq->mutex`. Feature update is atomic wrt processing. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0013",
  "title": "Bypass Owner Check in ioctl",
  "concept": "Access Control",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: Call ioctl without ownership. Mechanism: `vhost_net_ioctl` calls `vhost_dev_check_owner` (checks `mm`). `VHOST_NET_SET_BACKEND` checks it. `VHOST_SET_OWNER` sets it. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0014",
  "title": "Memory Leak in vhost_net_open",
  "concept": "Memory Leak",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `kmalloc` failure causes leak. Mechanism: Error paths in `vhost_net_open` verify `kfree` of all allocated structures. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0015",
  "title": "UAF in vhost_net_release",
  "concept": "UAF",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: Accessing device after cleanup. Mechanism: `release` is called on file close. No other references (fd closed). `vhost_net_flush` waits for pending works. Safe.",
  "classification": "UAF",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0016",
  "title": "Bad Pointer in vhost_net_buf_peek",
  "concept": "Memory Corruption",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Hypothesis: Invalid pointer in `rx_ring`. Mechanism: `rx_ring` populated by kernel (tap). Assuming kernel integrity, safe.",
  "classification": "hardening",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0017",
  "title": "Logic Error in vhost_net_tx_select_zcopy",
  "concept": "Logic Error",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `tx_flush` flag ignored. Mechanism: `vhost_net_tx_select_zcopy` checks `!net->tx_flush`. Logic correct.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0018",
  "title": "CPU Exhaustion via Busy Poll",
  "concept": "Resource Exhaustion",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `busy_poll` spins forever. Mechanism: `vhost_can_busy_poll` checks `!need_resched()`. Kernel scheduler can preempt. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0019",
  "title": "vhost_net_ubuf_alloc Failure",
  "concept": "Null Dereference",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `kmalloc` fails, returns NULL/ERR. Mechanism: Checked `IS_ERR`. Safe.",
  "classification": "hardening",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
{
  "file": "drivers/vhost/net.c",
  "scenario_id": "drivers/vhost/net.c-0020",
  "title": "vhost_tx_batch Error Path Leak",
  "concept": "Memory Leak",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Hypothesis: `sendmsg` fails, pages leaked. Mechanism: Error path loops over `batched_xdp` and calls `put_page`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [],
  "derived_from": [],
  "proposed_fix_summary": "None"
}
