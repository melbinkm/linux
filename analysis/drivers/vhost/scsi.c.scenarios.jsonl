{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0001",
  "title": "Integer Overflow in vhost_scsi_calc_sgls leading to OOB access",
  "concept": "Integer overflow in `sgl_count` calculation allowing bypass of pre-allocated SGL limit.",
  "attacker_model": "container_guest",
  "preconditions": [
    "vhost-scsi device configured",
    "Guest capable of sending large I/O requests"
  ],
  "description": "In `vhost_scsi_calc_sgls`, `sgl_count` is calculated via `iov_iter_npages`. If `bytes` is very large, `sgl_count` could be large. The check `if (sgl_count > max_sgls)` protects against exceeding the limit. However, `iov_iter_npages` takes an `int maxpages` (passed as 0xffff). It returns `int`. If the calculated pages exceed INT_MAX, it might return a wrapped negative value or truncated value? `iov_iter_npages` iterates. But looking at `vhost_scsi_mapal`, `prot_bytes` is `size_t`. If `prot_bytes` is huge, `vhost_scsi_calc_sgls` is called. `iov_iter_npages` logic handles large counts by iterating? Actually `iov_iter_npages` returns number of pages. If `bytes` is huge (e.g. close to SIZE_MAX), the number of pages is `bytes >> PAGE_SHIFT`. On 64-bit, this can exceed 32-bit `int`. `vhost_scsi_calc_sgls` stores result in `int sgl_count`. This truncation or overflow could cause the check `sgl_count > max_sgls` to pass incorrectly (if negative or small wrapped positive), leading to `sg_alloc_table_chained` with a wrong count, or subsequent loops writing out of bounds.",
  "classification": "integer-overflow",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:860: sgl_count = iov_iter_npages(iter, 0xffff);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Use proper types for page counts and check for overflows."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0002",
  "title": "Denial of Service via Stalled Worker in vhost_scsi_handle_vq",
  "concept": "A malicious guest can stall the vhost worker thread by sending an infinite stream of requests that don't trigger the weight limit or by exploiting the loop condition.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`vhost_scsi_handle_vq` loops processing descriptors: `do { ... } while (likely(!vhost_exceeds_weight(vq, ++c, 0)));`. `vhost_exceeds_weight` checks if `c` (packet count) exceeds `dev->weight`. However, if `vhost_scsi_get_desc` fails with `ret < 0` (e.g., `EAGAIN` or `ENXIO`), the loop breaks. If `ret == -ENOMEM`, it sends a status and logs, but `c` is incremented. If the guest can trigger an error path that effectively does no work but increments `c`, it yields. But if the guest provides a huge number of descriptors that are valid enough to pass `get_desc` but fail later (e.g. invalid target), the loop continues until weight is exceeded. This is normal behavior. However, if `vhost_scsi_chk_size` fails, it returns error, `vhost_scsi_handle_vq` breaks loop? No, `goto err`. `err:` block breaks if `ret == -ENXIO`. But for `-EIO` (bad target/size), it sends response and continues loop. This is correct weight enforcement. But consider `vhost_scsi_complete_cmd_work`. It iterates `completion_list`. If this list is huge, the worker might be stalled. The completion list is populated by `vhost_scsi_release_cmd` which adds to `svq->completion_list` and kicks worker. If many commands complete at once, the worker processes them all. There is no weight check in `vhost_scsi_complete_cmd_work` loop.",
  "classification": "DoS",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:717: llist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Add a weight/limit check in `vhost_scsi_complete_cmd_work` and requeue work if limit exceeded."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0003",
  "title": "Use-After-Free in vhost_scsi_clear_endpoint race",
  "concept": "Race condition between clearing endpoint and accessing it in TMF or IO paths.",
  "attacker_model": "privileged",
  "preconditions": [
    "Ability to configure vhost-scsi (sysfs/configfs)"
  ],
  "description": "`vhost_scsi_clear_endpoint` sets `vs->vs_tpg` to NULL. It takes `dev.mutex`. It calls `vhost_dev_flush`. It prevents new commands by setting backend to NULL. However, `vhost_scsi_handle_tmf` accesses `tpg->tpg_nexus`. `tpg` is obtained from `vhost_vq_get_backend(vq)`. `vhost_scsi_clear_endpoint` clears backend with `vhost_vq_set_backend(vq, NULL)` under `vq->mutex`. `vhost_scsi_handle_vq` (IO path) also takes `vq->mutex`. This seems synchronized correctly. But what about inflight TMFs? `vhost_scsi_handle_tmf` is called from `vhost_scsi_ctl_handle_vq`, which holds `vq->mutex`. So `clear_endpoint` cannot run concurrently for the same VQ. What about cross-VQ dependencies? `vhost_scsi_clear_endpoint` iterates all VQs. Seems robust.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1680: mutex_lock(&vq->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0004",
  "title": "Resource Leak in vhost_scsi_target_queue_cmd failure",
  "concept": "Leaking memory/state when `target_submit_prep` or `target_submit` fails.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "In `vhost_scsi_target_queue_cmd`, if `target_submit_prep` fails (returns non-zero), the function returns immediately. The `cmd` (vhost_scsi_cmd) was allocated/initialized. `vhost_scsi_handle_vq` called this. If it returns, `vhost_scsi_handle_vq` assumes success (ret=0) and loops. The command is now effectively lost/leaked? `vhost_scsi_handle_vq` sets `ret = 0` after calling `vhost_scsi_target_queue_cmd`. If `target_submit_prep` fails, the `se_cmd` is not submitted. The descriptor `vc.head` is not used/signalled? `cmd` remains in `svq->scsi_cmds` but its state is undefined? `vhost_scsi_release_cmd_res` is never called. This leaks the `inflight` reference and the `cmd` slot in `scsi_cmds`, eventually leading to `TASK_SET_FULL` (DoS).",
  "classification": "resource-exhaustion",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1008: if (target_submit_prep(...)) return;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Handle error from `vhost_scsi_target_queue_cmd` in `vhost_scsi_handle_vq` and release resources."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0005",
  "title": "Host Memory Exhaustion via Integer Underflow in exp_data_len",
  "concept": "Integer underflow when subtracting `prot_bytes` from `exp_data_len`.",
  "attacker_model": "container_guest",
  "preconditions": [
    "T10_PI enabled (VIRTIO_SCSI_F_T10_PI)"
  ],
  "description": "In `vhost_scsi_handle_vq`, `exp_data_len` is derived from `vc.out_size` or `vc.in_size`. `prot_bytes` comes from `v_req_pi.pi_bytesout` or `pi_bytesin` (guest controlled, u32). The code checks: `if (prot_bytes) { exp_data_len -= prot_bytes; ... }`. If `prot_bytes` > `exp_data_len`, this underflows `exp_data_len` (u32) to a huge value. This huge value is passed to `vhost_scsi_mapal`. `vhost_scsi_mapal` calls `vhost_scsi_calc_sgls`. `iov_iter_npages` on huge bytes might return huge count? `vhost_scsi_calc_sgls` checks `sgl_count > max_sgls`. If `exp_data_len` is huge, `sgl_count` will be huge, and the check should catch it. However, `vhost_scsi_mapal` calls `sg_alloc_table_chained` with `sgl_count`. If `sgl_count` calculation overflows/truncates in `vhost_scsi_calc_sgls` (Scenario 0001), then we have an issue. But specifically here: `exp_data_len` underflow. `vhost_scsi_target_queue_cmd` takes `exp_data_len`. TCM core might behave unexpectedly with 4GB+ data length if not validated.",
  "classification": "integer-overflow",
  "impact": "DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1270: exp_data_len -= prot_bytes;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Check if `prot_bytes <= exp_data_len` before subtracting."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0006",
  "title": "Use-After-Free in vhost_scsi_release_cmd_res double free",
  "concept": "Double freeing resources if command is released twice.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_scsi_release_cmd_res` frees scatterlists and pages. It checks `if (tv_cmd->tvc_sgl_count)`. After freeing, it does NOT zero `tvc_sgl_count`. If `vhost_scsi_release_cmd_res` is called twice on the same cmd, it will double free. Is it possible? `vhost_scsi_complete_cmd_work` calls it. `vhost_scsi_handle_vq` calls it on error paths. If `vhost_scsi_handle_vq` calls it on error, and then somehow it gets into completion list? `vhost_scsi_handle_vq` error paths that call `release` usually happen before submission. Once submitted (`vhost_scsi_target_queue_cmd`), `vhost_scsi_handle_vq` forgets it. TCM owns it. TCM calls `queue_data_in` etc., which call `transport_generic_free_cmd`, which calls `release_cmd`, which schedules completion work. Synchronization seems correct (ownership transfer).",
  "classification": "double-free",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:595: if (tv_cmd->tvc_sgl_count)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Set count to 0 after free for safety."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0007",
  "title": "vhost_scsi_hotplug event dropped",
  "concept": "Dropping hotplug events if event VQ is full.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_scsi_send_evt` drops event if `vhost_scsi_allocate_evt` returns NULL (limit reached) or if `vhost_vq_work_queue` fails. If hotplug event is dropped, guest state is inconsistent. Logic sets `vs->vs_events_missed = true`. Future `vhost_scsi_do_evt_work` will send `VIRTIO_SCSI_T_EVENTS_MISSED`. Guest is supposed to rescan. This handles the drop correctly according to spec.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:795: event->event |= cpu_to_vhost32(vq, VIRTIO_SCSI_T_EVENTS_MISSED);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0008",
  "title": "vhost_scsi_map_to_sgl infinite loop with 0 bytes",
  "concept": "Infinite loop if `iov_iter_get_pages2` returns 0 but bytes > 0?",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`iov_iter_get_pages2` returns bytes pinned. If it returns 0? The code: `if (bytes <= 0) return bytes < 0 ? bytes : -EFAULT;`. So it returns error on 0. No infinite loop.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:832: if (bytes <= 0)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0009",
  "title": "T10 PI misaligned buffer handling",
  "concept": "Misaligned data buffer with PI enabled.",
  "attacker_model": "container_guest",
  "preconditions": ["T10_PI enabled"],
  "description": "`vhost_scsi_map_to_sgl` checks for misalignment: `if (!is_prot && ... warning ...)`. It effectively allows misalignment for prot (is_prot=true)? Or if `is_prot` is false? The check is `!is_prot && ...`. So if `is_prot` is true, it skips the check. Does this mean PI buffers can be misaligned? Block layer might complain. But this isn't a vulnerability in vhost-scsi itself, maybe in TCM or block layer.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:841: if (!is_prot &&"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0010",
  "title": "vhost_scsi_get_req LUN validation",
  "concept": "Virtio-SCSI LUN validation.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`vhost_scsi_get_req` checks `*vc->lunp != 1`. Virtio spec says byte 0 should be 1. It logs error `Illegal virtio-scsi lun`. This enforces the spec.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1139: else if (unlikely(*vc->lunp != 1))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0011",
  "title": "vhost_scsi_handle_vq OOB write in vhost_scsi_setup_resp_iovs",
  "concept": "If `in_iovs_cnt` is large, `kcalloc` might fail or `tvc_resp_iovs` logic might be wrong.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`vhost_scsi_setup_resp_iovs` allocates `cmd->tvc_resp_iovs`. `cnt = min(VHOST_SCSI_MAX_RESP_IOVS, in_iovs_cnt)`. `VHOST_SCSI_MAX_RESP_IOVS` is `sizeof(struct virtio_scsi_cmd_resp)`. Wait, that's small (approx 52 bytes). `in_iovs_cnt` is descriptor count. Logic allocates array of `iovec`. Loop copies `in_iovs` to `cmd->tvc_resp_iovs`. Range `0` to `cnt`. `in_iovs` is `&vq->iov[vc.out]`. `vc.in` is the count. `vhost_get_vq_desc` ensures `vc.out + vc.in <= array_size`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1162: cnt = min(VHOST_SCSI_MAX_RESP_IOVS, in_iovs_cnt);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0012",
  "title": "ConfigFS buffer overflow in vhost_scsi_tpg_nexus_store",
  "concept": "Buffer overflow in parsing WWN/NAA.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_scsi_tpg_nexus_store` copies page to `i_port`. `unsigned char i_port[VHOST_SCSI_NAMELEN]`. `if (strlen(page) >= VHOST_SCSI_NAMELEN)` returns `-EINVAL`. `snprintf` is used. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2039: if (strlen(page) >= VHOST_SCSI_NAMELEN)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0013",
  "title": "Memory leak in vhost_scsi_make_nexus failure",
  "concept": "Leak `tv_nexus` if session setup fails.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_scsi_make_nexus` allocates `tv_nexus`. Calls `target_setup_session`. If fails, `kfree(tv_nexus)`. Correct.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1986: kfree(tv_nexus);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0014",
  "title": "vhost_scsi_drop_nexus busy check",
  "concept": "Dropping nexus while in use.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `tv_tpg_port_count` and `tv_tpg_vhost_count`. If non-zero, returns `-EBUSY`. Safe.",
  "classification": "state-machine",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2009: if (tpg->tv_tpg_port_count != 0)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0015",
  "title": "vhost_scsi_set_endpoint race",
  "concept": "Race in setting endpoint vs usage.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Takes `vs->dev.mutex`. Also takes `vhost_scsi_mutex` and `tpg->tv_tpg_mutex`. `target_depend_item` prevents configfs removal. `vhost_scsi_flush(vs)` ensures visibility. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1777: mutex_lock(&vs->dev.mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0016",
  "title": "vhost_scsi_calc_sgls int overflow (revisit)",
  "concept": "Checking `vhost_scsi_calc_sgls` again.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`iov_iter_npages` return type is `int`. If `bytes` is `SIZE_MAX`, `npages` is `SIZE_MAX >> 12` (approx 1 million billions on 64-bit, but return is int). On 64-bit, `int` is 32-bit. `npages` will truncate. `sgl_count` will be truncated. `if (sgl_count > max_sgls)` might pass if truncated value is small. Then `sg_alloc_table_chained` allocates small table. `vhost_scsi_map_iov_to_sgl` iterates `iov_iter`. It will try to map `SIZE_MAX` bytes into small table. `sg_next` will hit NULL or invalid. `vhost_scsi_map_to_sgl` loop `while (bytes)`: `sg_set_page(sg, ...)`, `sg = sg_next(sg)`. If `sg` becomes NULL, it crashes? `sg_next` on last entry returns NULL. `sg_set_page` dereferences `sg`. Crash. This is confirmed if `iov_iter_npages` truncates.",
  "classification": "integer-overflow",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:860: sgl_count = iov_iter_npages(iter, 0xffff);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Check for overflow in sgl_count calculation."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0017",
  "title": "vhost_scsi_get_cmd tag exhaustion",
  "concept": "DoS via tag exhaustion.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`vhost_scsi_get_cmd` uses `sbitmap_get`. If full, returns `ERR_PTR(-ENOMEM)`. `vhost_scsi_handle_vq` handles it: sends `SAM_STAT_TASK_SET_FULL`. Logs. Loops. This is correct behavior (Queue Full).",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:806: pr_warn_once(\"Guest sent too many cmds...\");"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0018",
  "title": "vhost_scsi_complete_cmd_work locking",
  "concept": "Correct locking during completion.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Takes `mutex_lock(&svq->vq.mutex)`. Iterates list. Calls `vhost_add_used`. Calls `vhost_signal`. Correct.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:715: mutex_lock(&svq->vq.mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0019",
  "title": "vhost_scsi_evt_handle_kick missed events",
  "concept": "Handling missed events.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `vs->vs_events_missed` is true, sends `VIRTIO_SCSI_T_NO_EVENT` (should be `EVENTS_MISSED`? No, logic in `do_evt_work` sets `EVENTS_MISSED` flag on event). `evt_handle_kick` sends a dummy event to trigger processing? It calls `vhost_scsi_send_evt`. Safely queues work.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1580: vhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT, 0);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0020",
  "title": "vhost_scsi_ctl_handle_vq unknown type",
  "concept": "Handling unknown control types.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Switch case default: `vq_err`. Continues loop. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1519: vq_err(vq, \"Unknown control request %d\", v_req.type);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0021",
  "title": "vhost_scsi_set_inline_sg_cnt overflow",
  "concept": "Overflow in module param set.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `cnt > VHOST_SCSI_PREALLOC_SGLS`. `VHOST_SCSI_PREALLOC_SGLS` is 2048. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:71: if (cnt > VHOST_SCSI_PREALLOC_SGLS)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0022",
  "title": "vhost_scsi_open allocation failures",
  "concept": "Cleanup on open failure.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Allocates `vs`, `old_inflight`, `vqs`. If any fails, `goto err`. Error paths free previously allocated. Correct.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2237: goto err_local_vqs;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0023",
  "title": "vhost_scsi_ioctl set_features log access",
  "concept": "Checking log access.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "If `VHOST_F_LOG_ALL` set, calls `vhost_log_access_ok`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2152: !vhost_log_access_ok(&vs->dev))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0024",
  "title": "vhost_scsi_check_true demo mode",
  "concept": "TCM demo mode check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Always returns 1. Allows access. Standard for vhost-scsi which relies on configfs setup.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:429: return 1;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0025",
  "title": "vhost_scsi_write_pending execution",
  "concept": "Immediate execution of pending write.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Calls `target_execute_cmd`. Expected for vhost-scsi as data is mapped.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:547: target_execute_cmd(se_cmd);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0026",
  "title": "vhost_scsi_get_desc log_num reset",
  "concept": "Resetting log_num.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Sets `*log_num = 0`. Correct.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1062: *log_num = 0;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0027",
  "title": "vhost_scsi_flush inflight refcounting",
  "concept": "Waiting for inflight requests.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Swaps `inflight_idx`. Decrements old `kref`. Waits for completion. Correct flush logic.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1612: wait_for_completion(&vs->old_inflight[i]->comp);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0028",
  "title": "vhost_scsi_setup_vq_cmds sbitmap init",
  "concept": "Sbitmap initialization.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `sbitmap_init_node`. Checks return. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1700: sbitmap_init_node..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0029",
  "title": "vhost_scsi_set_endpoint verify access",
  "concept": "Verifying ring access before enabling.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Iterates VQs. Calls `vhost_vq_access_ok`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1779: if (!vhost_vq_access_ok(&vs->vqs[index].vq))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0030",
  "title": "vhost_scsi_tmf_resp_work log write",
  "concept": "Logging TMF response.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Calls `vhost_scsi_log_write`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1385: vhost_scsi_log_write(&tmf->svq->vq, tmf->tmf_log, tmf->tmf_log_num);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0031",
  "title": "vhost_scsi_handle_tmf lun reset",
  "concept": "Handling LUN reset.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `subtype == LOGICAL_UNIT_RESET`. Calls `target_submit_tmr`. Correct.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1432: VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0032",
  "title": "vhost_scsi_get_tpgt check",
  "concept": "Retrieving TPGT.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Container of. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:449: return tpg->tport_tpgt;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0033",
  "title": "vhost_scsi_to_tcm_attr conversion",
  "concept": "Attribute conversion.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Maps Virtio attrs to TCM attrs. Default SIMPLE. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:963: return TCM_SIMPLE_TAG;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0034",
  "title": "vhost_scsi_make_tpg name check",
  "concept": "Checking TPG name format.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `tpgt_` prefix. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2102: if (strstr(name, \"tpgt_\") != name)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0035",
  "title": "vhost_scsi_make_tport protocol check",
  "concept": "Protocol ID from name.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `naa.`, `fc.`, `iqn.`. Sets proto ID. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2150: tport->tport_proto_id = SCSI_PROTOCOL_SAS;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0036",
  "title": "vhost_scsi_copy_iov_to_sgl invalid copy",
  "concept": "Copy from iter failure.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `copy_page_from_iter` returns short, returns `-EFAULT`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:926: ret = -EFAULT;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0037",
  "title": "vhost_scsi_mapal prot SGL count",
  "concept": "SGL count check for PI.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `calc_sgls` result. If error, returns. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:962: if (ret)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0038",
  "title": "vhost_scsi_chk_size underflow checks",
  "concept": "Buffer size validation.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `in_size < rsp_size` and `out_size < req_size`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1115: if (unlikely(vc->in_size < vc->rsp_size))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0039",
  "title": "vhost_scsi_complete_events locking",
  "concept": "Locking during event completion.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Takes `vq->mutex`. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:655: mutex_lock(&vq->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0040",
  "title": "vhost_scsi_alloc_evt failure",
  "concept": "Event allocation fail.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Sets `vs_events_missed`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:575: vs->vs_events_missed = true;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0041",
  "title": "vhost_scsi_do_evt_work backend check",
  "concept": "Backend check in event work.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `vhost_vq_get_backend`. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:605: if (!vhost_vq_get_backend(vq))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0042",
  "title": "vhost_scsi_tpg_attrib_fabric_prot_type_store val check",
  "concept": "Attribute value check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `val != 0 && val != 1 && val != 3`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1935: if (val != 0 && val != 1 && val != 3)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0043",
  "title": "vhost_scsi_inline_sg_cnt_op limits",
  "concept": "Inline SG count limit.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `cnt > VHOST_SCSI_PREALLOC_SGLS`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:71: max inline_sg_cnt"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0044",
  "title": "vhost_scsi_handle_vq CDB size check",
  "concept": "Checking CDB size.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1305: if (unlikely(scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0045",
  "title": "vhost_scsi_handle_vq nexus check",
  "concept": "Checking active nexus.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `!nexus`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1312: if (!nexus)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0046",
  "title": "vhost_scsi_copy_sgl_to_iov failure",
  "concept": "Handling copy failure.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `copy_page_to_iter` fails, logs error. Returns -1. `vhost_scsi_complete_cmd_work` sends `BAD_TARGET`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:695: return -1;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0047",
  "title": "vhost_scsi_exit cleanup",
  "concept": "Module exit cleanup.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Unregisters template and deregisers misc. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2370: target_unregister_template..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0048",
  "title": "vhost_scsi_make_tpg alloc failure",
  "concept": "Allocation failure.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `tpg`. Returns `ERR_PTR`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2112: if (!tpg)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0049",
  "title": "vhost_scsi_drop_nexus check active counts",
  "concept": "Checking counts before drop.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `tv_tpg_port_count` and `tv_tpg_vhost_count`. Safe.",
  "classification": "state-machine",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2009: if (tpg->tv_tpg_port_count != 0)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0050",
  "title": "vhost_scsi_tpg_nexus_store buffer size",
  "concept": "Checking page size.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `strlen(page) >= NAMELEN`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:2039: if (strlen(page) >= VHOST_SCSI_NAMELEN)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0051",
  "title": "vhost_scsi_copy_cmd_log allocation",
  "concept": "Log allocation.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Allocates `tvc_log`. Checks `!tvc_log`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:485: if (unlikely(!cmd->tvc_log))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0052",
  "title": "vhost_scsi_log_write NULL check",
  "concept": "Log write checks.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `!log_num || !log`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:502: if (likely(!log_num || !log))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0053",
  "title": "vhost_scsi_release_cmd_res cleanup",
  "concept": "Cleaning up resources.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Frees pages, iter, iov, table. Clears bit. Puts inflight. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:537: vhost_scsi_put_inflight(inflight);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0054",
  "title": "vhost_scsi_map_iov_to_sgl invalid ret",
  "concept": "Handling map error.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `ret < 0`, reverts and returns error. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:947: vhost_scsi_revert_map_iov_to_sgl..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0055",
  "title": "vhost_scsi_ctl_handle_vq backend check",
  "concept": "Checking backend.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `vhost_vq_get_backend`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1475: if (!vhost_vq_get_backend(vq))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0056",
  "title": "vhost_scsi_get_req null tpg check",
  "concept": "Checking TPG existence.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `!tpg` after lookup. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1145: if (unlikely(!tpg))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0057",
  "title": "vhost_scsi_destroy_vq_cmds null check",
  "concept": "Checking scsi_cmds.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `!svq->scsi_cmds`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1669: if (!svq->scsi_cmds)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0058",
  "title": "vhost_scsi_setup_vq_cmds allocation",
  "concept": "Allocation checks.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks kcalloc returns. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1696: if (!svq->scsi_cmds)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0059",
  "title": "vhost_scsi_setup_vq_cmds sgl allocation",
  "concept": "SGL allocation check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `!tv_cmd->sgl`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1712: if (!tv_cmd->sgl)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/scsi.c",
  "scenario_id": "drivers/vhost/scsi.c-0060",
  "title": "vhost_scsi_set_endpoint access ok",
  "concept": "Checking vq access.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `vhost_vq_access_ok`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/scsi.c:1779: if (!vhost_vq_access_ok(&vs->vqs[index].vq))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
