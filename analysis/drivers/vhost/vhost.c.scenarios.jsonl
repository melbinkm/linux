{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0001",
  "title": "Integer Overflow in vhost_log_write leading to OOB write",
  "concept": "The `vhost_log_write` function handles logging of dirty pages. A 32-bit overflow in `write_length` calculation can lead to OOB writes.",
  "attacker_model": "container_guest",
  "preconditions": [
    "vhost device enabled with VHOST_F_LOG_ALL"
  ],
  "description": "In `log_write` (called by `vhost_log_write`), `write_length += write_address % VHOST_PAGE_SIZE;` is performed. `write_length` is `u64`. If `len` (from `vhost_log_write`) is `U64_MAX` (used to indicate logging all descriptor pages), and `write_address` is unaligned, `write_length` might wrap if it were 32-bit, but it is 64-bit here. However, `log_write` iterates with `write_page += 1`. If `log_base` + `write_page` overflows, `set_bit_to_user` might write to an unexpected address. More critically, in `vhost_log_write`, the loop `for (i = 0; i < log_num; ++i)` relies on `log[i].len`. If the guest provides a huge length, `log_write` loops for a long time. But specifically, check `log_write_hva`: `end = min(u->addr - 1 + u->size, hva - 1 + len);`. If `hva + len` overflows 64-bit, `end` might be small, causing logic errors in range calculation.",
  "classification": "integer-overflow",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1680: write_length += write_address % VHOST_PAGE_SIZE;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Use check_add_overflow."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0002",
  "title": "Integer Overflow in vhost_set_memory leading to Invalid IOTLB Range",
  "concept": "Integer overflow in `guest_phys_addr + memory_size` allows wrapping around the address space, potentially bypassing overlap checks.",
  "attacker_model": "privileged",
  "preconditions": [
    "Privileged user (CAP_SYS_ADMIN or owner of vhost device)"
  ],
  "description": "In `vhost_set_memory`, the code calculates `region->guest_phys_addr + region->memory_size - 1`. If `guest_phys_addr` is large and `memory_size` is large, this sum wraps around. `vhost_iotlb_add_range` is then called with the wrapped end address. This might allow creating a memory region that effectively covers the entire address space or overlaps unexpectedly, leading to incorrect address translation.",
  "classification": "integer-overflow",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1208: region->guest_phys_addr + region->memory_size - 1"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Check for overflow before calling vhost_iotlb_add_range."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0003",
  "title": "Unbounded Loop in log_write_hva causing DoS",
  "concept": "A malicious guest can trigger an expensive loop in `log_write_hva` by providing a large length.",
  "attacker_model": "container_guest",
  "preconditions": [
    "IOTLB enabled",
    "Logging enabled"
  ],
  "description": "`log_write_hva` iterates while `len` > 0. Inside the loop, it iterates over all `umem` entries. If `umem` has many entries and `len` is very large (e.g., covering the whole address space), and the fragmentation is high (small `min`), this can consume significant CPU time. However, `cond_resched()` is not called in this loop. This could lead to soft lockups.",
  "classification": "DoS",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1700: while (len) {"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Add cond_resched() in the loop."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0004",
  "title": "Memory Leak in vhost_new_msg failure",
  "concept": "Failure to allocate message node doesn't free resources?",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_new_msg` allocates a node. If allocation fails, it returns NULL. The caller `vhost_iotlb_miss` handles this by returning `-ENOMEM`. No leak observed here.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2370: if (!node) return NULL;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0005",
  "title": "Use-After-Free in vhost_iotlb_miss with RCU",
  "concept": "Accessing `vq` or `dev` after it might be freed.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_iotlb_miss` uses `vq->dev`. It queues a message. The `dev` is protected by `dev->mutex` or reference counts? `vhost_iotlb_miss` is called during translation. Translation happens under `vq->mutex`. `vhost_dev_cleanup` takes `vq->mutex` before resetting. So `vq` should be stable. However, `vhost_iotlb_miss` adds to `dev->read_list`. If `dev` is being cleaned up concurrently, `vhost_clear_msg` clears the list. We need to ensure `vhost_iotlb_miss` doesn't run after cleanup starts.",
  "classification": "race-condition",
  "impact": "UAF",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1075: mutex_lock(&d->vqs[i]->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Locking seems sufficient."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0006",
  "title": "vhost_worker_ioctl Use-After-Free via Race",
  "concept": "Race between `VHOST_FREE_WORKER` and worker usage.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_worker_ioctl` handles `VHOST_FREE_WORKER`. It finds the worker, checks `attachment_cnt`, flushes, and destroys it. If another thread attaches the worker (via `VHOST_ATTACH_VRING_WORKER`) concurrently? Both take `dev->mutex` (via `vhost_worker_ioctl` locking or implicit?). `vhost_worker_ioctl` is called via `vhost_dev_ioctl`? No, `vhost_worker_ioctl` is exported but where is it called? It seems it's not called by `vhost_dev_ioctl` directly in this file, but by `vhost_net` etc? Wait, `vhost.c` exports `vhost_worker_ioctl` but `vhost_dev_ioctl` doesn't call it. Drivers must call it. If drivers wrap it with `dev->mutex`, it's safe. If not, race exists.",
  "classification": "race-condition",
  "impact": "UAF",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:662: mutex_lock(&worker->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Ensure callers hold dev->mutex."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0007",
  "title": "Double Free in vhost_set_memory Error Path",
  "concept": "Double freeing `newmem` or `newumem` on error.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_set_memory` allocates `newmem` and `newumem`. If `vhost_iotlb_add_range` fails (goto err), it calls `vhost_iotlb_free(newumem)` and `kvfree(newmem)`. This is correct. If `memory_access_ok` fails, same path. No double free.",
  "classification": "double-free",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1229: err: vhost_iotlb_free(newumem); kvfree(newmem);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0008",
  "title": "vhost_get_vq_desc Infinite Loop Detection Bypass",
  "concept": "Bypassing loop detection by manipulating descriptor chains.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`vhost_get_vq_desc` has a loop counter `found` to prevent infinite loops in descriptor chains (cycles). `if (++found > vq->num) return -EINVAL;`. This check seems robust against simple cycles. `get_indirect` also has a check. `if (++found > count)`. `count` is derived from `len / sizeof desc`. If `count` is huge, `found` can be huge. But `count` is checked `> USHRT_MAX + 1`. So max loop is ~65k. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2024: if (unlikely(++found > vq->num))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0009",
  "title": "Uninitialized memory leak in vhost_new_msg",
  "concept": "Leaking kernel stack/heap via padding in `vhost_msg_node`.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_new_msg` uses `kzalloc`, so the node and embedded message are zero-initialized. This prevents leaks of uninitialized memory to userspace when the message is read.",
  "classification": "info-leak",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2370: struct vhost_msg_node *node = kzalloc(sizeof(*node), GFP_KERNEL);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0010",
  "title": "vhost_iotlb_itree_first Logic Error",
  "concept": "Incorrect interval tree lookup leading to missed mappings.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`vhost_iotlb_itree_first` (external) is used to find mappings. The loop in `translate_desc` handles fragmentation: `map->start > addr` check implies a hole. `if (map == NULL || map->start > addr)`. This correctly identifies missing mappings (holes) and triggers `vhost_iotlb_miss` or returns error. Logic seems correct.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1913: if (map == NULL || map->start > addr)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0011",
  "title": "Integer Overflow in vhost_vring_set_addr",
  "concept": "Overflow in address validation checks on 32-bit systems.",
  "attacker_model": "privileged",
  "preconditions": ["32-bit Host"],
  "description": "`vhost_vring_set_addr` checks: `if ((u64)(unsigned long)a.desc_user_addr != a.desc_user_addr)`. On 32-bit, `unsigned long` is 32-bit. Casting to `u64` zero-extends. If `a.desc_user_addr` (u64) has high bits set, the check fails. This correctly prevents setting addresses > 4GB on 32-bit kernels if userspace tries to pass them (though `void __user *` is 32-bit anyway). The check is actually verifying that the 64-bit value passed from userspace fits in `unsigned long`.",
  "classification": "integer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1301: if ((u64)(unsigned long)a.desc_user_addr != a.desc_user_addr)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0012",
  "title": "Race Condition in vhost_dev_cleanup vs vhost_worker_free",
  "concept": "Concurrent cleanup leading to UAF of worker.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_dev_cleanup` calls `vhost_workers_free`. `vhost_workers_free` iterates `worker_xa` and destroys workers. It uses `xa_for_each`. `vhost_worker_destroy` calls `xa_erase`. Modifying the xarray while iterating? `xa_for_each` is safe for concurrent deletion if locking is correct. `vhost_dev_cleanup` is usually called under `dev->mutex` (e.g., `vhost_vsock_dev_release`). If called without lock, race is possible. `vhost_net_release` calls `vhost_dev_cleanup`. `vhost_dev_cleanup` does NOT take `dev->mutex`. It assumes exclusive access (refcount 0).",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:860: vhost_workers_free(dev);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "Caller ensures exclusion."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0013",
  "title": "vhost_iotlb_miss Allocation Failure Handling",
  "concept": "If `vhost_new_msg` fails, translation fails.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "If `vhost_new_msg` returns NULL, `vhost_iotlb_miss` returns `-ENOMEM`. `translate_desc` propagates this. `vhost_get_vq_desc` propagates this. The device stops processing. This is a DoS (denial of service) if the attacker can force OOM, but it's a standard failure mode.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1040: return -ENOMEM;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0014",
  "title": "Recursive Indirect Descriptors",
  "concept": "Guest providing infinite recursion of indirect descriptors.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`get_indirect` checks `if (unlikely(desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)))`. It logs an error `Nested indirect descriptor` and returns `-EINVAL`. This explicitly forbids nested indirect descriptors, preventing recursion attacks.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1967: Nested indirect descriptor"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0015",
  "title": "vhost_process_iotlb_msg integer overflow validation",
  "concept": "Validating IOTLB message ranges.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_process_iotlb_msg` calls `umem_access_ok`. `umem_access_ok` calls `vhost_overflow(uaddr, size)`. `vhost_overflow` checks `uaddr + size` wrap. This prevents adding invalid ranges that wrap around the address space.",
  "classification": "integer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1010: if (vhost_overflow(uaddr, size))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0016",
  "title": "vhost_chr_write_iter Buffer Overread",
  "concept": "Reading beyond buffer in `write_iter`.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`vhost_chr_write_iter` uses `copy_from_iter`. It checks return values. It advances the iter. It checks `sizeof(type)`, `sizeof(asid)`, `sizeof(msg)`. If the user provides insufficient data, `copy_from_iter` returns partial count, check fails, returns `-EINVAL` or `-EFAULT`. Safe.",
  "classification": "info-leak",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1107: if (ret != sizeof(type))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0017",
  "title": "vhost_log_write_hva Buffer Overread",
  "concept": "Logging to invalid HVA.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`log_write_hva` iterates `umem`. `start = max(u->addr, hva)`. `end = min(...)`. If `hva` is not in any `umem` range, `hit` remains false. Returns `-EFAULT`. `log_write` uses `pin_user_pages_fast`. If address is invalid, pinning fails, returns error. Safe.",
  "classification": "UAF",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1718: if (!hit) return -EFAULT;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0018",
  "title": "Use of uninitialized memory in vhost_vring_ioctl(VHOST_SET_VRING_KICK)",
  "concept": "Using uninitialized `eventfp`.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "If `f.fd == VHOST_FILE_UNBIND`, `eventfp = NULL`. Else `eventfd_fget(f.fd)`. If `IS_ERR`, returns. If valid, `eventfp` is set. Then `vq->kick` is updated. `eventfp` is always initialized.",
  "classification": "UAF",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1406: eventfp = f.fd == VHOST_FILE_UNBIND ? NULL : eventfd_fget(f.fd);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0019",
  "title": "vhost_dev_init locking",
  "concept": "Initializing mutexes.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_dev_init` initializes `dev->mutex` and `vq->mutex`. Correctly done before any usage.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:544: mutex_init(&dev->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0020",
  "title": "vhost_get_user_slow Non-Atomic Access",
  "concept": "Handling split pages in userspace access.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "`__vhost_get_user_slow` calls `translate_desc`. If `ret != 1` (mapped to multiple iovecs), it returns NULL (failure). It logs \"Non atomic userspace memory access\". This means `vhost` (for some operations) requires the data to be contiguous in physical/IOTLB space? `__vhost_get_user` is used for `vhost_get_avail`, `vhost_get_used` etc (metadata). Ring structures must be contiguous in HVA/GPA space translated. If not, it fails safely.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1161: if (ret != 1 || vq->iotlb_iov[0].iov_len != size)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0021",
  "title": "vhost_vring_set_num resizing check",
  "concept": "Resizing ring with active backend.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `if (vq->private_data) return -EBUSY;`. This prevents resizing while the backend is active, avoiding memory corruption or state inconsistency.",
  "classification": "state-machine",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1270: if (vq->private_data) return -EBUSY;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0022",
  "title": "vhost_dev_ioctl VHOST_GET_FEATURES copy_to_user check",
  "concept": "Checking return value of copy_to_user.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "The return value of `copy_to_user` is checked. Returns `-EFAULT` if it fails. Safe.",
  "classification": "info-leak",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1580: if (copy_to_user(argp, &features, sizeof(features)))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0023",
  "title": "vhost_dev_ioctl VHOST_SET_LOG_BASE validation",
  "concept": "Validating log base address.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `(u64)(unsigned long)p != p`. This checks if the user pointer fits in the kernel's pointer size (relevant for compat ioctls?). Also calls `vq_log_access_ok`. Safe.",
  "classification": "integer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1595: if ((u64)(unsigned long)p != p)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0024",
  "title": "vhost_init_device_iotlb allocation failure",
  "concept": "Handling allocation failure during IOTLB init.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "If `iotlb_alloc()` fails, returns `-ENOMEM`. Existing `oiotlb` is preserved? No, `d->iotlb` is assigned `niotlb`. `oiotlb` is `d->iotlb`. If `niotlb` alloc fails, `return -ENOMEM`. `d->iotlb` remains `oiotlb`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1505: if (!niotlb) return -ENOMEM;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0025",
  "title": "vhost_chr_write_iter type check",
  "concept": "Checking message type in write iter.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks `type` against `VHOST_IOTLB_MSG` and `VHOST_IOTLB_MSG_V2`. Returns `-EINVAL` if unknown. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1115: default: ret = -EINVAL; goto done;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0026",
  "title": "vhost_chr_write_iter zero size check",
  "concept": "Checking for zero size update.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks `if (msg.type == VHOST_IOTLB_UPDATE && msg.size == 0)`. Returns `-EINVAL`. Prevents adding empty ranges. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1145: if (msg.type == VHOST_IOTLB_UPDATE && msg.size == 0)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0027",
  "title": "vhost_chr_read_iter buffer size check",
  "concept": "Checking read buffer size.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks `iov_iter_count(to) < size`. Returns 0 if too small. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1175: if (iov_iter_count(to) < size) return 0;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0028",
  "title": "vhost_chr_poll list empty check",
  "concept": "Polling wait queue.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks `!list_empty(&dev->read_list)`. Sets `EPOLLIN | EPOLLRDNORM`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1165: if (!list_empty(&dev->read_list))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0029",
  "title": "vhost_dev_set_owner owner check",
  "concept": "Preventing re-setting owner.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `vhost_dev_has_owner(dev)`. Returns `-EBUSY`. Prevents hijacking. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:750: if (vhost_dev_has_owner(dev))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0030",
  "title": "vhost_attach_mm refcounting",
  "concept": "Managing MM refcounts.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `get_task_mm(current)` or `mmgrab`. `vhost_detach_mm` calls `mmput` or `mmdrop`. Correctly balances refs.",
  "classification": "refcount",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:595: dev->mm = get_task_mm(current);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0031",
  "title": "vhost_dev_free_iovecs cleanup",
  "concept": "Freeing iovecs.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Iterates VQs and calls `vhost_vq_free_iovecs`. `vhost_vq_free_iovecs` frees `indirect`, `log`, `heads`. Sets pointers to NULL. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:485: vhost_vq_free_iovecs(dev->vqs[i]);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0032",
  "title": "vhost_iotlb_add_range overflow check in iotlb.c",
  "concept": "Checking add range parameters.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "`vhost_iotlb_add_range` (in iotlb.c, but called here) likely checks `start > end`. `vhost_set_memory` passes `addr + size - 1`. If overflow occurred, `end < start`. `vhost_iotlb_add_range` should fail. If `iotlb.c` is robust, this is safe. (See Scenario 0002 for the specific overflow call site).",
  "classification": "integer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/iotlb.c: ... check start > end ..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0033",
  "title": "vhost_worker_create allocation check",
  "concept": "Worker allocation failure.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `!worker` after `kzalloc`. Returns NULL. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:640: if (!worker) return NULL;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0034",
  "title": "vhost_vq_work_queue NULL worker check",
  "concept": "Queuing work to NULL worker.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "`rcu_dereference(vq->worker)`. Checks if worker is NULL. If so, returns false. Safe.",
  "classification": "UAF",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:285: if (worker)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0035",
  "title": "vhost_poll_start EPOLLERR check",
  "concept": "Handling poll error.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks `mask & EPOLLERR`. calls `vhost_poll_stop`. Returns `-EINVAL`. Safe.",
  "classification": "state-machine",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:230: if (mask & EPOLLERR)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0036",
  "title": "vhost_dev_init iov_limit",
  "concept": "Initializing limits.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Initializes `iov_limit`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:540: dev->iov_limit = iov_limit;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0037",
  "title": "vhost_init_is_le features check",
  "concept": "Endianness initialization.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks `VIRTIO_F_VERSION_1`. Sets `vq->is_le`. Correct.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:130: vq->is_le = vhost_has_feature(vq, VIRTIO_F_VERSION_1) || !vq->user_be;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0038",
  "title": "vhost_vring_set_num valid num check",
  "concept": "Validating ring size.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `!s.num`, `s.num > 0xffff`, `s.num & (s.num - 1)`. Must be power of 2 and valid range. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1280: if (!s.num || s.num > 0xffff || (s.num & (s.num - 1)))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0039",
  "title": "vhost_vring_set_addr log support check",
  "concept": "Checking log feature.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `a.flags & ~(0x1 << VHOST_VRING_F_LOG)`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1295: if (a.flags & ~(0x1 << VHOST_VRING_F_LOG))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0040",
  "title": "vhost_vring_set_addr alignment check",
  "concept": "Checking address alignment.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks alignment of avail, used, log addr. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1309: if ((a.avail_user_addr & (VRING_AVAIL_ALIGN_SIZE - 1)) ..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0041",
  "title": "vhost_vring_ioctl base check",
  "concept": "Checking active backend for set base.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `vq->private_data`. Returns `-EBUSY`. Safe.",
  "classification": "state-machine",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1360: if (vq->private_data)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0042",
  "title": "vhost_vring_ioctl get base index",
  "concept": "Getting base index.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Uses `vq->last_avail_idx`. Handles packed ring. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1385: s.num = vq->last_avail_idx;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0043",
  "title": "vhost_vring_ioctl set kick fd error",
  "concept": "Setting kick fd.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `IS_ERR(eventfp)`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1405: if (IS_ERR(eventfp))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0044",
  "title": "vhost_vring_ioctl set call fd error",
  "concept": "Setting call fd.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `IS_ERR(ctx)`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1425: if (IS_ERR(ctx))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0045",
  "title": "vhost_vring_ioctl set err fd error",
  "concept": "Setting err fd.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `IS_ERR(ctx)`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1440: if (IS_ERR(ctx))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0046",
  "title": "vhost_set_backend_features check",
  "concept": "Setting backend features.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Sets `vq->acked_backend_features`. Locking used. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2425: mutex_lock(&dev->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0047",
  "title": "vhost_log_access_ok check",
  "concept": "Validating log access.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `memory_access_ok`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1150: return memory_access_ok(dev, dev->umem, 1);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0048",
  "title": "vhost_vq_access_ok check",
  "concept": "Validating VQ access.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `vq_log_access_ok` and `vq_access_ok`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1180: if (!vq_log_access_ok(vq, vq->log_base))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0049",
  "title": "vhost_worker_queue bit test",
  "concept": "Queueing work.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Uses `test_and_set_bit` to avoid double queueing. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:260: if (!test_and_set_bit(VHOST_WORK_QUEUED, &work->flags))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0050",
  "title": "vhost_poll_wakeup mask check",
  "concept": "Wakeup mask.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Checks key poll mask. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:190: if (!(key_to_poll(key) & poll->mask))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0051",
  "title": "vhost_poll_wakeup worker use",
  "concept": "Wakeup worker.",
  "attacker_model": "local_unprivileged",
  "preconditions": [],
  "description": "Uses worker if configured. Else function directly. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:193: if (!poll->dev->use_worker)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0052",
  "title": "vhost_dev_flush loop",
  "concept": "Flushing device.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Iterates workers and flushes. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:320: xa_for_each(&dev->worker_xa, i, worker)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0053",
  "title": "vhost_vq_has_work rcu",
  "concept": "Checking work rcu.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Uses `rcu_read_lock`. Checks worker and list. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:330: rcu_read_lock();"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0054",
  "title": "vhost_vq_reset memset",
  "concept": "Resetting VQ.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Resets fields. Zeros features. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:370: virtio_features_zero(vq->acked_features_array);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0055",
  "title": "vhost_run_work_kthread_list loop",
  "concept": "Worker loop.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Loops until kthread_should_stop. Processes list. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:395: if (kthread_should_stop())"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0056",
  "title": "vhost_run_work_list processing",
  "concept": "Processing work list.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Deletes list. Reverses order. Processes safe. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:430: node = llist_del_all(&worker->work_list);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0057",
  "title": "vhost_worker_killed locking",
  "concept": "Killing worker.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Locks worker mutex. Sets killed. Iterates VQs. Locks VQ mutex. Detaches. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:455: mutex_lock(&worker->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0058",
  "title": "vhost_dev_alloc_iovecs failure",
  "concept": "Allocating iovecs.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Allocates arrays. If failure, calls `vhost_vq_free_iovecs`. Returns `-ENOMEM`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:500: goto err_nomem;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0059",
  "title": "vhost_exceeds_weight check",
  "concept": "Weight check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks packet count and byte weight. Polls if exceeded. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:515: if ((dev->byte_weight && ...))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0060",
  "title": "vhost_dev_init zeroing",
  "concept": "Device init.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Initializes lists and mutexes. Resets VQs. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:560: vhost_vq_reset(dev, vq);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0061",
  "title": "vhost_attach_cgroups_work implementation",
  "concept": "Attaching cgroups.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `cgroup_attach_task_all`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:585: cgroup_attach_task_all(s->owner, current);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0062",
  "title": "vhost_attach_task_to_cgroups flush",
  "concept": "Flush during cgroup attach.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Locks mutex. Queues work. Flushes. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:600: __vhost_worker_flush(worker);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0063",
  "title": "vhost_worker_destroy cleanup",
  "concept": "Destroying worker.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Erases from xa. Stops. Frees. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:655: kfree(worker);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0064",
  "title": "vhost_workers_free iteration",
  "concept": "Freeing all workers.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Clears pointers. Iterates xa. Destroys. Destroys xa. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:670: xa_destroy(&dev->worker_xa);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0065",
  "title": "vhost_task_worker_create alloc",
  "concept": "Creating task worker.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Creates task. Allocates xa id. Starts task. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:710: vhost_task_create..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0066",
  "title": "vhost_kthread_worker_create alloc",
  "concept": "Creating kthread worker.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Creates kthread. Allocates xa id. Attaches cgroups. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:730: kthread_create..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0067",
  "title": "__vhost_vq_attach_worker refcounting",
  "concept": "Attaching worker.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Increments `attachment_cnt`. Handles old worker. Flushes old worker. Safe.",
  "classification": "refcount",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:780: worker->attachment_cnt++;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0068",
  "title": "vhost_vq_attach_worker validation",
  "concept": "Validating attachment.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `use_worker`. Finds worker in xa. Checks ID. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:835: if (!worker || worker->id != info->worker_id)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0069",
  "title": "vhost_free_worker check",
  "concept": "Freeing worker check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `attachment_cnt`. If busy, returns error. Safe.",
  "classification": "refcount",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:875: if (worker->attachment_cnt || worker->killed)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0070",
  "title": "vhost_get_vq_from_user bounds",
  "concept": "User VQ index check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `idx >= dev->nvqs`. Uses `array_index_nospec`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:900: idx = array_index_nospec(idx, dev->nvqs);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0071",
  "title": "vhost_worker_ioctl permissions",
  "concept": "Worker ioctl check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks owner. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:920: ret = vhost_dev_check_owner(dev);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0072",
  "title": "vhost_worker_ioctl NEW_WORKER check",
  "concept": "New worker check.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `fork_owner`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:930: if (!dev->fork_owner)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0073",
  "title": "vhost_iotlb_notify_vq loop",
  "concept": "Notifying VQs of IOTLB change.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Iterates pending list. Checks overlap. Polls. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1085: vhost_poll_queue(&node->vq->poll);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0074",
  "title": "umem_access_ok checks",
  "concept": "Checking umem access.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks overflow. Checks `access_ok`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1100: if (vhost_overflow(uaddr, size))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0075",
  "title": "vhost_process_iotlb_msg UPDATE logic",
  "concept": "Handling IOTLB update.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `dev->iotlb`. Checks `umem_access_ok`. Calls `vhost_iotlb_add_range`. Notifies. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1125: case VHOST_IOTLB_UPDATE:"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0076",
  "title": "vhost_process_iotlb_msg INVALIDATE logic",
  "concept": "Handling IOTLB invalidate.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Checks `dev->iotlb`. Calls `vhost_iotlb_del_range`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1140: case VHOST_IOTLB_INVALIDATE:"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0077",
  "title": "vhost_iotlb_miss allocation",
  "concept": "Allocating miss message.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Calls `vhost_new_msg`. If NULL, returns `-ENOMEM`. Safe.",
  "classification": "resource-exhaustion",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1225: if (!node) return -ENOMEM;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0078",
  "title": "vq_access_ok iotlb bypass",
  "concept": "Access OK with IOTLB.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "If `vq->iotlb`, returns true (validated later). Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1255: if (vq->iotlb) return true;"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0079",
  "title": "iotlb_access_ok loop",
  "concept": "Checking access with IOTLB.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Iterates ranges. Checks permissions. Updates meta. Returns true if covered. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1285: while (len > s)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0080",
  "title": "vq_meta_prefetch logic",
  "concept": "Prefetching meta.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Calls `iotlb_access_ok` for desc, avail, used. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1310: return iotlb_access_ok..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0081",
  "title": "vhost_log_access_ok check",
  "concept": "Checking log access.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Calls `memory_access_ok`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1325: return memory_access_ok..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0082",
  "title": "translate_desc overflow check",
  "concept": "Checking buffer size in translate.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `ret >= iov_size`. Returns `-ENOBUFS`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1850: if (unlikely(ret >= iov_size))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0083",
  "title": "next_desc flags check",
  "concept": "Checking next flag.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `VRING_DESC_F_NEXT`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1885: if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0084",
  "title": "get_indirect length check",
  "concept": "Indirect length sanity.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `len % sizeof desc`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1900: if (unlikely(len % sizeof desc))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0085",
  "title": "get_indirect loop check",
  "concept": "Indirect loop detection.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `found > count`. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1925: if (unlikely(++found > count))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0086",
  "title": "get_indirect nested check",
  "concept": "Nested indirect check.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `VRING_DESC_F_INDIRECT`. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:1935: if (unlikely(desc.flags & cpu_to_vhost16(vq, VRING_DESC_F_INDIRECT)))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0087",
  "title": "vhost_get_vq_desc_n invalid head",
  "concept": "Head index check.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `head >= vq->num`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2000: if (unlikely(head >= vq->num))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0088",
  "title": "vhost_get_vq_desc_n descriptor index check",
  "concept": "Descriptor index check.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `i >= vq->num`. Safe.",
  "classification": "buffer-overflow",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2015: if (unlikely(i >= vq->num))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0089",
  "title": "vhost_get_vq_desc_n loop check",
  "concept": "Loop detection.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `found > vq->num`. Safe.",
  "classification": "DoS",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2020: if (unlikely(++found > vq->num))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0090",
  "title": "vhost_get_vq_desc_n descriptor get",
  "concept": "Getting descriptor failure.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks return of `vhost_get_desc`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2025: if (unlikely(ret))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0091",
  "title": "__vhost_add_used_n log used",
  "concept": "Logging used update.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Calls `log_used`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2150: log_used(vq, ...)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0092",
  "title": "vhost_add_used_n_ooo check",
  "concept": "Out of order used check.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Handles wrapping. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2170: if (n < count)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0093",
  "title": "vhost_add_used_n_in_order nheads check",
  "concept": "Checking nheads.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `!nheads`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2190: if (!nheads)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0094",
  "title": "vhost_notify feature check",
  "concept": "Checking notify on empty.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `VIRTIO_F_NOTIFY_ON_EMPTY`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2235: if (vhost_has_feature...)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0095",
  "title": "vhost_notify event idx check",
  "concept": "Checking event idx.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `VIRTIO_RING_F_EVENT_IDX`. Calls `vring_need_event`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2255: return vring_need_event..."
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0096",
  "title": "vhost_signal call_ctx check",
  "concept": "Checking call ctx.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `vq->call_ctx.ctx`. Calls `vhost_notify`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2265: if (vq->call_ctx.ctx && vhost_notify(dev, vq))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0097",
  "title": "vhost_vq_avail_empty check",
  "concept": "Checking avail empty.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Compares `avail_idx` and `last_avail_idx`. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2290: if (vq->avail_idx != vq->last_avail_idx)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0098",
  "title": "vhost_enable_notify check",
  "concept": "Enabling notify.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `VRING_USED_F_NO_NOTIFY`. Updates flags. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2305: if (!(vq->used_flags & VRING_USED_F_NO_NOTIFY))"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0099",
  "title": "vhost_disable_notify check",
  "concept": "Disabling notify.",
  "attacker_model": "container_guest",
  "preconditions": [],
  "description": "Checks `VRING_USED_F_NO_NOTIFY`. Updates flags. Safe.",
  "classification": "logic-bypass",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2330: if (vq->used_flags & VRING_USED_F_NO_NOTIFY)"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0100",
  "title": "vhost_set_backend_features lock",
  "concept": "Locking for backend features.",
  "attacker_model": "privileged",
  "preconditions": [],
  "description": "Takes `dev->mutex` and `vq->mutex`. Safe.",
  "classification": "race-condition",
  "impact": "none",
  "likelihood": "low",
  "verdict": "not_feasible",
  "context": "driver",
  "evidence": [
    "drivers/vhost/vhost.c:2425: mutex_lock(&dev->mutex);"
  ],
  "derived_from": [],
  "proposed_fix_summary": "None."
}
