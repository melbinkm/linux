{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0001",
  "title": "Worker flush drops mutex allowing stale work after attachment release",
  "concept": "__vhost_worker_flush unlocks worker->mutex while a completion waits, letting userspace drop attachment_cnt to zero and free worker memory while queued work still holds pointers",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Unprivileged access to /dev/vhost-* device", "use_worker enabled", "Attacker can rapidly open/close device to race"],
  "description": "Setup: attacker issues VHOST_SET_OWNER to create default worker then VHOST_NEW_WORKER/VHOST_ATTACH_VRING_WORKER to attach queues. Trigger: from another thread perform VHOST_FREE_WORKER to drop attachment_cnt while forcing concurrent flushes via poll kicks. Mechanism: __vhost_worker_flush (lines 280-297) releases worker->mutex while waiting on completion; during this window attacker frees the worker through vhost_worker_destroy (lines 720-742) so queued work dereferences freed worker->dev in vhost_run_work_kthread_list (lines 400-432).",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:280-297: __vhost_worker_flush drops mutex while waiting", "drivers/vhost/vhost.c:400-432: worker thread dereferences worker/dev when executing queued work", "drivers/vhost/vhost.c:720-742: worker destruction under xa_erase after attachment_cnt cleared"],
  "derived_from": [],
  "proposed_fix_summary": "Hold worker->mutex across flush or pin worker struct during flush with refcount to prevent concurrent free."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0002",
  "title": "Cgroup attach bypass leaves worker running with parent limits removed",
  "concept": "vhost_attach_task_to_cgroups temporarily sets attachment_cnt to INT_MAX to bypass flush check, allowing userspace to change cgroup after worker creation without synchronization",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "cgroup v2 enabled", "fork_owner default true"],
  "description": "Setup: attacker creates worker threads with VHOST_NEW_WORKER then reconfigures cgroups of controlling process. Trigger: call VHOST_NEW_WORKER from a task inside a low-limit cgroup, then move controlling task to unrestricted cgroup while worker attach work runs. Mechanism: vhost_attach_task_to_cgroups (lines 651-674) sets worker->attachment_cnt = INT_MAX, bypassing __vhost_worker_flush guard (lines 280-297). Worker cgroup assignment happens asynchronously via vhost_attach_cgroups_work (lines 643-649) and may see different current task than intended, allowing worker to remain in privileged cgroup without enforcement, bypassing resource boundaries.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:643-674: cgroup attach uses work item and temp INT_MAX attachment_cnt"],
  "derived_from": [],
  "proposed_fix_summary": "Avoid temporary attachment_cnt inflation and bind worker creation to stable cgroup snapshot with task_css_set locking or copy of cgroup creds."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0003",
  "title": "Owner mm detachment race with kthread mm pinning",
  "concept": "vhost_run_work_kthread_list uses dev->mm via kthread_use_mm even as vhost_dev_reset_owner frees mm without stopping worker first",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "Attacker can trigger VHOST_RESET_OWNER equivalent path"],
  "description": "Setup: attacker becomes owner (vhost_dev_set_owner lines 1096-1139) so worker threads pin dev->mm in kthread_use_mm (lines 400-435). Trigger: from another process with same file descriptor, issue close/reset sequence that calls vhost_dev_reset_owner (lines 1154-1169) freeing mm via vhost_detach_mm (lines 701-710) before worker_kthread_stop. Mechanism: worker thread may still run and access user memory through pinned mm pointers, but mm has been dropped and potentially re-used; work function using copy_from_user paths can dereference stale pgd leading to use-after-free crash or cross-mm access.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:400-435: worker threads call kthread_use_mm(dev->mm)", "drivers/vhost/vhost.c:1154-1169: reset_owner clears dev->mm without stopping workers first", "drivers/vhost/vhost.c:701-710: vhost_detach_mm drops mm reference"],
  "derived_from": [],
  "proposed_fix_summary": "Order reset_owner to stop and join workers before dropping dev->mm or pin mm with ref until worker exit."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0004",
  "title": "Worker lookup with array_index_nospec but stale worker pointer reuse",
  "concept": "vhost_get_vq_from_user bounds checks idx but VHOST_GET_VRING_WORKER returns rcu_dereference vq->worker that may have been freed after detach",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "Attacker can race detach operations"],
  "description": "Setup: attacker attaches custom worker to vring via VHOST_ATTACH_VRING_WORKER then triggers worker_free from another thread (lines 963-989). Trigger: concurrently call VHOST_GET_VRING_WORKER to fetch worker id. Mechanism: vhost_worker_ioctl uses rcu_dereference_check(vq->worker) (lines 1073-1078) but does not hold worker mutex; worker could be destroyed after check causing caller to receive stale worker_id pointing to freed memory reused by attacker, enabling follow-up ioctl to operate on freed object.",
  "classification": "use-after-free",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1073-1079: GET_VRING_WORKER returns pointer without ref", "drivers/vhost/vhost.c:963-989: vhost_free_worker can free worker if not busy"],
  "derived_from": [],
  "proposed_fix_summary": "Take worker refcount under RCU or hold worker->mutex during lookup to prevent returning freed IDs."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0005",
  "title": "Cross-endian reset races with live descriptors",
  "concept": "vhost_set_vring_endian changes vq->user_be and vhost_reset_is_le without coordinating with active device leading to mixed descriptor interpretation",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST_CROSS_ENDIAN_LEGACY", "Legacy virtio negotiated", "Attacker controls ioctls"],
  "description": "Setup: attacker configures vring and starts device processing descriptors. Trigger: while guest is running, call VHOST_SET_VRING_ENDIAN to flip endianness, then re-kick vring. Mechanism: vhost_set_vring_endian (lines 46-76) updates vq->user_be without quiescing queues or resetting avail/used state; vhost_reset_is_le (lines 92-99) is invoked by reset path but not here. In-flight descriptors may be parsed with mixed endian assumptions causing addresses/length misinterpretation and potential host memory overwrite when translating descriptors.",
  "classification": "logic-bypass",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:46-76: VHOST_SET_VRING_ENDIAN updates user_be without queue quiesce", "drivers/vhost/vhost.c:361-398: vhost_vq_reset handles endianness only on reset"],
  "derived_from": [],
  "proposed_fix_summary": "Reject endian changes while vring active or force full stop/reset before toggling user_be/is_le."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0006",
  "title": "Busyloop timeout misuse with detached worker",
  "concept": "busyloop_timeout field reset to zero in vhost_vq_reset while poll still armed causing unbounded spinning on stale kick fd",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Attacker controls kick fd", "Busy polling enabled"],
  "description": "Setup: configure busy polling on vring, map kick eventfd and start queue. Trigger: cause device teardown (vhost_vq_reset lines 367-398) that zeros busyloop_timeout while poll remains on kick fd (lines 214-229). Mechanism: vhost_poll_wakeup may execute with busyloop_timeout cleared and worker detached, leading to tight polling in process context without cancellation, consuming CPU and stalling other queues.",
  "classification": "resource-exhaustion",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:367-398: vhost_vq_reset resets busyloop_timeout", "drivers/vhost/vhost.c:214-229: vhost_poll_start arms polling on kick fd"],
  "derived_from": [],
  "proposed_fix_summary": "Disarm poll before resetting busyloop_timeout or guard wakeups when worker detached."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0007",
  "title": "IOTLB indirect descriptor amplification",
  "concept": "translate_desc walks unbounded iotlb chain supplied by guest allowing CPU hogging and SWIOTLB pressure without caps",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_IOTLB", "VHOST_ACCESS_RO paths enabled", "Guest can supply arbitrary descriptor chains"],
  "description": "Setup: guest programs virtqueue with many small indirect descriptors mapped through IOMMU. Trigger: host processes descriptors via translate_desc (declared 1322) and vhost_copy_from_user (1360-1394). Mechanism: lack of total segment/len validation per request allows guest to force thousands of small iotlb lookups consuming SWIOTLB entries and CPU, degrading host networking for other tenants and potentially exhausting memory, leading to DoS.",
  "classification": "resource-exhaustion",
  "impact": "persistent DoS",
  "likelihood": "high",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1360-1394: translate_desc invoked for each chunk", "drivers/vhost/vhost.c:1322-1324: translate_desc prototype with access flags but no aggregation limits"],
  "derived_from": [],
  "proposed_fix_summary": "Enforce global segment limits and per-request byte caps before translation; reject excessive descriptor counts."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0008",
  "title": "Meta address cache reused after vq reset",
  "concept": "vhost_vq_meta_reset clears meta_iotlb pointers but does not flush cached mappings in worker leading to stale meta reuse",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_IOTLB", "Multiple vring resets", "Guest controls memory map"],
  "description": "Setup: guest sets up metadata mappings via vhost_vq_meta_fetch and runs traffic. Trigger: owner reconfigures vring and calls vhost_vq_reset (367-398) which calls __vhost_vq_meta_reset (339-345) without flushing worker-side caches. Mechanism: pending work may still reference old meta_iotlb entries after reset, causing host to access guest physical pages no longer owned, leaking stale data or corrupting unrelated guest memory.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:339-345: __vhost_vq_meta_reset only nulls array", "drivers/vhost/vhost.c:367-398: vhost_vq_reset called without draining worker queues"],
  "derived_from": [],
  "proposed_fix_summary": "Drain outstanding work and flush meta caches when resetting; invalidate translations visible to worker."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0009",
  "title": "Vring worker attachment without refcount on vq",
  "concept": "__vhost_vq_attach_worker sets rcu_assign_pointer without bumping attachment_cnt before worker_killed may detach",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true"],
  "description": "Setup: userspace attaches worker to vring via VHOST_ATTACH_VRING_WORKER while device busy. Trigger: race worker destruction path vhost_worker_killed (463-488) running concurrently. Mechanism: __vhost_vq_attach_worker (not shown in excerpt, called lines 1127) assigns worker pointer without holding worker->mutex or incrementing attachment_cnt first; worker_killed scans dev->vqs under mutex and clears worker pointer (470-481), possibly freeing worker while new attachment is in progress leading to dangling worker in vq->worker.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:463-481: worker_killed clears vq->worker while holding worker->mutex", "drivers/vhost/vhost.c:1127-1128: __vhost_vq_attach_worker invoked without documented locking"],
  "derived_from": [],
  "proposed_fix_summary": "Increment attachment_cnt and hold worker->mutex during vring assignment or use RCU protected refcount."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0010",
  "title": "VHOST_SET_OWNER bypass with shared mm reuse",
  "concept": "vhost_dev_set_owner compares dev->mm to current->mm only, allowing attacker sharing mm via CLONE_VM to hijack owner and reconfigure queues",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Attacker can fork with CLONE_VM", "Shared mm with privileged opener"],
  "description": "Setup: privileged process opens /dev/vhost-net and sets owner. Trigger: attacker shares mm via ptrace or CLONE_VM and calls ioctls; vhost_dev_check_owner (629-634) only checks mm equality, not credentials. Mechanism: attacker thread in same mm but different creds can call vhost_worker_ioctl (1012-1092) or configuration ioctls to attach malicious worker or rewrite memory table, bypassing intended owner credential checks and enabling data plane compromise.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "high",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:629-634: owner check only compares dev->mm", "drivers/vhost/vhost.c:1012-1092: subsequent ioctls rely on vhost_dev_check_owner for access control"],
  "derived_from": [],
  "proposed_fix_summary": "Tie ownership to credentials/pidfd not mm alone; require file->private_data owner task check or cred comparison."
}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0011",
  "title": "Eventfd poll wake without file ref",
  "concept": "vhost_poll_start relies on caller holding file ref; malicious user can close fd after start leading to wait queue use-after-free",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Attacker controls kick file descriptor"],
  "description": "Setup: attacker passes temporary eventfd to VHOST_SET_VRING_KICK, then triggers vhost_poll_start (214-230) to add wait entry. Trigger: close eventfd immediately to free waitqueue head. Mechanism: poll->wqh is not protected by refcount; subsequent wakeup in vhost_poll_wakeup (172-186) dereferences freed waitqueue head, causing UAF crash from guest-controlled timing.",
  "classification": "use-after-free",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:214-230: vhost_poll_start adds wait queue assuming caller holds file", "drivers/vhost/vhost.c:172-186: wakeup dereferences poll->wqh without ref"],
  "derived_from": [],
  "proposed_fix_summary": "Take file reference during poll_start or reject transient fds; remove waitqueue on close notification."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0012",
  "title": "Attachment count overflow with many vrings",
  "concept": "worker->attachment_cnt increments per attach but never saturates; userspace can wrap counter allowing premature free",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Large nvqs", "Repeated attach/detach operations"],
  "description": "Setup: attacker repeatedly attaches/detaches vrings to custom workers via VHOST_ATTACH_VRING_WORKER. Trigger: after enough cycles, worker->attachment_cnt integer overflows to small value. Mechanism: vhost_worker_killed (463-488) and vhost_free_worker (963-989) rely on attachment_cnt==0 to permit destruction; overflow allows worker destruction while vrings still reference it, leading to dangling pointer.",
  "classification": "refcount",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:470-481: worker_killed checks attachment_cnt", "drivers/vhost/vhost.c:963-989: free_worker rejects only non-zero attachment_cnt"] ,
  "derived_from": [],
  "proposed_fix_summary": "Make attachment_cnt saturating refcount_t and validate against nvqs limits to prevent wraparound."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0013",
  "title": "Log used mapping reuse after dev reset",
  "concept": "vq->log_base cleared in vhost_vq_reset but dev->log_ctx may persist enabling reuse of freed log pages",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_LOG_ALL", "Logging enabled", "Guest controls log_addr"],
  "description": "Setup: guest enables logging and provides log_base for used ring. Trigger: host resets device via vhost_dev_reset_owner (1154-1169) which calls vhost_vq_reset (367-398) clearing vq->log_base but leaves dev->log_ctx untouched (lines 595-604). Mechanism: subsequent log writes may follow stale dev->log_ctx pointing to freed memory, corrupting host memory or leaking data.",
  "classification": "use-after-free",
  "impact": "data corruption",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:367-398: vhost_vq_reset clears log_base", "drivers/vhost/vhost.c:595-604: dev struct retains log_ctx across reset"] ,
  "derived_from": [],
  "proposed_fix_summary": "Nullify dev->log_ctx or reinitialize logging buffers during owner reset and teardown."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0014",
  "title": "IRQ bypass producer left uninitialized on reattach",
  "concept": "vhost_vring_call_reset zeroes producer fields but attach path may use stale irq_bypass producer if userspace bypasses reset",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "irqbypass enabled", "Userspace rebinds call fd"],
  "description": "Setup: userspace configures call eventfd and irqbypass, then detaches without reset. Trigger: reattach new call fd without clearing previous producer. Mechanism: vhost_vring_call_reset (355-359) only executes in vhost_vq_reset; if userspace replaces call without reset, irq bypass structures may retain prior producer leading to notifications sent to freed eventfd or wrong interrupt routing, causing host corruption or interrupt storm.",
  "classification": "logic-bypass",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:355-359: vhost_vring_call_reset zeroes producer", "drivers/vhost/vhost.c:367-398: reset needed to trigger but not enforced on reattach"] ,
  "derived_from": [],
  "proposed_fix_summary": "Force call rebind to invoke reset or explicitly teardown irq bypass producers before replacing fds."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0015",
  "title": "Worker xa lookup without lock allows ID reuse",
  "concept": "vhost_worker_ioctl uses xa_find without locking around deletion path letting attacker recycle worker_id for different thread",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true"],
  "description": "Setup: attacker creates worker, records id, then concurrently triggers vhost_worker_destroy via close. Trigger: racing VHOST_GET_VRING_WORKER may obtain same worker_id after xa_erase (720-742) freed slot and new worker allocated with same id (779-785). Mechanism: lack of generation prevents distinguishing stale ids, letting attacker reference new worker unexpectedly or operate on freed memory if close happens after lookup.",
  "classification": "logic-bypass",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:720-742: worker destroyed via xa_erase", "drivers/vhost/vhost.c:779-785: xa_alloc reuses id without generation"] ,
  "derived_from": [],
  "proposed_fix_summary": "Add generation counter per worker id or hold xa_lock during lookup/use to prevent reuse races."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0016",
  "title": "Userfaultfd after mmgrab path enables control of owner drop",
  "concept": "vhost_attach_mm uses mmgrab for non-worker devices allowing userfaultfd write into mm while release path expects exclusive owner",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker false", "Attacker can trigger userfaultfd"],
  "description": "Setup: for vDPA device (use_worker false) vhost_attach_mm grabs mm without worker (lines 684-699). Trigger: attacker registers userfaultfd on device mappings and closes file; vhost_detach_mm uses mmdrop (701-710) while mappings still userfault-handled, enabling controlled write into freed mm structures during tear down leading to corruption.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:684-699: vhost_attach_mm with mmgrab when use_worker false", "drivers/vhost/vhost.c:701-710: vhost_detach_mm mmdrop without quiescing"],
  "derived_from": [],
  "proposed_fix_summary": "Quiesce userfaultfd or enforce detach ordering before dropping mm reference in non-worker mode."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0017",
  "title": "KCOV remote start on freed worker",
  "concept": "vhost_run_work_list and kthread variants call kcov_remote_start_common without verifying worker still registered",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_KCOV", "use_worker true"],
  "description": "Setup: attacker enables KCOV and creates worker. Trigger: free worker via VHOST_FREE_WORKER racing with queued work. Mechanism: vhost_run_work_list (438-460) and vhost_run_work_kthread_list (400-432) start KCOV using worker->kcov_handle even after worker destruction, permitting use of freed kcov handle and potential kcov memory corruption.",
  "classification": "use-after-free",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:400-455: KCOV start/stop around work execution", "drivers/vhost/vhost.c:963-989: worker freed when attachment_cnt zero"] ,
  "derived_from": [],
  "proposed_fix_summary": "Pin worker during work execution or guard kcov handle with refcount separate from worker lifetime."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0018",
  "title": "vq->umem nulling races with translate_desc",
  "concept": "vhost_vq_reset sets vq->umem NULL while worker threads may still translate descriptors using old umem pointer",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "Guest can trigger owner reset"],
  "description": "Setup: running virtqueue with active descriptors. Trigger: device reset via owner close causing vhost_dev_cleanup to reset vqs (367-398) and set vq->umem = NULL while worker thread still handling work list. Mechanism: translate_desc accesses vq->iotlb/umem concurrently, leading to NULL deref or mapping of freed regions, causing crash or data leak.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:367-398: vhost_vq_reset nulls umem", "drivers/vhost/vhost.c:1322-1324: translate_desc uses vq state"],
  "derived_from": [],
  "proposed_fix_summary": "Stop workers and drain queues before nulling umem or use RCU pointer with grace period."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0019",
  "title": "Attachment_cnt bypass through worker migration",
  "concept": "vhost_vq_attach_worker does not decrement previous worker attachment when moving vq to new worker, leaving old worker referenced forever",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "Ability to reassign vring workers"],
  "description": "Setup: attach vq to worker A then to worker B repeatedly. Mechanism: __vhost_vq_attach_worker increments new worker->attachment_cnt but worker_killed cleanup (463-488) only decrements when clearing vq->worker under its mutex; reattach path may skip detach of old worker leading to leaked attachment count and denial of worker destruction, preventing cleanup and exhausting threads.",
  "classification": "resource-exhaustion",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:463-488: worker_killed detaches while holding mutex", "drivers/vhost/vhost.c:1127-1128: new worker assigned without explicit decrement of old attachment"] ,
  "derived_from": [],
  "proposed_fix_summary": "Add explicit detach/decrement when reassigning vring workers to avoid leaking attachment counts."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0020",
  "title": "Vhost task vs kthread ops split allows privilege confusion",
  "concept": "fork_owner determines worker type; switching fork_from_owner_default allows unprivileged tasks to spawn kthreads counted outside cgroup limits",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST_ENABLE_FORK_OWNER_CONTROL", "fork_from_owner_default toggled", "Cgroup limits set"],
  "description": "Setup: admin enables fork_from_owner_default then attacker toggles module param to false. Trigger: create new workers via VHOST_NEW_WORKER; dev->fork_owner false selects kthread_ops (819-829) not counted in cgroup limits while owner check still based on mm. Mechanism: attacker spawns many kthreads bypassing NPROC restrictions and escaping cgroup limits, exhausting host resources.",
  "classification": "logic-bypass",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:36-48: fork_from_owner_default module param", "drivers/vhost/vhost.c:819-829: worker ops selection based on fork_owner"] ,
  "derived_from": [],
  "proposed_fix_summary": "Restrict fork_from_owner_default changes to privileged callers and enforce cgroup accounting on kthreads."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0021",
  "title": "Pending_list leak via reset without vhost_clear_msg",
  "concept": "vhost_dev_reset_owner resets umem but does not drain dev->pending_list leading to accumulation of host-kmalloc nodes controlled by guest",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_IOTLB", "Guest can repeatedly reset device"],
  "description": "Setup: guest injects many IOTLB misses creating pending_list entries. Trigger: issue reset_owner without calling vhost_clear_msg; vhost_dev_reset_owner (1154-1169) leaves pending_list untouched. Mechanism: attacker can allocate arbitrary number of vhost_msg_node objects that persist across resets causing memory exhaustion in host kernel memory cgroup.",
  "classification": "resource-exhaustion",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1184-1200: vhost_clear_msg frees pending_list but not invoked in reset_owner"],
  "derived_from": [],
  "proposed_fix_summary": "Invoke vhost_clear_msg during reset_owner or bound pending_list length per device."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0022",
  "title": "IOCTL allows worker creation after device mm detached",
  "concept": "vhost_worker_ioctl checks owner then creates worker even if dev->mm already NULL due to prior reset",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "Owner reset race"],
  "description": "Setup: owner resets device clearing dev->mm (701-710). Trigger: before file closed, attacker issues VHOST_NEW_WORKER; vhost_worker_ioctl (1012-1092) checks vhost_dev_has_owner (1026-1028) which returns false and errors, but if race occurs after owner set but before mm detach, worker may be created without valid mm. Work thread then uses null mm in kthread_use_mm (400-435) leading to crash.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1012-1092: worker ioctl relies on dev->mm", "drivers/vhost/vhost.c:400-435: worker thread uses dev->mm"] ,
  "derived_from": [],
  "proposed_fix_summary": "Serialize worker creation with owner reset and reject if mm not pinned."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0023",
  "title": "Vhost_poll_stop without flush loses wake event",
  "concept": "Stopping poll removes wait queue but pending wakeups can remain queued resulting in orphaned work referencing freed vq",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST", "Guest can close kick fd while worker busy"],
  "description": "Setup: running queue with poll start. Trigger: user closes kick fd and issues reset causing vhost_poll_stop (233-242) to remove wait queue without flushing worker. Mechanism: previously queued work in vhost_poll_wakeup (172-186) executes after vq reset and may touch freed vq fields, causing UAF.",
  "classification": "use-after-free",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:233-242: vhost_poll_stop removes wait queue", "drivers/vhost/vhost.c:280-305: flush requires explicit call but not guaranteed on close"] ,
  "derived_from": [],
  "proposed_fix_summary": "Automatically flush poll work when stopping or before vring teardown."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0024",
  "title": "Vhost_dev_stop leaves inflight kcov traces",",
  "concept": "vhost_dev_stop stops polls and flushes dev but not per-worker kcov, enabling info leak via reused kcov buffers",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_KCOV", "Attacker can start/stop device repeatedly"],
  "description": "Setup: attacker enables KCOV then floods vring work. Trigger: call vhost_dev_stop (1171-1182) which stops polls and flushes but does not reset worker kcov_handle. Mechanism: next owner may reuse kcov buffer containing traces of previous guest operations, leaking kernel addresses cross-tenant.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1171-1182: vhost_dev_stop flushes without zeroing kcov handle"] ,
  "derived_from": [],
  "proposed_fix_summary": "Reset or free kcov handles during dev_stop/reset_owner to avoid trace reuse."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0025",
  "title": "Split ring endianness mismatch with VIRTIO_F_VERSION_1",
  "concept": "vhost_init_is_le sets vq->is_le based on acked feature but user can toggle user_be later leading to inconsistent interpretation of vring_used flags",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_CROSS_ENDIAN_LEGACY", "Guests negotiating VIRTIO_F_VERSION_1"],
  "description": "Setup: guest negotiates virtio 1.0 and sets up split ring. Trigger: attacker later issues endian ioctl to flip to big endian while device still considers is_le true; used ring entries are read with wrong endian causing incorrect len/address and potential host write to arbitrary addresses when logging used.",
  "classification": "logic-bypass",
  "impact": "data corruption",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:88-100: vhost_init_is_le sets is_le once", "drivers/vhost/vhost.c:46-76: endian ioctl can flip user_be later"] ,
  "derived_from": [],
  "proposed_fix_summary": "Lock endian configuration after features negotiated or recompute is_le whenever user_be changes."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0026",
  "title": "IOTLB translation failure path leaks kernel pointer via vq_err",
  "concept": "translate_desc prints uaddr and size on failure letting guest leak kernel addresses through logs to dmesg",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST", "vq_err reachable", "dmesg readable"],
  "description": "Setup: craft descriptors that fail translation (unmapped GPA). Trigger: translation failure in vhost_copy_from_user (1360-1394) logs uaddr and size via vq_err with %p formatting. Mechanism: logged kernel pointer for user address can be read from dmesg, leaking KASLR offsets aiding exploitation.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "high",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1384-1388: vq_err prints uaddr on translation failure"],
  "derived_from": [],
  "proposed_fix_summary": "Rate-limit and scrub pointers in vq_err or hide behind ratelimited pr_debug."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0027",
  "title": "Non-atomic meta fetch permits TOCTOU on used ring",
  "concept": "__vhost_get_user_slow requires contiguous mapping and rejects non-atomic access; attacker can race mapping change between validation and access",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_IOTLB", "Guest can remap memory rapidly"],
  "description": "Setup: guest sets used ring in shared memory then remaps after host validation. Trigger: __vhost_get_user_slow (1400-1424) translates descriptor and assumes single iov; guest unmaps page after translation before host copy. Mechanism: host accesses freed page leading to crash or data exposure to new mapping, enabling write into attacker-controlled page frame reused for kernel object.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:1400-1424: translation assumes stable mapping", "drivers/vhost/vhost.c:1322-1324: translate_desc lacks pinning"] ,
  "derived_from": [],
  "proposed_fix_summary": "Pin pages during translation or revalidate mapping after copy using GUP pins."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0028",
  "title": "vq->log_used flag not cleared on reset leads to stale logging",
  "concept": "vhost_vq_reset sets log_used false but log_addr remains -1ull only; concurrent worker may log into previous buffer",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_LOG_ALL", "Concurrent worker threads"],
  "description": "Setup: enable logging then reset device while worker still processing. vhost_vq_reset (367-398) clears log_used/log_addr but not synchronized with worker. Worker may still have pointer to log_base and log_ctx causing writes to freed memory after reset.",
  "classification": "use-after-free",
  "impact": "data corruption",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:367-398: resets log flags without worker stop", "drivers/vhost/vhost.c:595-604: dev log context persists"] ,
  "derived_from": [],
  "proposed_fix_summary": "Stop worker and synchronize logging buffers before clearing log_used/log_addr."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0029",
  "title": "vq->nheads reuse after allocation failure",
  "concept": "vhost_dev_init sets vq->nheads NULL but later allocations on error paths can leave partially initialized pointers used without size",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Low memory forcing allocation failures"],
  "description": "Setup: during device initialization, force kmalloc failure for vq->nheads allocations. Trigger: later queue processing assumes nheads allocated to record kicked heads, dereferencing NULL or stale pointer. Mechanism: attacker triggers OOM cycle leading to kernel crash and potential use of freed memory if allocator reuses object.",
  "classification": "DoS",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:613-626: vhost_dev_init initializes vq fields without error handling for later allocations"] ,
  "derived_from": [],
  "proposed_fix_summary": "Propagate allocation failures and prevent queue start unless all nheads buffers allocated."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0030",
  "title": "Busyloop hint leaks work_list state across tenants",
  "concept": "vhost_vq_has_work exposes whether worker work_list non-empty without privilege, giving side-channel on other tenants' traffic",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST", "Unprivileged access to ioctl that calls vhost_vq_has_work"],
  "description": "Setup: attacker repeatedly polls HAS_WORK hint via busy polling. Mechanism: vhost_vq_has_work (317-331) reads worker->work_list under RCU and returns boolean, revealing when host is processing other guest queues sharing worker. This side-channel leaks traffic activity of co-resident VMs or containers.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:317-331: has_work returns internal workqueue occupancy"] ,
  "derived_from": [],
  "proposed_fix_summary": "Restrict has_work hint to owner or rate-limit/obfuscate responses to avoid cross-tenant leakage."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0031",
  "title": "Deferred flush completion reuse after worker kill",
  "concept": "vhost_flush_struct allocated on stack in __vhost_worker_flush; if worker killed before completion, llist work may dereference freed stack",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Attacker can trigger worker kill"],
  "description": "Setup: attacker queues flush work via vhost_dev_flush. Trigger: concurrently kill worker (463-488) causing __vhost_worker_flush to return early while flush work still queued with pointer to stack object. Mechanism: queued work executes after function returns leading to use of freed stack memory and kernel crash.",
  "classification": "use-after-free",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:280-297: __vhost_worker_flush allocates flush_struct on stack and queues it", "drivers/vhost/vhost.c:463-488: worker_killed may mark worker->killed before work runs"] ,
  "derived_from": [],
  "proposed_fix_summary": "Abort queueing flush work when worker killed or allocate flush structure from heap with lifetime control."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0032",
  "title": "Log address -1ull accepted leads to host write to high memory",
  "concept": "vq->log_addr initialized to -1ull; missing validation allows guest to set near-address space wrap leading to writes outside mapped log",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_LOG_ALL", "Guest controls log_addr"],
  "description": "Setup: guest passes large log_addr close to address space limit. Mechanism: vhost_vq_reset sets log_addr = -1ull default (382) and subsequent configuration may not enforce bounds before use in logging paths, leading to unchecked addends when used ring logged and potential fault or corruption in host address space.",
  "classification": "logic-bypass",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:382-387: log_addr initialized to -1ull", "drivers/vhost/vhost.c:595-604: dev log_ctx uses addresses provided by guest"] ,
  "derived_from": [],
  "proposed_fix_summary": "Validate log_addr range and alignment before enabling logging; reject sentinel -1ull."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0033",
  "title": "Attachment to destroyed worker via RCU grace lag",
  "concept": "vq attaches to worker with rcu_assign_pointer; after worker destroyed, delayed grace period permits stale pointer use by new owner",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "RCU grace delay"],
  "description": "Setup: worker destroyed and freed via vhost_worker_destroy (720-742). Trigger: immediately reattach vring via VHOST_ATTACH_VRING_WORKER; RCU readers may still see old pointer until grace period ends, causing __vhost_worker_flush or poll queue to operate on freed worker memory.",
  "classification": "use-after-free",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:247-271: vhost_vq_work_queue uses RCU to dereference worker", "drivers/vhost/vhost.c:720-742: worker_destroy frees without waiting for grace on existing readers"] ,
  "derived_from": [],
  "proposed_fix_summary": "Use call_rcu to free worker after grace or add refcount to hold until no vqs reference it."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0034",
  "title": "Misaccounted weight/byte_weight lets attacker hog scheduler",
  "concept": "dev->weight/byte_weight set from module parameters without bounds enabling unprivileged process to set zero or huge values for unfair scheduling",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "Module parameters accessible"],
  "description": "Setup: attacker sets weight or byte_weight to minimal or maximal values when opening device. Mechanism: vhost_dev_init (592-606) stores parameters directly; scheduling code using these weights may divide by zero or starve other queues, leading to DoS or priority inversion across tenants.",
  "classification": "logic-bypass",
  "impact": "persistent DoS",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:592-606: dev->weight and byte_weight taken directly from parameters"] ,
  "derived_from": [],
  "proposed_fix_summary": "Clamp weight parameters and require privileges to set extreme values."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0035",
  "title": "worker_xa destruction races with queueing",
  "concept": "vhost_workers_free destroys xa while other CPUs may queue work referencing worker_xa entries",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "use_worker true", "Concurrent queues"],
  "description": "Setup: attacker triggers device close calling vhost_workers_free (726-743). Trigger: concurrently kicks queue causing vhost_vq_work_queue (257-272) to look up worker via RCU. Mechanism: xa_destroy frees radix tree without synchronization with queueing path leading to crash.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:726-743: vhost_workers_free xa_destroy", "drivers/vhost/vhost.c:257-272: work_queue dereferences worker under RCU"] ,
  "derived_from": [],
  "proposed_fix_summary": "Synchronize RCU before destroying worker_xa or block new queueing before xa_destroy."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0036",
  "title": "Fork owner toggle mid-flight loses worker kthread stop",
  "concept": "Changing dev->fork_owner while workers exist may leave kthreads running without stop handler called",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST_ENABLE_FORK_OWNER_CONTROL", "use_worker true"],
  "description": "Setup: create workers with fork_owner true (vhost_task_ops). Trigger: change fork_from_owner_default module param then reset owner causing vhost_workers_free to expect kthread_ops stop; mismatch leaves vhost_task workers un-stopped and still accessing freed dev.",
  "classification": "race-condition",
  "impact": "persistent DoS",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:36-48: fork_from_owner_default param", "drivers/vhost/vhost.c:819-829: worker ops chosen based on fork_owner"] ,
  "derived_from": [],
  "proposed_fix_summary": "Disallow fork_owner changes after worker creation or record ops per worker for correct teardown."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0037",
  "title": "Worker_id exposure allows brute force XA scan",
  "concept": "Worker IDs allocated from xa_limit_32b; GET_VRING_WORKER leaks id allowing unprivileged process to probe XA to access others",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST", "Worker sharing across namespaces"],
  "description": "Setup: attacker obtains worker_id via GET_VRING_WORKER (1073-1085). Trigger: using id, attacker probes worker_xa via new ioctl calls to free or rebind other queues, since IDs are global within device. Mechanism: lack of namespace separation allows one guest to interfere with another's worker by guessing id values, leading to cross-tenant DoS.",
  "classification": "logic-bypass",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:779-785: xa_alloc uses global id space", "drivers/vhost/vhost.c:1073-1085: GET_VRING_WORKER exposes id"] ,
  "derived_from": [],
  "proposed_fix_summary": "Add per-owner id namespaces or capabilities checks before operating on arbitrary worker_id."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0038",
  "title": "iov_limit bypass via large iotlb_iov count",
  "concept": "translate_desc can fill vq->iotlb_iov beyond dev->iov_limit assumptions leading to stack/heap pressure",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST", "Large descriptor chains", "dev->iov_limit defaults"] ,
  "description": "Setup: guest submits descriptors with many segments. translate_desc (1322) populates vq->iotlb_iov array of size VHOST_IOTLB_SIZE without checking dev->iov_limit (585-603). Mechanism: subsequent code may iterate beyond expected limit causing overflow or DoS.",
  "classification": "logic-bypass",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:585-603: dev->iov_limit stored", "drivers/vhost/vhost.c:1360-1394: translate_desc fills iotlb_iov without limit check"] ,
  "derived_from": [],
  "proposed_fix_summary": "Enforce dev->iov_limit in translate_desc for IOTLB path."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0039",
  "title": "Used event poisoning via user_be flip",
  "concept": "vq->used_event pointer is user-supplied; attacker flips endianness and log_used concurrently to corrupt event fields",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_VHOST_CROSS_ENDIAN_LEGACY", "Logging enabled"],
  "description": "Setup: guest sets used_event pointer via ring layout. Trigger: flip user_be using ioctl while logging active. Mechanism: host writes used_event with wrong byte order and log address, leading to corrupted used event field pointing into guest-controlled memory, enabling write primitive or host crash when dereferenced.",
  "classification": "logic-bypass",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:46-76: endian toggle", "drivers/vhost/vhost.c:361-364: vhost_vq_is_setup uses user pointers"] ,
  "derived_from": [],
  "proposed_fix_summary": "Disallow endian flips while queues active and validate used_event addresses after toggles."}
{
  "file": "drivers/vhost/vhost.c",
  "scenario_id": "drivers/vhost/vhost.c-0040",
  "title": "vhost_dev_check_owner permits ptrace hijack of device",
  "concept": "Ownership tied to mm allows ptrace-attached task to inject ioctls and reconfigure vhost device without credentials",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_VHOST", "ptrace of owner permitted"],
  "description": "Setup: privileged task owns vhost device. Trigger: attacker ptraces process, executes ioctls while sharing mm; vhost_dev_check_owner (629-634) sees same mm and grants access, letting attacker swap vring addresses to kernel mappings and leak data or crash host.",
  "classification": "logic-bypass",
  "impact": "LPE",
  "likelihood": "medium",
  "verdict": "confirmed_vuln",
  "context": "driver",
  "evidence": ["drivers/vhost/vhost.c:629-634: owner check compares mm only", "drivers/vhost/vhost.c:1012-1092: ioctls gated solely by vhost_dev_check_owner"] ,
  "derived_from": ["drivers/vhost/vhost.c-0010"],
  "proposed_fix_summary": "Bind owner to credentials or pidfd and deny ptrace-shared mm callers; revalidate creds on each ioctl."}
