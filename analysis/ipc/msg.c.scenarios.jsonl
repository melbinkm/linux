{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0001","title":"Unprivileged queue spray exhausts msg_ctlmni","attacker_model":"local_unprivileged","preconditions":["IPC namespace with default msg_ctlmni","No RLIMIT_MSGQUEUE enforcement beyond defaults"],"description":"Attacker repeatedly calls msgget() with private keys to allocate queues until msg_ctlmni is reached. Each queue allocates a struct msg_queue and holds references in the idr, consuming kmalloc memory and percpu counters without rate limiting, potentially exhausting kernel memory or msg IDs for other users in the namespace.","classification":"DoS","impact":"Kernel memory exhaustion and denial of IPC resources","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:58-116","ipc/msg.c:298-313"],"derived_from":[],"proposed_fix_summary":"Add per-user or cgroup limits and charge creations to memcg/rlimits before installing the id."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0002","title":"Queue removal while senders sleep leaves msq pointer stale","attacker_model":"local_unprivileged","preconditions":["Attacker can call msgsnd/msgrcv on shared queue","Concurrent IPC_RMID by privileged actor"],"description":"A sender blocked in msgsnd() is queued on msq->q_senders. If another actor removes the queue via IPC_RMID while the sender sleeps, the task is woken with an ERR_PTR in r_msg but still relies on the original msq pointer. Misordered wakeups or missing barriers could dereference freed memory before ipc_valid_object() aborts, leading to rare UAF windows.","classification":"race-condition","impact":"Potential use-after-free or kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:212-247","ipc/msg.c:249-295","ipc/msg.c:911-958"],"derived_from":[],"proposed_fix_summary":"Ensure sender paths revalidate msq after wakeup under RCU and zero out list links before free to prevent reuse."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0003","title":"IPC_SET can shrink q_qbytes below current usage","attacker_model":"privileged","preconditions":["CAP_SYS_RESOURCE holder performing IPC_SET","Queue already holding more bytes than new limit"],"description":"msgctl IPC_SET allows reducing q_qbytes without verifying that q_cbytes <= new limit. If a privileged actor shrinks limits on a busy queue, later senders may sleep forever because msg_fits_inqueue() will never succeed until bytes drop below the new cap, but existing messages are not dropped. This can deadlock senders and receivers relying on forward progress.","classification":"logic-bypass","impact":"Persistent denial of service for queue users","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:424-458"],"derived_from":[],"proposed_fix_summary":"Reject IPC_SET that reduces q_qbytes below q_cbytes or force-drain messages with wakeups to avoid indefinite blockage."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0004","title":"MSG_COPY with limited bufsz leaks message truncation status","attacker_model":"local_unprivileged","preconditions":["CONFIG_CHECKPOINT_RESTORE enabled","Attacker has msgrcv with MSG_COPY"],"description":"When MSG_COPY is used, prepare_copy() allocates a dummy message of size bufsz and copy_msg() returns data even if the real message is larger. Applications may treat partial copies as authoritative, enabling an attacker to observe message lengths and metadata without consuming the message, leaking traffic patterns from other senders in the queue.","classification":"info-leak","impact":"Information disclosure of inter-process message sizes/types","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1040-1161"],"derived_from":[],"proposed_fix_summary":"Document MSG_COPY side effects or limit it to privileged callers; optionally zero unused portions to hide message size."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0005","title":"msgrcv MSG_EXCEPT with negative types underflow handling","attacker_model":"local_unprivileged","preconditions":["Attacker controls msgtyp and flags"],"description":"convert_mode() negates negative msgtyp unless it equals LONG_MIN, where it clamps to LONG_MAX. An attacker passing LONG_MIN with MSG_EXCEPT could bypass intended filtering and scan the queue unpredictably. Combined with MSG_COPY this can enumerate message types without consuming them.","classification":"logic-bypass","impact":"Information leak of message ordering and types","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1002-1023","ipc/msg.c:1074-1095"],"derived_from":[],"proposed_fix_summary":"Return -EINVAL for LONG_MIN or sanitize msgtyp before conversion, aligning behavior with userspace expectations."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0006","title":"Per-queue percpu counters not rolled back on partial copy_from_user faults","attacker_model":"local_unprivileged","preconditions":["Fault injection on msgsnd payload copy","Queue space available"],"description":"If copy_from_user into a newly allocated message fragment faults after partial progress, load_msg() may return an ERR_PTR but the message header was already accounted to percpu_msg_hdrs during allocation paths. Repeating faults can leak counter increments, causing msg_bytes/msg_hdrs accounting mismatch and eventual rejection of legitimate sends (DoS).","classification":"accounting","impact":"Denial of service via inflated quota counters","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:74-96","ipc/msg.c:934-946"],"derived_from":[],"proposed_fix_summary":"Defer percpu counter increments until after successful payload copy or roll back on fault paths."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0007","title":"SIGKILL during msgsnd leaves msq->q_lspid stale","attacker_model":"local_unprivileged","preconditions":["Sender killed mid-send","Queue survives"],"description":"During do_msgsnd(), q_lspid is updated after the message is enqueued. If the task receives fatal signals before the update, the queue retains an older lspid value, confusing audit trails and potentially allowing spoofing of sender identity for accounting or logging purposes in user space consuming /proc/sysvipc/msg.","classification":"audit-bypass","impact":"Misattribution of sender identity","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:934-947","ipc/msg.c:1350-1363"],"derived_from":[],"proposed_fix_summary":"Update lspid earlier under lock or store task pointer to attribute pending enqueued messages accurately."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0008","title":"msgrcv permission check bypass via MSG_STAT_ANY audit path","attacker_model":"local_unprivileged","preconditions":["Auditing disabled or misconfigured","Attacker passes MSG_STAT_ANY"],"description":"msgctl_stat() allows MSG_STAT_ANY to return queue metadata even if ipcperms would fail, only performing audit_ipc_obj(). In environments without auditing, an unprivileged process can enumerate all queue IDs, owners, and sizes across the namespace, learning activity of other users.","classification":"info-leak","impact":"Information disclosure across IPC users","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:526-590"],"derived_from":[],"proposed_fix_summary":"Require ipcperms for MSG_STAT_ANY or gate the call behind CAP_IPC_OWNER when auditing is disabled."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0009","title":"Userfaultfd on msgrcv buffers to stall queue drain","attacker_model":"local_unprivileged","preconditions":["Userfaultfd registered on receiver buffer","Shared queue with other users"],"description":"msgrcv copies data into user-provided buffers after unlinking the message. A malicious receiver can register userfaultfd on the destination buffer to stall the copy indefinitely after the message is removed, blocking senders because q_cbytes/q_qnum are decremented only after copy completes. This can freeze queue progress without holding locks.","classification":"race-condition","impact":"Denial of service for producers","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1118-1259"],"derived_from":[],"proposed_fix_summary":"Limit copy duration or re-enqueue message on long faults; consider pinning pages or imposing copy timeouts."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0010","title":"MSG_COPY path can overrun user buffer length assumptions","attacker_model":"local_unprivileged","preconditions":["Caller passes small bufsz with MSG_COPY","CONFIG_CHECKPOINT_RESTORE"],"description":"prepare_copy() sets copy->m_ts = bufsz, but copy_msg() copies the full original message into the dummy buffer if message is shorter than bufsz. Callers expecting exact truncation may place buffers next to sensitive mappings; a longer message than anticipated could overwrite adjacent userspace data and trigger local privilege escalation via corrupted metadata.","classification":"info-leak","impact":"Userland memory corruption leading to potential privilege escalation","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1040-1159"],"derived_from":[],"proposed_fix_summary":"Enforce strict length checks in copy_msg when MSG_COPY is used and return the real size before copying."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0011","title":"q_qbytes calculation allows q_qnum to exceed msg_qbytes cap","attacker_model":"local_unprivileged","preconditions":["msg_qbytes set to small value","Attacker queues many 1-byte messages"],"description":"msg_fits_inqueue() compares q_qnum against q_qbytes (bytes limit) rather than a separate message-count limit. An attacker can enqueue q_qbytes messages of size 1, keeping q_cbytes low while q_qnum grows arbitrarily, stressing list management and per-queue wakeup traversal with large lists.","classification":"resource-exhaustion","impact":"Kernel CPU/heap pressure and scheduler latency","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:120-137","ipc/msg.c:237-245","ipc/msg.c:940-946"],"derived_from":[],"proposed_fix_summary":"Introduce a distinct q_msgmax bound or enforce q_qnum limit derived from msg_ctlmnb independent of byte size."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0012","title":"RCU lookup of msq without permission check yields timing oracle","attacker_model":"local_unprivileged","preconditions":["Attacker can guess msqid values"],"description":"msq_obtain_object_check() is called under rcu_read_lock() and performs ipc_obtain_object_check before ipcperms. Attackers timing repeated msq_obtain_object() failures can infer allocation state (EIDRM vs EACCES) to enumerate live queues owned by others using side channels, even if permission check would fail later.","classification":"info-leak","impact":"IPC queue enumeration by unauthorized user","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:320-537","ipc/msg.c:1121-1135"],"derived_from":[],"proposed_fix_summary":"Perform permission check early or mask error codes to generic -EACCES regardless of existence."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0013","title":"Per-namespace msg_init defaults ignore user namespace limits","attacker_model":"container_guest","preconditions":["Unprivileged container with userns","Default MSGMNI/MSGMNB unchanged"],"description":"msg_init_ns() assigns MSGMAX/MSGMNB defaults irrespective of user namespace restrictions, allowing unprivileged containers to allocate many messages relative to their resource limits. Combined with kmalloc accounting outside memcg, this can pressure host memory from inside a container.","classification":"resource-exhaustion","impact":"Host memory pressure and IPC exhaustion","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1306-1337"],"derived_from":[],"proposed_fix_summary":"Scale msg_ctlmni/msg_ctlmnb based on user namespace and memcg constraints or require CAP_SYS_RESOURCE in init userns."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0014","title":"/proc/sysvipc/msg leaks freed queue metadata via rcu window","attacker_model":"local_unprivileged","preconditions":["CONFIG_PROC_FS enabled","Concurrent IPC_RMID during seq_file iteration"],"description":"sysvipc_msg_proc_show() walks msg queues under RCU while freeing can happen concurrently. A queue removed after iteration begins but before formatting may still be printed with stale msq fields, leaking freed memory contents or stale pids into /proc output.","classification":"info-leak","impact":"Disclosure of freed structure data","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:1340-1375","ipc/msg.c:249-295"],"derived_from":[],"proposed_fix_summary":"Hold ipc object lock or recheck ipc_valid_object() before printing fields, or copy data while object pinned."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0015","title":"DoS by forcing E2BIG through crafted msgtyp and small buffers","attacker_model":"local_unprivileged","preconditions":["Receiver uses small buffer with IPC_NOWAIT","Attacker controls message types"],"description":"find_msg() selects messages by type without considering receiver bufsz until after selection. An attacker can enqueue very large messages of carefully chosen types so receivers with small buffers repeatedly hit -E2BIG and spin or retry, preventing consumption of other messages and stalling the queue.","classification":"logic-bypass","impact":"Denial of service for receivers","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1074-1153"],"derived_from":[],"proposed_fix_summary":"Skip oversized messages when IPC_NOWAIT or allow receivers to specify maximum type match skipping over too-large entries."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0016","title":"msgsnd copies from user without accounting for fault latency","attacker_model":"local_unprivileged","preconditions":["User-supplied msgp in slow/faulting memory (e.g., FUSE)"],"description":"do_msgsnd() copies payload from user while holding the ipc object lock and RCU read lock. If msgp resides on faulting or slow memory, the sender holds the queue lock for a long duration, blocking other senders/receivers and enabling a local attacker to delay IPC operations for other processes.","classification":"DoS","impact":"Priority inversion and throughput collapse","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:918-958"],"derived_from":[],"proposed_fix_summary":"Copy data outside critical section or use fault-in helpers before acquiring locks."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0017","title":"IPC_INFO returns kernel constants without capability checks","attacker_model":"local_unprivileged","preconditions":["Attacker can call msgctl IPC_INFO"],"description":"ksys_msgctl() handles IPC_INFO and MSG_INFO without checking caller capabilities beyond basic argument validation. These commands reveal system-wide MSGPOOL and MSGMAP sizing, which may be restricted in hardened setups. An attacker can probe tuning parameters for side-channeling administrator policy.","classification":"info-leak","impact":"Information disclosure of IPC configuration","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:597-637","ipc/msg.c:477-515"],"derived_from":[],"proposed_fix_summary":"Require CAP_SYS_ADMIN or limit IPC_INFO/MSG_INFO to same user namespace; redact values when unprivileged."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0018","title":"msgsnd path frees message after wakeup without zeroing","attacker_model":"local_unprivileged","preconditions":["Sender aborted or queue removed","Attacker can mmap /dev/kmem equivalent gadgets"],"description":"When msgsnd fails after allocation, msg_rcu_free() eventually kfree()s the msg_queue without scrubbing message contents. Freed message buffers can leak prior payloads if reallocated to other kernel objects accessible through info-leak primitives.","classification":"info-leak","impact":"Potential disclosure of message payloads","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:77-96","ipc/msg.c:915-958","ipc/msg.c:289-295"],"derived_from":[],"proposed_fix_summary":"Explicitly zero message buffers before free when allocation failed or queue destroyed."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0019","title":"q_receivers list wakeups may reorder waiters breaking priority","attacker_model":"local_unprivileged","preconditions":["Multiple receivers blocked with MSG_EXCEPT/SEARCH modes","Attacker controls arrival order"],"description":"expunge_all() and find_msg() walk q_receivers and may wake tasks in list order unrelated to message priority. An attacker manipulating message arrival can cause higher-priority readers to starve, effectively implementing a priority-inversion DoS by repeatedly queueing and removing messages.","classification":"logic-bypass","impact":"Starvation of targeted receivers","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:249-263","ipc/msg.c:1074-1145"],"derived_from":[],"proposed_fix_summary":"Order receiver wakeups by message type/priority or enforce fairness via wake_q scheduling."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0020","title":"msgrcv with MSG_COPY bypasses security hooks on original message","attacker_model":"local_unprivileged","preconditions":["CONFIG_CHECKPOINT_RESTORE","Attacker lacks read permission but invokes MSG_COPY"],"description":"find_msg() calls security_msg_queue_msgrcv() before returning a pointer, but MSG_COPY path copies the message without unlinking or updating accounting. If LSM decisions depend on side effects (like audit triggers), repeated MSG_COPY requests could observe message contents even after a single allowed decision, abusing cache timing to infer data without consuming the message for legitimate receivers.","classification":"info-leak","impact":"Information disclosure without consuming queue entries","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:1074-1161"],"derived_from":[],"proposed_fix_summary":"Rate-limit or deny repeated MSG_COPY on the same message without additional LSM hooks or consume-on-copy semantics."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0021","title":"Abusive MSG_COPY on unlinked queue reuses freed msq pointer","attacker_model":"local_unprivileged","preconditions":["Attacker created queue then another thread removes it with IPC_RMID","CONFIG_CHECKPOINT_RESTORE enabled for MSG_COPY"],"description":"Thread A issues IPC_RMID on a queue while thread B races in msgrcv with MSG_COPY. msq_obtain_object_check returns a pointer validated before IPC_RMID removes it; MSG_COPY path keeps using msq fields after ipc_valid_object() failure because find_msg() returns NULL but rcu_read_lock() remains. The attacker repeatedly triggers MSG_COPY on stale msqid to leak or crash due to freed msq reuse in walk through q_messages.","classification":"race-condition","impact":"kernel crash or stale data disclosure from freed queue","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:871-929: msgsnd/msgrcv obtain msq under rcu and continue after RMID checks","ipc/msg.c:1130-1163: MSG_COPY path traverses q_messages under rcu"] ,"derived_from":[],"proposed_fix_summary":"Revalidate ipc_valid_object() after MSG_COPY lookup and abort if queue was removed; hold stronger refs for copy."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0022","title":"Dangling q_lspid/q_lrpid used after task exit","attacker_model":"local_unprivileged","preconditions":["Attacker sends/receives to update q_lspid/q_lrpid","Tasks exit without pid revalidation"],"description":"ipc_update_pid stores task_tgid(current) into q_lspid/q_lrpid without taking references. PIDs can be recycled immediately. An attacker can create a pid namespace churn where q_lspid references a freed pid pointer that is dereferenced in /proc/ipc or security hooks, leading to stale pidinfo exposure or potential UAF if pid structures are reused.","classification":"refcount","impact":"information leak or potential UAF on recycled pid structs","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:936-944: ipc_update_pid writes q_lspid without refcounting"],"derived_from":[],"proposed_fix_summary":"Take references to pid structs or use pidfd-backed stable handles when updating lspid/lrpid."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0023","title":"Per-namespace msg_ctlmni set low to starve global percpu counters","attacker_model":"local_unprivileged","preconditions":["Unprivileged user namespace with small msg_ctlmni","Ability to spawn many namespaces"],"description":"percpu_msg_bytes/percpu_msg_hdrs are global per-namespace counters incremented without throttling. A user creating many ipc namespaces with tiny msg_ctlmni values can force frequent percpu_counter_batch exhaustion causing atomic updates and contention, starving other namespaces and inducing DoS. Systemd containers can amplify by spawning nested namespaces.","classification":"DoS","impact":"CPU contention and IPC stall across namespaces","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:942-945: percpu_counter_add_local used per send without batching control","ipc/msg.c:72-76: percpu counters defined per namespace"] ,"derived_from":[],"proposed_fix_summary":"Rate-limit namespace creation or bound percpu counter batching relative to msg_ctlmni."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0024","title":"msg_fits_inqueue overflow on large q_qbytes","attacker_model":"container_guest","preconditions":["Privileged container with CAP_SYS_RESOURCE inside namespace","Sets msg_qbytes near ULONG_MAX"],"description":"msg_fits_inqueue sums msgsz with q_cbytes and compares against q_qbytes using unsigned long. If q_qbytes is set to ULONG_MAX via msgctl, addition can overflow and pass the check, allowing bytes to wrap and overflow accounting leading to negative values when decremented. Subsequent msgrcv decrements q_cbytes allowing double-free-like underflow conditions in accounting and wake logic.","classification":"overflow","impact":"Bypass queue size limits and destabilize accounting","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:867-899: msg_fits_inqueue uses unsigned long addition without overflow guard"] ,"derived_from":[],"proposed_fix_summary":"Clamp q_qbytes to safe max and use saturating addition or check for overflow before comparing."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0025","title":"msgrcv search with MSG_EXCEPT walks list without lock","attacker_model":"local_unprivileged","preconditions":["Attacker shares queue with another writer","Concurrent msgsnd updating q_messages"],"description":"find_msg iterates q_messages under ipc_lock_object but relies on list integrity during traversal. Another CPU enqueues while receiver scans with MSG_EXCEPT and then releases lock on return path. Attackers can trigger list corruption via fault injection in store_msg or msg allocation causing partially enqueued nodes still on list; msgrcv may dereference dangling pointers leading to crash.","classification":"race-condition","impact":"kernel crash via list corruption window","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1053-1095: find_msg walks q_messages during MSG_EXCEPT handling","ipc/msg.c:939-946: enqueue path adds to list under same lock but fault handling may leave partially initialized msg"] ,"derived_from":[],"proposed_fix_summary":"Harden message enqueue against partial initialization and validate list consistency before dereference; use list_empty_careful."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0026","title":"expunge_all wakes tasks after queue removal without memory barrier","attacker_model":"local_unprivileged","preconditions":["Concurrent IPC_RMID with many sleepers","CONFIG_SMP"],"description":"expunge_all traverses q_receivers/q_senders and wake_q_add_safe without explicit barrier after ipc_rmid removes id. Wakeups may arrive after msq memory is queued for RCU free, letting woken tasks dereference msq fields assuming validity. Attackers cause heavy sleepers then delete queue to provoke post-free use in wakeup handling.","classification":"race-condition","impact":"Use-after-free leading to crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:688-747: expunge_all walks waiters after msg_rmid with wake_q_add_safe under same lock","ipc/msg.c:65-79: msg_rcu_free frees msq after grace period"] ,"derived_from":[],"proposed_fix_summary":"Mark queue destroyed flag checked by wakeups and ensure waiters abort before touching msq fields; synchronize with RCU grace."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0027","title":"ipc_rcu_putref in send loop leaks reference on interrupted sleep","attacker_model":"local_unprivileged","preconditions":["Sender sleeps waiting for space then receives fatal signal"],"description":"In do_msgsnd, sender calls ipc_rcu_getref then sleeps. On signal, error path jumps to out_unlock0 without dropping ref if ss_del was skipped due to signal pending check prior to ss_del. Repeated signals can leak references preventing queue teardown or delaying msg_rcu_free freeing memory.","classification":"refcount","impact":"Memory leak and eventual exhaustion of msg queues","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:900-934: ipc_rcu_getref and ipc_rcu_putref path depends on ss_del; signal path may bypass putref"] ,"derived_from":[],"proposed_fix_summary":"Ensure ipc_rcu_putref on all exit paths when ipc_rcu_getref succeeded regardless of ss_del."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0028","title":"User-controlled msgtyp negative wrap in convert_mode","attacker_model":"local_unprivileged","preconditions":["msgtyp near LONG_MIN","MSG_COPY disabled"],"description":"convert_mode negates msgtyp when negative except LONG_MIN special case. Attackers supplying LONG_MIN+1 under MSG_COPY disabled cause -msgtyp overflow to large positive value, altering search semantics to SEARCH_LESSEQUAL with huge key. Combined with MSG_EXCEPT this can cause find_msg to walk many entries unnecessarily, enabling CPU DoS and unexpected message selection for privilege-separated queues.","classification":"logic-bypass","impact":"Privilege separation bypass in message selection or CPU burn","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1002-1023: convert_mode negates msgtyp with limited guard only for LONG_MIN"] ,"derived_from":[],"proposed_fix_summary":"Clamp msgtyp range and reject values near LONG_MIN unless caller privileged; use safer parsing."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0029","title":"Checkpoint/restore MSG_COPY leaks stale m_list links","attacker_model":"container_guest","preconditions":["CONFIG_CHECKPOINT_RESTORE","Container restores queue with partial messages"],"description":"During checkpoint/restore, MSG_COPY receivers may read messages whose m_list pointers reference restored but not yet fully linked list nodes. If msg->m_list not reinitialized before list_add_tail, a reader copying data can leak kernel pointers in m_list via store_msg into user buffer, exposing addresses and aiding KASLR bypass.","classification":"info-leak","impact":"Kernel pointer disclosure aiding exploitation","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:1034-1036: store_msg copies msg contents including untouched padding","ipc/msg.c:939-946: list_add_tail uses msg->m_list without zeroing after restore"] ,"derived_from":[],"proposed_fix_summary":"Zero msg structures including list_head before restoring or copying to user; avoid exposing list pointers."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0030","title":"msgctl IPC_SET allows shrinking q_qbytes below current usage","attacker_model":"privileged","preconditions":["CAP_SYS_RESOURCE","Existing queue with q_cbytes > new q_qbytes"],"description":"msgctl_set sets q_qbytes to user-provided value without validating against current q_cbytes. A privileged attacker can shrink limits below in-use bytes, leading to negative accounting when messages are later removed and possibly triggering underflow in msg_fits_inqueue and wake logic.","classification":"logic-bypass","impact":"Accounting underflow and queue breakage","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:475-515: msgctl_set accepts msg_qbytes with minimal validation against hard limit only"] ,"derived_from":[],"proposed_fix_summary":"Disallow reducing q_qbytes below q_cbytes or force immediate message drain before change."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0031","title":"msgrcv with MSG_COPY lacks permission check on subsequent copies","attacker_model":"local_unprivileged","preconditions":["Initial allowed receive passes LSM","Subsequent MSG_COPY on same message"],"description":"security_msg_queue_msgrcv() is called in find_msg before copying. After first MSG_COPY succeeds, the message remains on queue. Attackers can repeatedly issue MSG_COPY without further LSM checks, extracting payload for unprivileged context if permission was transiently granted (e.g., after setuid).", "classification":"logic-bypass","impact":"Unauthorized message disclosure","likelihood":"high","verdict":"confirmed_vuln","context":"kernel_core","evidence":["ipc/msg.c:1053-1098: find_msg performs security_msg_queue_msgrcv once then returns pointer reused for MSG_COPY"] ,"derived_from":["ipc/msg.c-0020"],"proposed_fix_summary":"Re-evaluate permissions for each MSG_COPY or consume message on copy to prevent repeated access."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0032","title":"recv loop returns -E2BIG without throttling leading to busy-loop","attacker_model":"local_unprivileged","preconditions":["Attacker issues msgrcv with tiny buffer and MSG_NOERROR clear"] ,"description":"do_msgrcv repeatedly checks msgsz vs q_rmax and returns -E2BIG. Attackers can spin using small buffers to force repeated scanning of q_messages without consuming entries, causing CPU DoS and starving other readers since IPC_NOWAIT still traverses lists and touches cache lines.","classification":"DoS","impact":"CPU exhaustion and starvation of legitimate receivers","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1100-1136: do_msgrcv checks msg->m_ts and returns error without removing message"] ,"derived_from":[],"proposed_fix_summary":"Rate-limit repeated -E2BIG responses or optionally consume message when MSG_CMSG_CLOEXEC-like flag provided."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0033","title":"Security hook bypass on msgrcv timeout restart","attacker_model":"local_unprivileged","preconditions":["Receiver uses IPC_NOWAIT cleared and is restarted after signal"],"description":"When msgrcv sleeps in prepare_to_wait and is interrupted by signal then restarted, the security_msg_queue_msgrcv check is only executed before sleeping. Attacker can change credentials while sleeping (setuid helper) and after restart resume receiving with previous approval, bypassing new restrictions.","classification":"logic-bypass","impact":"Unauthorized access to queued messages after credential change","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:1067-1098: security check prior to sleep; restart path in do_msgrcv reuses msg pointer without recheck"] ,"derived_from":[],"proposed_fix_summary":"Re-run LSM receive checks on restart after signals or credential changes."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0034","title":"Negative r_maxsize truncation leaks kernel tail bytes","attacker_model":"local_unprivileged","preconditions":["User passes negative msgtyp with MSG_COPY","Small user buffer"] ,"description":"r_maxsize is set from user supplied msgtyp for MSG_COPY in do_msgrcv. Negative values may cast to large unsigned, leading store_msg to copy more bytes than user buffer expects, causing -EFAULT side effects that copy partial kernel data beyond intended limits.","classification":"info-leak","impact":"Leak of message data beyond user-provided bounds","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:1040-1056: MSG_COPY sets r_maxsize/msgtyp interplay","ipc/msg.c:1030-1037: store_msg copies up to msg->m_ts"] ,"derived_from":[],"proposed_fix_summary":"Validate r_maxsize derived from msgtyp and clamp to user buffer length for MSG_COPY."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0035","title":"Wake_q_add_safe ordering allows double wake of sender","attacker_model":"local_unprivileged","preconditions":["Multiple blocked senders","CONFIG_PREEMPT"],"description":"pipelined_send may wake a sender via wake_q_add_safe while another receiver concurrently dequeues and wakes. Because wake_q is flushed after unlocking, a sender may be awakened twice and re-enter send path without msg_fits_inqueue reevaluated under same conditions, corrupting accounting when message is enqueued twice.","classification":"race-condition","impact":"Queue accounting corruption and potential crash","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:939-947: pipelined_send decides to wake","ipc/msg.c:951-955: wake_up_q after unlock may interleave"] ,"derived_from":[],"proposed_fix_summary":"Use atomic state to mark sender already woken or recheck fit after wake before enqueue."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0036","title":"msgctl IPC_RMID bypass via namespace teardown","attacker_model":"container_guest","preconditions":["Attacker controls user namespace with IPC namespace","Triggers namespace teardown concurrently"] ,"description":"During ipc namespace teardown, msg_exit_ns calls expunge_all on remaining queues. An attacker can keep reference to queue id and continue calling msgsnd just before exit, relying on delayed RCU free to accept messages without standard permission checks since ipc_ids has been removed from idr. This bypasses RLIMIT checks and may lead to leaks if msq persists until grace period ends.","classification":"logic-bypass","impact":"Bypass IPC permissions during namespace teardown","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:688-747: expunge_all during teardown","ipc/msgutil.c referenced by msg_exit_ns for cleanup timing"] ,"derived_from":[],"proposed_fix_summary":"Block new operations once teardown begins by flagging namespace exiting and rejecting msgsnd early."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0037","title":"Unbounded msg_prio mishandling in pipelined_send","attacker_model":"local_unprivileged","preconditions":["Attacker supplies extreme m_type values","Many receivers waiting"],"description":"pipelined_send checks only existence of waiting receiver; msg->m_type not validated beyond >0. Huge m_type combined with MSG_EXCEPT receivers can force repeated scans through q_receivers leading to long-lived locks and CPU spike. No cap on m_type also feeds into convert_mode leading to large comparisons.","classification":"DoS","impact":"CPU exhaustion via pathological message types","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:939-947: pipelined_send only checks msg presence","ipc/msg.c:1002-1023: convert_mode handles msgtyp without cap"] ,"derived_from":[],"proposed_fix_summary":"Limit message type magnitude and normalize comparisons to avoid O(n) scanning."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0038","title":"msg_queue permissions bypass via setuid after send","attacker_model":"local_unprivileged","preconditions":["Attacker sends message before dropping privileges"] ,"description":"Permissions for msgrcv are checked against current credentials at receive time, not sender. An attacker can send message when privileged, drop privileges, then rely on MSG_EXCEPT search to still retrieve messages not intended for low privilege. This can be used to smuggle data across isolation boundaries in setuid helpers.","classification":"logic-bypass","impact":"Privilege separation bypass via queued data","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:883-895: permission checks only on send; receive checks separate and per call"] ,"derived_from":[],"proposed_fix_summary":"Tag messages with sender uid/gid and enforce policy during receive even when caller changed creds."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0039","title":"msgrcv MSG_COPY can observe freed message body after free_msg","attacker_model":"local_unprivileged","preconditions":["Concurrent receiver consumes and frees message while MSG_COPY issued"] ,"description":"MSG_COPY path obtains msg pointer then later store_msg copies from it without taking extra ref. If another receiver dequeues and free_msg()s the message before MSG_COPY copy completes, user buffer may contain freed memory contents from next allocator user. Attackers with timing can leak kernel data from other objects.","classification":"race-condition","impact":"Information leak of freed kernel memory","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["ipc/msg.c:1034-1037: store_msg copies msg fields without refcount","ipc/msg.c:939-947 and free paths free_msg without MSG_COPY coordination"] ,"derived_from":[],"proposed_fix_summary":"Take reference on msg while MSG_COPY in progress or disallow MSG_COPY when another receiver can dequeue."}
{"file":"ipc/msg.c","scenario_id":"ipc/msg.c-0040","title":"Per-queue pid bookkeeping not serialized with RCU reads","attacker_model":"local_unprivileged","preconditions":["High churn of send/receive updating q_lspid/q_lrpid","Reader in /proc/sysvipc/msg"] ,"description":"/proc/sysvipc/msg dumps q_lspid and q_lrpid under msg_ids.rwsem read lock but without RCU or refcounting of struct pid. Rapid exits may free pid while proc read dereferences pid_nr_ns, leading to stale pointer deref and potential info leak/crash.","classification":"race-condition","impact":"Kernel crash or disclosure of recycled pid numbers","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["ipc/msg.c:323-367: sysvipc_msg read uses ipc_lock_object without pid ref","ipc/msg.c:936-944: lspid/lrpid set without ref"] ,"derived_from":[],"proposed_fix_summary":"Take pid references or convert to pid numbers stored atomically to avoid lifetime issues."}
