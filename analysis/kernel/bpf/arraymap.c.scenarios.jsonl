{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0001", "title": "Integer Overflow in array_map_alloc (max_entries)", "concept": "If max_entries calculation overflows, a smaller map is allocated than expected. If subsequent logic uses the original max_entries, heap corruption occurs.", "attacker_model": "local_privileged", "preconditions": ["BPF_SYSCALL", "CAP_SYS_ADMIN"], "description": "Vulnerability Path: Setup: Call map_create with large max_entries. Trigger: `array_map_alloc` computes `array_size`. `mask64 = fls_long(max_entries - 1)`. If max_entries is huge. Mechanism: `array_size` calculation uses u64 but initial multiplication might wrap if not careful. `array_size += (u64) max_entries * elem_size`. This looks safe in `array_map_alloc` due to `u64` cast, but `max_entries` is `u32`. `max_entries` itself is checked in `array_map_alloc_check` but only for 0. The `u32` value prevents `u64` overflow unless `elem_size` is huge. `elem_size` is limited by `INT_MAX`. So `(u64)u32 * u32` fits in u64. `kmalloc/vmalloc` limits usually prevent allocation of >2GB/4GB chunks. Impact: Likely ENOMEM, but worth checking boundary conditions.", "classification": "integer-overflow", "impact": "resource-exhaustion", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_alloc"], "proposed_fix_summary": "Ensure array_size calc doesn't overflow before alloc."}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0002", "title": "OOB Read in array_map_lookup_elem via Index Mask Bypass", "concept": "If `index_mask` doesn't cover `max_entries` correctly (e.g. non-power-of-2 workaround fails or speculative execution bypasses check), OOB read.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Create array map. Trigger: Lookup with index > max_entries. Mechanism: `array_map_lookup_elem` checks `index >= max_entries`. Then returns `array->value + ... (index & array->index_mask)`. `index_mask` forces power-of-2 behavior. If `bypass_spec_v1` is true, mask is skipped? No, lookup always masks. Wait, `array_map_gen_lookup` (JIT) has `bypass_spec_v1` logic. If `bypass_spec_v1` is true, JIT emits check then access without mask. Speculative execution can bypass check and access OOB before rollback. Impact: Side-channel info leak (Spectre v1).", "classification": "side-channel", "impact": "info leak", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_gen_lookup"], "proposed_fix_summary": "Ensure index masking is always present or LFENCE used."}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0003", "title": "Prog Array Map Circular Reference Leak", "concept": "Prog array map holding references to progs that hold references to the map.", "attacker_model": "local_privileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Create Prog Array Map A. Load Prog P. Update Map A with P. Bind Map A to Prog P (via `bpf_prog_bind_map` or usage). Trigger: Close FDs. Mechanism: Map holds ref to Prog. Prog holds ref to Map. Cycle. Memory leak. Impact: Resource exhaustion.", "classification": "resource-exhaustion", "impact": "DoS", "likelihood": "medium", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:prog_fd_array_get_ptr"], "proposed_fix_summary": "Detect cycles or limit nesting depth."}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0004", "title": "Perf Event Array Map UAF via Race", "concept": "Race between `perf_event_fd_array_release` and map free/update.", "attacker_model": "local_privileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Map with perf events. Trigger: Close perf event FD concurrent with map free. Mechanism: `perf_event_fd_array_release` iterates map. `READ_ONCE(array->ptrs[i])`. Calls `__fd_array_map_delete_elem`. This takes mutex. Map free calls `perf_event_fd_array_map_free`. If both run, refcounting on perf_event or map might be racy? `bpf_fd_array_map_clear` called during free. `filp->private_data` holds map ref? No, map holds event ref. Event holds file ref. File release calls map release. Map release modifies map. If map is being freed, map ref count should prevent premature free. If event release is triggered by map free (circular?), recursion? Impact: UAF/Double Free.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:perf_event_fd_array_release"], "proposed_fix_summary": "Review locking and lifetime."}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0005", "title": "Memory Leak in bpf_array_alloc_percpu failure", "concept": "Failure in percpu allocation loop leaves partially allocated percpu pointers.", "attacker_model": "local_privileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Alloc large percpu array. Trigger: ENOMEM in loop. Mechanism: `bpf_array_alloc_percpu` loops. On failure calls `bpf_array_free_percpu`. This frees `array->pptrs[i]` for `i < max_entries`. Since `pptrs` was kzalloced, unallocated slots are NULL. `free_percpu(NULL)` is safe. Logic seems correct. Impact: None.", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:bpf_array_alloc_percpu"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0006", "title": "Invalid Map Ptr from Prog Array during Poke", "concept": "Concurrent update/poke might use stale/invalid pointer.", "attacker_model": "local_privileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Prog array. Trigger: JIT poke update concurrent with map update. Mechanism: `prog_array_map_poke_run`. Accesses `aux->poke_progs`. Protected by `poke_mutex`. Use of `READ_ONCE` on stable flag. Seems robust. Impact: UAF if locking missing.", "classification": "race-condition", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:prog_array_map_poke_run"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0007", "title": "Integer Overflow in array_map_mem_usage", "concept": "Memory usage calculation overflows 64-bit integer.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Map with huge `max_entries` and `elem_size`. Trigger: `map_mem_usage`. Mechanism: `entries * elem_size`. `entries` is u32, `elem_size` is u32. Product fits in u64. `num_possible_cpus()` multiplier. If huge number of CPUs and max allocation? Still likely within u64 (16EB). Impact: Incorrect accounting.", "classification": "integer-overflow", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_mem_usage"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0008", "title": "bpf_array_get_next_key Infinite Loop", "concept": "If `next_key` handling is broken, userspace iteration hangs.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Map. Trigger: `get_next_key`. Mechanism: `*next = index + 1`. If `index == max_entries - 1`, returns ENOENT. Correct. Impact: None.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:bpf_array_get_next_key"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0009", "title": "Map-in-Map Inner Map Metadata Corruption", "concept": "Corrupting `inner_map_meta` during allocation.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Array of maps. Trigger: Alloc. Mechanism: `bpf_map_meta_alloc` creates meta. `array_of_map_alloc` assigns it. `bpf_map_meta_free` on error. Seems correct. Impact: None.", "classification": "memory-corruption", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_of_map_alloc"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0010", "title": "Prog Array Infinite Recursion via Tail Call", "concept": "Creating a tail call loop using prog array updates.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_JIT"], "description": "Vulnerability Path: Setup: Prog A calls B, B calls A. Put B in A's array. Trigger: Run A. Mechanism: `MAX_TAIL_CALL_CNT` (33) limits recursion depth in interpreter and JIT. The map update itself doesn't check for cycles, but execution does. Impact: None (handled by runtime).", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:prog_fd_array_get_ptr"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0011", "title": "Array Map MMap vs Freeze Race", "concept": "Mapping array map as writable, then freezing it.", "attacker_model": "local_privileged", "preconditions": ["BPF_F_MMAPABLE"], "description": "Vulnerability Path: Setup: MMAP array map. Write to it. Trigger: Freeze map from another thread. Mechanism: `map_freeze` sets `frozen` bit. `bpf_map_mmap` checks `frozen`. But existing mappings? `bpf_map_mmap` open/close counters. `map_freeze` fails if `writecnt > 0`. Impact: Safe.", "classification": "race-condition", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:map_freeze"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0012", "title": "Per-CPU Array Value Size Mismatch", "concept": "Allocating percpu array with size mismatching actual percpu allocator alignment/size.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: `value_size` 1. Trigger: Alloc. Mechanism: `round_up(value_size, 8)`. `pcpu` allocator handles small sizes. Impact: Wasted memory, no corruption.", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_alloc"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0013", "title": "Lookup Batch NULL ptr deref", "concept": "Providing NULL pointers to batch lookup.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Batch lookup. Trigger: NULL `keys` or `values`. Mechanism: `generic_map_lookup_batch` checks pointers. Returns EFAULT. Impact: None.", "classification": "memory-corruption", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:generic_map_lookup_batch"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0014", "title": "Prog Array Extended Prog Exclusion", "concept": "Inserting extended prog into prog array.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Prog type EXT. Trigger: Insert into Prog Array. Mechanism: `prog_fd_array_get_ptr` checks `prog->type == BPF_PROG_TYPE_EXT`. Returns EINVAL. `is_extended` check. Impact: Correctly prevented.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:prog_fd_array_get_ptr"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0015", "title": "Zero-init of Per-CPU Array", "concept": "Ensuring per-cpu array elements are zeroed.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Alloc per-cpu array. Trigger: Read without write. Mechanism: `bpf_map_alloc_percpu` uses `__alloc_percpu_gfp`. Returns zeroed memory? Yes, `zalloc`. Impact: Safe.", "classification": "info-leak", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:bpf_array_alloc_percpu"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0016", "title": "Array Map Direct Value Access OOB", "concept": "Direct value access beyond map size.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Map. Trigger: Direct access offset > value_size. Mechanism: `array_map_direct_value_meta` checks `imm` against range. `array_map_direct_value_addr` checks `off`. Impact: Safe.", "classification": "boundary-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_direct_value_meta"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0017", "title": "Array Map Delete Elem", "concept": "Deleting element from Array Map.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Array Map. Trigger: Delete elem. Mechanism: `array_map_delete_elem` returns `EINVAL`. Array maps don't support delete. Correct.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_delete_elem"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0018", "title": "Alloc Array Map with huge value_size", "concept": "Integer overflow in `array_size` calc with huge value_size.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: `max_entries=1`, `value_size` near U32_MAX. Trigger: Alloc. Mechanism: `array_map_alloc_check` checks `value_size > INT_MAX`. `round_up` overflow check. Impact: Safe.", "classification": "integer-overflow", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_alloc_check"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0019", "title": "Concurrent Access to array_map_elem_ptr", "concept": "Racy access to element pointer helper.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Call `array_map_elem_ptr`. Trigger: Concurrent calls. Mechanism: Calculates pointer based on base and index. Read-only operation. Safe.", "classification": "race-condition", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_elem_ptr"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/arraymap.c", "scenario_id": "kernel/bpf/arraymap.c-0020", "title": "Bypass Speculation V1 Check", "concept": "Bypassing Spectre v1 mitigation in array lookup.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Bypass spec v1 enabled. Trigger: Lookup. Mechanism: `array_map_alloc` sets `bypass_spec_v1`. `array_map_gen_lookup` omits masking if set. Controlled by sysctl/capability. Admin opts in to risk. Impact: Accepted risk.", "classification": "side-channel", "impact": "info leak", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/arraymap.c:array_map_gen_lookup"], "proposed_fix_summary": "N/A"}
