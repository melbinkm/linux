{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0001", "title": "Div/Mod by Zero via register truncation (32-bit ALU)", "concept": "JIT backends might optimize div/mod operations. If the JIT implementation of 32-bit ALU operations on 64-bit registers doesn't correctly handle the zero check for the 32-bit sub-register, a division by zero exception can occur.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_JIT"], "description": "Vulnerability Path: Setup: BPF program with 32-bit div/mod. Trigger: R1 = 0x100000000 (lower 32 bits are 0). R2 = 10. R0 = R2 / R1 (32-bit div). Mechanism: `do_div` checks for 0. JITs implementing 32-bit div might check full 64-bit register for 0 instead of lower 32 bits. Impact: Kernel crash (divide error).", "classification": "logic-bypass", "impact": "kernel crash", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:ALU_DIV_X", "kernel/bpf/core.c:ALU_MOD_X"], "proposed_fix_summary": "Ensure JITs check the correct operand width for zero."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0002", "title": "Tail Call Infinite Loop via Hierarchy Bypass", "concept": "Tail calls allow jumping to another BPF program. `MAX_TAIL_CALL_CNT` prevents infinite loops. If a BPF program can reset this count or bypass the check (e.g. by exploiting JIT state or recursion), it leads to an infinite loop.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_JIT"], "description": "Vulnerability Path: Setup: Prog A tail calls Prog B. Prog B tail calls Prog A. Trigger: Run Prog A. Mechanism: `tail_call_cnt` logic. If JIT implementation of tail call fails to propagate or increment `tail_call_cnt` correctly across specific transitions (e.g. trampoline to JIT). Impact: Core freeze/DoS.", "classification": "resource-exhaustion", "impact": "persistent DoS", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:JMP_TAIL_CALL"], "proposed_fix_summary": "Audit JIT tail call implementation for counter handling."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0003", "title": "Speculative Store Bypass (SSB) in Interpreted Code", "concept": "Interpreted BPF code might be vulnerable to Spectre v4 (SSB) if the `ST_NOSPEC` instruction or mitigation logic is insufficient for the interpreter context.", "attacker_model": "local_unprivileged", "preconditions": ["bpf_jit_enable=0"], "description": "Vulnerability Path: Setup: Interpreted BPF program. Trigger: Speculative execution of load after store. Mechanism: `___bpf_prog_run` relies on `barrier_nospec()` for `ST_NOSPEC`. If the interpreter's switch/dispatch logic introduces speculative windows. Impact: Info leak.", "classification": "side-channel", "impact": "info leak", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:ST_NOSPEC"], "proposed_fix_summary": "Ensure interpreter dispatch is robust against SSB."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0004", "title": "Integer Overflow in bpf_prog_alloc size calculation", "concept": "Calculation of allocation size in `bpf_prog_alloc` might overflow if `size` is very large.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Load huge BPF prog. Trigger: `bpf_prog_alloc`. Mechanism: `size = round_up(size, __PAGE_SIZE)`. If `size` is close to UINT_MAX, `round_up` might overflow or wrap. `__vmalloc` might succeed with small size. Buffer overflow when copying instructions. Impact: Heap corruption.", "classification": "integer-overflow", "impact": "kernel crash", "likelihood": "low", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_prog_alloc_no_stats"], "proposed_fix_summary": "Check for overflow in `round_up` or limit max prog size earlier."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0005", "title": "JIT Constant Blinding Randomness Weakness", "concept": "Constant blinding uses `get_random_u32()`. If the RNG is weak or predictable, blinding is ineffective against JIT spraying.", "attacker_model": "local_unprivileged", "preconditions": ["bpf_jit_harden=2"], "description": "Vulnerability Path: Setup: JIT hardening enabled. Trigger: Load BPF prog with constants. Mechanism: `bpf_jit_blind_constants` uses `get_random_u32`. If attacker can predict RNG state (e.g. boot time), they can bypass blinding. Impact: JIT spraying success.", "classification": "crypto-weakness", "impact": "mitigation bypass", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_jit_blind_insn"], "proposed_fix_summary": "Use cryptographically secure RNG for blinding."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0006", "title": "bpf_check_timed_may_goto clock dependency", "concept": "`may_goto` loop termination relies on `ktime_get_mono_fast_ns()`. If clock is manipulated or stalls, infinite loop is possible.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: `may_goto` loop. Trigger: Clock stalling/manipulation. Mechanism: `bpf_check_timed_may_goto` checks `time - p->timestamp`. If `time` doesn't advance. Impact: Persistent DoS.", "classification": "DoS", "impact": "persistent DoS", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_check_timed_may_goto"], "proposed_fix_summary": "Use cycle counter or robust timeout."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0007", "title": "KASAN Shadow Corruption in bpf_prog_pack", "concept": "BPF prog pack allocator manipulates executable memory. Incorrect handling of KASAN shadow memory for these regions could lead to false negatives or corruption.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_KASAN"], "description": "Vulnerability Path: Setup: Alloc BPF prog in pack. Trigger: Write to prog memory (JIT update). Mechanism: `bpf_prog_pack_alloc` vs KASAN. Impact: Missed OOB writes in JIT or KASAN false positives.", "classification": "memory-corruption", "impact": "correctness", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_prog_pack_alloc"], "proposed_fix_summary": "Verify KASAN shadow handling for prog packs."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0008", "title": "Race in bpf_prog_kallsyms_add", "concept": "Adding symbols to kallsyms might race with other BPF operations or kallsyms readers.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Load/Unload progs rapidly. Trigger: `bpf_prog_kallsyms_add`. Mechanism: `bpf_lock` spinlock protects list/tree. Interaction with RCU readers (`bpf_get_kallsym`) seems safe but complex. Impact: UAF in symbol lookup.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_prog_kallsyms_add"], "proposed_fix_summary": "Review RCU usage."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0009", "title": "bpf_jit_binary_pack_finalize W^X Violation", "concept": "Finalizing JIT binary copies from RW buffer to RO buffer. If RO buffer is not properly protected before copy or there's a race.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_JIT"], "description": "Vulnerability Path: Setup: JIT compile. Mechanism: `bpf_jit_binary_pack_finalize` calls `bpf_arch_text_copy`. Requires `text_poke`. If `text_poke` fails or is bypassed. Impact: Writable executable memory.", "classification": "permission-bypass", "impact": "code execution", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_jit_binary_pack_finalize"], "proposed_fix_summary": "Strict W^X enforcement."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0010", "title": "Shift out of bounds in Interpreter", "concept": "Shift operations with count >= width are undefined behavior in C. Interpreter masks them, but JITs might not.", "attacker_model": "local_unprivileged", "preconditions": ["bpf_jit_enable=0"], "description": "Vulnerability Path: Setup: BPF prog. Trigger: `LSH` by 64. Mechanism: `DST = DST OP (SRC & 63)`. Interpreter masks correctly. JITs are warned in comment. Impact: Inconsistent behavior between JIT and Interpreter.", "classification": "logic-bypass", "impact": "correctness", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:___bpf_prog_run"], "proposed_fix_summary": "Verify JITs mask shifts."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0011", "title": "bpf_prog_realloc zeroing", "concept": "Reallocating program buffer. `__vmalloc` with `__GFP_ZERO`. `memcpy` copies old data. Tail part is zeroed. If logic assumes full copy.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Realloc. Mechanism: `bpf_prog_realloc`. Impact: Safe due to `__GFP_ZERO`.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_prog_realloc"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0012", "title": "Atomic Fetch-Op Truncation", "concept": "Atomic fetch operations on 32-bit values might truncate or sign-extend incorrectly when stored in 64-bit registers in the interpreter.", "attacker_model": "local_unprivileged", "preconditions": ["bpf_jit_enable=0"], "description": "Vulnerability Path: Setup: `STX_ATOMIC_W`. Trigger: `BPF_ADD | BPF_FETCH`. Mechanism: `SRC = (u32) atomic_fetch_add(...)`. Cast to `u32` zeros upper bits. Correct for `BPF_W`. Impact: None.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:___bpf_prog_run"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0013", "title": "Recursion in bpf_prog_free_deferred", "concept": "`bpf_prog_free_deferred` frees subprograms. If subprograms reference main program or other subprograms in a loop (refcount cycle handled elsewhere?), recursion depth in free path.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Complex prog hierarchy. Trigger: Free. Mechanism: `bpf_prog_free_deferred` loops over subprogs. Iterative, not recursive. Impact: None.", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_prog_free_deferred"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0014", "title": "bpf_jit_charge_modmem limits", "concept": "JIT memory charging against `bpf_jit_limit`. If limit calculation is wrong or charging is bypassed.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Massive JIT allocs. Trigger: Exceed limit. Mechanism: `bpf_jit_charge_modmem` uses atomic_long_add. Checks limit. Returns -EPERM. Impact: DoS prevented.", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_jit_charge_modmem"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0015", "title": "bpf_obj_name_cpy validation", "concept": "Validating object names. `isalnum`, `_`, `.`. If other chars allowed.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Name with special chars. Trigger: `bpf_obj_name_cpy`. Mechanism: Explicit check. Impact: None.", "classification": "input-validation", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_obj_name_cpy"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0016", "title": "Interpreter Stack Overflow via recursion", "concept": "The interpreter uses kernel stack for `u64 stack[stack_size / 8]`. `DEFINE_BPF_PROG_RUN` macros. If stack size is large, `___bpf_prog_run` (which is forced inline) adds to frame size. Tail calls reuse frame? No, tail calls use `goto select_insn`. Recursion (bpf-to-bpf call)? Interpreter handles calls via `BPF_CALL` helper or internal implementation. `JMP_CALL` calls `__bpf_call_base + imm`. If this calls another interpreted prog.", "attacker_model": "local_unprivileged", "preconditions": ["bpf_jit_enable=0"], "description": "Vulnerability Path: Setup: BPF-to-BPF calls. Trigger: Deep recursion. Mechanism: Kernel stack usage per call. `MAX_BPF_STACK` limits BPF stack, but kernel stack overhead exists. Impact: Stack overflow.", "classification": "resource-exhaustion", "impact": "crash", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:DEFINE_BPF_PROG_RUN"], "proposed_fix_summary": "Limit recursion depth in interpreter."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0017", "title": "Call Argument Patching Race", "concept": "Patching `BPF_CALL_ARGS` offsets. `bpf_patch_call_args`. If concurrent execution during patching.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Load prog. Trigger: Patch args. Mechanism: `bpf_patch_call_args` modifies instructions. Should happen before visibility. Verifier/JIT phase. Impact: None if ordered.", "classification": "race-condition", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_patch_call_args"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0018", "title": "bpf_jit_binary_alloc sizing", "concept": "Allocation size for JIT binary. `proglen + sizeof(*hdr) + 128`. Round up to PAGE_SIZE. If `proglen` is huge, `round_up` overflow?", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Huge prog. Trigger: JIT. Mechanism: `bpf_jit_binary_alloc`. `round_up`. Integer overflow. Impact: Small allocation, heap corruption.", "classification": "integer-overflow", "impact": "crash", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_jit_binary_alloc"], "proposed_fix_summary": "Check for overflow."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0019", "title": "bpf_prog_pack_free bitmap corruption", "concept": "Double free or invalid pointer passed to `bpf_prog_pack_free`. Bitmap manipulation.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Double free. Trigger: `bpf_prog_pack_free`. Mechanism: `bitmap_clear`. No check if already clear? `WARN_ONCE`. Impact: Corruption of allocator state.", "classification": "double-free", "impact": "corruption", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_prog_pack_free"], "proposed_fix_summary": "Check bit state before clearing."}
{"file": "kernel/bpf/core.c", "scenario_id": "kernel/bpf/core.c-0020", "title": "bpf_dump_raw_ok credential check", "concept": "Checking credentials for dumping BPF info. `bpf_dump_raw_ok(f_cred)`. If `f_cred` is stale or incorrect context.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Open FD. Drop privs. Trigger: Dump. Mechanism: Checks credentials stored in file object (`file->f_cred`). Correct behavior. Impact: None.", "classification": "privilege-escalation", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/core.c:bpf_insn_prepare_dump"], "proposed_fix_summary": "N/A"}
