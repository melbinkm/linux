{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0001", "title": "Circular Reference Resource Leak (Prog-Map Cycle)", "concept": "Resource leak via circular dependency between BPF program and BPF map, causing unclaimable memory.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL", "BPF_MAP_TYPE_PROG_ARRAY enabled"], "description": "Vulnerability Path: Setup: Create a BPF_MAP_TYPE_PROG_ARRAY (Map M). Load a BPF program (Prog A). Trigger: Update Map M to contain Prog A. Call `bpf_prog_bind_map` to bind Map M to Prog A. Mechanism: Prog A holds ref to Map M (via bind). Map M holds ref to Prog A (via content). Both refcounts > 0. Closing FDs decrements user ref, but circular kernel refs remain. Impact: Permanent memory leak of Prog A and Map M.", "classification": "resource-exhaustion", "impact": "persistent DoS", "likelihood": "high", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_prog_bind_map", "kernel/bpf/syscall.c:bpf_map_put", "kernel/bpf/syscall.c:bpf_prog_put"], "proposed_fix_summary": "Detect cycles during bind or map update, or use weak references for one direction."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0002", "title": "Stats Toggle Performance DoS", "concept": "Denial of Service via rapid toggling of global BPF stats, triggering expensive static key updates.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL", "CAP_SYS_ADMIN"], "description": "Vulnerability Path: Setup: Acquire CAP_SYS_ADMIN. Trigger: Loop calling `bpf_enable_stats` (BPF_STATS_RUN_TIME) and closing the FD immediately. Mechanism: `bpf_enable_stats` calls `static_key_slow_inc`. `bpf_stats_release` calls `static_key_slow_dec`. These operations involve IPIs to all CPUs to patch code/update state. Rapid looping causes system-wide performance degradation. Impact: System slowdown / DoS.", "classification": "DoS", "impact": "performance degradation", "likelihood": "medium", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_enable_stats", "kernel/bpf/syscall.c:bpf_stats_release"], "proposed_fix_summary": "Rate limit stats toggling or use a lighter weight mechanism."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0003", "title": "Bind Map Memory Exhaustion", "concept": "Memory exhaustion via repeated binding of maps to a single program.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Load BPF program. Create BPF map. Trigger: Repeatedly call `bpf_prog_bind_map` binding the same map to the program. Mechanism: `bpf_prog_bind_map` reallocates the `used_maps` array on every call (`kmalloc_array(cnt + 1)`). It copies existing pointers. No limit on `used_map_cnt` is enforced in this function (bounded only by u32). Exponential cost for linear growth. Impact: Wastes kernel memory and CPU time copying arrays.", "classification": "resource-exhaustion", "impact": "DoS", "likelihood": "medium", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_prog_bind_map"], "proposed_fix_summary": "Enforce a limit on `used_map_cnt` or check for duplicates before adding."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0004", "title": "Unprivileged BPF Toggle Bypass via Token", "concept": "Bypass of `unprivileged_bpf_disabled` sysctl using BPF Tokens.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL", "sysctl_unprivileged_bpf_disabled=1"], "description": "Vulnerability Path: Setup: Admin sets `unprivileged_bpf_disabled=1`. Admin creates a BPF Token and passes FD to unpriv user. Trigger: User calls `bpf_prog_load` with `BPF_F_TOKEN_FD`. Mechanism: `bpf_prog_load` checks `if (sysctl_unprivileged_bpf_disabled && !bpf_cap) goto put_token;`. `bpf_cap` is derived from `bpf_token_capable(token, CAP_BPF)`. If token grants capability, the sysctl check is skipped. Impact: Unprivileged user loads BPF code despite global disable.", "classification": "logic-bypass", "impact": "policy bypass", "likelihood": "medium", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_prog_load"], "proposed_fix_summary": "Clarify documentation that Token supersedes sysctl, or add check to enforce sysctl even with token."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0005", "title": "Link ID Exhaustion", "concept": "Exhaustion of global Link IDs preventing new links.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Loop creating BPF links (e.g., cgroup links). Trigger: Create 2^31 links (or whatever the IDR limit/memory limit allows). Mechanism: `bpf_link_alloc_id` allocates from global `link_idr`. If exhausted, no new links can be created system-wide. Impact: Denial of Service for BPF operations.", "classification": "resource-exhaustion", "impact": "DoS", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_link_alloc_id"], "proposed_fix_summary": "Per-user/cgroup limits on number of links."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0006", "title": "Map Freeze vs MMap Write Race", "concept": "Race condition attempting to bypass map freezing via concurrent mmap writes.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Create map, mmap as RW. Trigger: Thread A calls `bpf_map_freeze`. Thread B writes to mmap. Mechanism: `bpf_map_mmap` increments `writecnt`. `map_freeze` checks `writecnt`. If mmap is active writable, freeze fails. Logic seems robust, but verifies complex interaction. Impact: Potential integrity violation if race exists.", "classification": "race-condition", "impact": "integrity violation", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:map_freeze", "kernel/bpf/syscall.c:bpf_map_mmap"], "proposed_fix_summary": "None needed, logic appears correct."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0007", "title": "BPF Link Update Concurrency", "concept": "Concurrent updates to a BPF link might cause state inconsistency.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Create replaceable link. Trigger: Two threads call `link_update` simultaneously. Mechanism: `link_update` does not lock the link object itself before calling `ops->update_prog`. Correctness depends on specific link implementation (e.g., cgroup) handling concurrency. Impact: Potential UAF or state corruption if ops don't lock.", "classification": "race-condition", "impact": "corruption", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:link_update"], "proposed_fix_summary": "Ensure all `update_prog` implementations handle concurrency."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0008", "title": "Map Lookup Batch Memory Exhaustion", "concept": "Allocating excessive kernel memory via `map_lookup_batch`.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Create map with large key/value size. Trigger: Call `map_lookup_batch` with large `count`. Mechanism: `generic_map_lookup_batch` calls `kvmalloc` for `keys` and `values` buffers based on `count`. `kvmalloc` can allocate large amounts. Impact: OOM killer invocation, pressure on memory.", "classification": "resource-exhaustion", "impact": "DoS", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:generic_map_lookup_batch"], "proposed_fix_summary": "Limit max batch size."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0009", "title": "Raw Tracepoint Module Unload Race", "concept": "Race between raw tracepoint link attachment and module unload.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL", "CONFIG_MODULES"], "description": "Vulnerability Path: Setup: Load module with tracepoint. Trigger: Attach raw_tp link to it. Unload module concurrently. Mechanism: `bpf_raw_tp_link_attach` finds tp. `bpf_probe_register` attaches. Does it hold module reference? `bpf_probe_register` usually doesn't pin module. If module unloads while probe is active? Tracing subsystem handles this via `tracepoint_synchronize_unregister`? Impact: UAF if not synchronized.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_raw_tp_link_attach"], "proposed_fix_summary": "Ensure tracepoint registration holds module ref or unregistration syncs."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0010", "title": "Prog Test Run Recursion Depth", "concept": "Stack overflow via recursive `BPF_PROG_TEST_RUN`.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: BPF prog calling `bpf_sys_bpf`. Trigger: `bpf_sys_bpf` calls `BPF_PROG_TEST_RUN`. Mechanism: `kern_sys_bpf` calls `bpf_prog_test_run`. Recursion protection `__bpf_prog_enter_sleepable_recur` exists. Scenario validates if limit is sufficient to prevent stack overflow. Impact: Kernel stack overflow / Crash.", "classification": "resource-exhaustion", "impact": "crash", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:kern_sys_bpf"], "proposed_fix_summary": "Verify stack usage per recursion level."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0011", "title": "Map Update Value Kptr Leak", "concept": "Leaking kernel pointers via map update syscall if validation is weak.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Map with `BPF_KPTR_REF`. Trigger: `map_update_elem` syscall with crafted value containing arbitrary address. Mechanism: `bpf_map_update_value` copies user value. `copy_map_value` must ensure kptr fields are zeroed or validated. If not, user injects bad kptr. `bpf_map_free` later frees it. Impact: Arbitrary free / UAF.", "classification": "type-confusion", "impact": "privilege escalation", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_map_update_value"], "proposed_fix_summary": "Ensure `copy_map_value` zeroes kptr fields from userspace."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0012", "title": "BPF Link Primer Leak", "concept": "Leaking BPF Link memory/ID if `settle` is not called.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Call `link_create`. `bpf_link_prime` succeeds. Trigger: Attach fails. `bpf_link_cleanup` called. Mechanism: `bpf_link_cleanup` fputs file. If file release is delayed or raced, does ID remain? `bpf_link_free_id` is called. Cleanup seems correct. Impact: Resource leak check.", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_link_cleanup"], "proposed_fix_summary": "None."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0013", "title": "Struct Ops Map Update Type Confusion", "concept": "Type confusion in `struct_ops` map update via syscall.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: `struct_ops` map. Trigger: `map_update_elem` with malicious value (fake function pointers). Mechanism: `bpf_struct_ops_map_update_elem` (in other file) must verify every pointer matches expected BTF type. If dispatch in `syscall.c` allows race or bypass. Impact: Control Flow Hijacking.", "classification": "type-confusion", "impact": "RCE", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_map_update_value"], "proposed_fix_summary": "Strict BTF verification."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0014", "title": "BTF Load Large Allocation", "concept": "Memory exhaustion via large BTF load.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Craft large BTF blob. Trigger: `BPF_BTF_LOAD`. Mechanism: `btf_new_fd` allocates memory for BTF. `kvmalloc`. Impact: OOM.", "classification": "resource-exhaustion", "impact": "DoS", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_btf_load"], "proposed_fix_summary": "Limit max BTF size."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0015", "title": "Prog Load License Check Bypass", "concept": "Bypassing GPL license check via string manipulation.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Prog with GPL-only helpers. Trigger: `BPF_PROG_LOAD` with license string that passes check but isn't GPL? Mechanism: `license_is_gpl_compatible`. String copy `strncpy_from_bpfptr`. Impact: Policy bypass.", "classification": "logic-bypass", "impact": "policy bypass", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_prog_load"], "proposed_fix_summary": "None."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0016", "title": "Map Get Next Key NULL deref", "concept": "NULL pointer dereference in `map_get_next_key` with invalid pointers.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Map. Trigger: `BPF_MAP_GET_NEXT_KEY` with invalid user pointers. Mechanism: `__bpf_copy_key` handles NULL. `copy_to_user` handles fault. Logic checks for NULLs. Impact: Crash.", "classification": "memory-corruption", "impact": "crash", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:map_get_next_key"], "proposed_fix_summary": "None."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0017", "title": "Task FD Query Info Leak", "concept": "Leaking task info via `BPF_TASK_FD_QUERY`.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_BPF_SYSCALL", "CAP_SYS_ADMIN"], "description": "Vulnerability Path: Setup: Target task. Trigger: Query FD. Mechanism: Returns probe offset, addr, etc. Impact: KASLR leak. Requires CAP_SYS_ADMIN, so acceptable.", "classification": "info-leak", "impact": "info leak", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_task_fd_query"], "proposed_fix_summary": "None."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0018", "title": "Prog Attach Check Attach Type Confusion", "concept": "Attaching prog with mismatched attach type.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Prog with expected attach type A. Trigger: Attach with type B. Mechanism: `bpf_prog_attach_check_attach_type` validates. Complex switch case. If gap exists, invalid context passed to prog. Impact: Context confusion.", "classification": "type-confusion", "impact": "unknown", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_prog_attach_check_attach_type"], "proposed_fix_summary": "Audit switch cases."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0019", "title": "Obj Pin Path Traversal", "concept": "Path traversal in `bpf_obj_pin`.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: `../` in path. Trigger: `BPF_OBJ_PIN`. Mechanism: `user_path_at` handles traversal. VFS layer security. Impact: File creation outside allowed dir. Unlikely due to VFS.", "classification": "logic-bypass", "impact": "file write", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_obj_pin"], "proposed_fix_summary": "None."}
{"file": "kernel/bpf/syscall.c", "scenario_id": "kernel/bpf/syscall.c-0020", "title": "Map Value Size Overflow", "concept": "Overflow in map value size calculation.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Per-cpu map. Trigger: Large value size. Mechanism: `bpf_map_value_size` calculates `round_up(value_size, 8) * num_possible_cpus()`. Integer overflow if result > 4GB? Returns `u32`. Truncation? Impact: Small allocation for large value access -> Heap overflow.", "classification": "integer-overflow", "impact": "heap overflow", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/syscall.c:bpf_map_value_size"], "proposed_fix_summary": "Check for overflow in size calculation."}
