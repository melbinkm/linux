{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0001", "title": "Precision Loss on Linear Stack Load", "concept": "Precision tracking relies on jump history to identify stack accesses. Linear stack loads (not jump targets) lack history, causing backtracking to drop precision requirements, leading to unsafe pruning.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_JIT_ALWAYS_ON=y", "unprivileged_bpf_disabled=0"], "description": "Vulnerability Path: Setup: Load unknown scalar R1. Spill R1 to stack (linear, no jump). Load R2 from stack (linear). Trigger: Use R2 in a context requiring precision (e.g., variable offset access). Mechanism: `backtrack_insn` checks `hist->flags & INSN_F_STACK_ACCESS` for LDX. Linear instructions have no `jmp_history`. Returns 0. Precision tracking stops. R1 remains imprecise. regsafe prunes unsafe state.", "classification": "logic-bypass", "impact": "boundary bypass", "likelihood": "high", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:backtrack_insn"], "proposed_fix_summary": "Ensure linear stack accesses also record history or `backtrack_insn` can deduce stack access from R10 usage."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0002", "title": "32-bit ALU Bounds Desynchronization", "concept": "32-bit ALU operations update 32-bit bounds and sync to 64-bit. Edge cases in sign extension or wrapping can cause verifier's 64-bit bounds to diverge from actual values.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_JIT_ALWAYS_ON=y"], "description": "Vulnerability Path: Setup: R1 = 0xFFFFFFFF80000000. Trigger: ALU32 op (e.g. w1 += 0). Mechanism: `__reg_combine_64_into_32` or vice-versa logic flaw. Verifier sees R1 as small positive u64. Actual R1 is negative s64. Access array with R1.", "classification": "logic-bypass", "impact": "boundary bypass", "likelihood": "medium", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:adjust_scalar_min_max_vals"], "proposed_fix_summary": "Strengthen `zext` handling and bounds deduction logic."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0003", "title": "Dynptr Slice Use-After-Destruction", "concept": "Dynptr slices are pointers to memory managed by a dynptr on the stack. Overwriting the stack slot should invalidate slices. Partial or aliased overwrites might be missed.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_DYNPTR"], "description": "Vulnerability Path: Setup: Create dynptr. Get slice R1. Trigger: Overwrite dynptr stack slot using a helper or partial write. Mechanism: `check_stack_write` -> `destroy_if_dynptr_stack_slot` might fail to detect specific write patterns (e.g. via `bpf_probe_read_kernel`). Impact: R1 remains valid but points to garbage/freed memory.", "classification": "UAF", "impact": "info leak", "likelihood": "medium", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:destroy_if_dynptr_stack_slot"], "proposed_fix_summary": "Ensure all stack writes, including helpers, trigger dynptr destruction."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0004", "title": "bpf_loop Callback Stack Overflow", "concept": "Inlined `bpf_loop` calls a subprog. The stack depth check might not account for the dynamic nature of the callback or recursion limits correctly if nested.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Main prog uses max stack. Call `bpf_loop` with callback using stack. Trigger: deeply nested loops or multiple callbacks. Mechanism: `check_max_stack_depth` uses call graph. If `bpf_loop` edge is not weighted correctly, stack overflow occurs at runtime.", "classification": "resource-exhaustion", "impact": "kernel crash", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_max_stack_depth"], "proposed_fix_summary": "Enforce strict stack depth counting for callbacks."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0005", "title": "BPF_CMPXCHG on Stack Pointer Type Confusion", "concept": "Atomic exchange on a stack slot containing a pointer might leave the slot in an inconsistent state if the verifier doesn't scrub it properly upon failure or success.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_JIT_ALWAYS_ON=y"], "description": "Vulnerability Path: Setup: Spill PTR to stack. Trigger: BPF_CMPXCHG on stack slot. Mechanism: Verifier must convert slot to STACK_MISC. If it preserves PTR type conditionally or incorrectly, attacker treats scalar as pointer.", "classification": "type-confusion", "impact": "boundary bypass", "likelihood": "low", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_atomic"], "proposed_fix_summary": "Always scrub stack slots on atomic ops."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0006", "title": "check_ptr_off_reg Overflow", "concept": "Adding a huge scalar to a pointer can cause 64-bit overflow, wrapping around to a valid-looking address.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: R1 = valid ptr. R2 = huge scalar. Trigger: R1 += R2. Mechanism: `adjust_ptr_min_max_vals` checks for overflow. If check is insufficient (e.g. allowing wrap if resulting pointer is still 'within' object bounds logic), access is unsafe.", "classification": "boundary-bypass", "impact": "OOB access", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:adjust_ptr_min_max_vals"], "proposed_fix_summary": "Strict overflow checks for pointer arithmetic."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0007", "title": "may_goto Infinite Loop DoS", "concept": "`may_goto` instruction relies on a runtime counter. If optimizations remove the counter update or the branch, infinite loop is possible.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_JIT_ALWAYS_ON=y"], "description": "Vulnerability Path: Setup: Loop with `may_goto`. Trigger: Dead code elimination or NOP removal interacts bady with `may_goto` expansion. Mechanism: `opt_remove_nops` removes part of the expanded `may_goto` sequence. Impact: Infinite loop in kernel.", "classification": "DoS", "impact": "persistent DoS", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:opt_remove_nops"], "proposed_fix_summary": "Ensure `may_goto` sequences are atomic/protected from optimization."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0008", "title": "kptr_xchg Reference Leak", "concept": "Exchanging a kptr might leak the old reference if not properly released or tracked.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Map with kptr. Trigger: `kptr_xchg` to swap in new ptr, getting old ptr R1. Mechanism: If R1 is overwritten without `bpf_obj_drop`, ref leak. Verifier tracks this via `acquire_reference`. Impact: Resource exhaustion.", "classification": "resource-exhaustion", "impact": "DoS", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_helper_call"], "proposed_fix_summary": "Enforce release of exchanged kptrs."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0009", "title": "bpf_timer_set_callback UAF", "concept": "Timer callback can be set for a map. If map is freed or reused while timer is pending/running, UAF.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Init timer in map. Set callback. Trigger: Free map / Unload prog. Mechanism: `bpf_timer_cancel_and_free` should handle this. If race condition exists between callback execution and map freeing.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:process_timer_func"], "proposed_fix_summary": "Ensure map holds ref to prog and timer cancels on map free."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0010", "title": "PTR_TO_CTX Variable Offset Access", "concept": "Context access is rewritten. If variable offset is allowed, rewrite might target wrong field.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: R1 = ctx. R1 += variable. Trigger: Load from R1. Mechanism: `check_mem_access` should reject variable offset for `PTR_TO_CTX`. If it allows it under some condition (e.g. 0 var_off but imprecise?), rewrite targets garbage.", "classification": "boundary-bypass", "impact": "info leak", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_mem_access"], "proposed_fix_summary": "Strictly forbid variable offsets on CTX."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0011", "title": "Map-in-Map Inner Map Delete Race", "concept": "Concurrent update of outer map while inner map is being accessed.", "attacker_model": "local_unprivileged", "preconditions": ["BPF_SYSCALL"], "description": "Vulnerability Path: Setup: Map-in-map. Trigger: Prog A uses inner map. Prog B updates outer map (replaces inner map). Mechanism: Inner map refcount must be held during program execution. `map_lookup_elem` returns `PTR_TO_MAP_VALUE` which pins the map?", "classification": "race-condition", "impact": "UAF", "likelihood": "medium", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_map_access"], "proposed_fix_summary": "Ensure inner map refcounting covers duration of BPF program usage."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0012", "title": "check_ids in regsafe with Ref Reuse", "concept": "ID reuse (wrapping 32-bit ID gen) could cause `regsafe` to match unrelated IDs.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Generate 4B IDs. Trigger: `rold` has ID X. `rcur` has ID X (reused). Mechanism: `check_ids` mapping logic assumes unique IDs. Impact: Pruning incorrect state.", "classification": "logic-bypass", "impact": "boundary bypass", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_ids"], "proposed_fix_summary": "Use 64-bit IDs or detect wrap."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0013", "title": "Helper Argument Size 0 Bypass", "concept": "Passing size 0 to helpers expecting `ARG_PTR_TO_MEM` might bypass memory checks but still perform operations.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Call helper with size 0. Trigger: Helper implementation assumes >0. Mechanism: `check_mem_access` for size 0 might succeed trivially. Helper might access -1 or similar.", "classification": "logic-bypass", "impact": "OOB access", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_helper_call"], "proposed_fix_summary": "Enforce minimum size 1 where appropriate."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0014", "title": "adjust_scalar_min_max_vals RSH/LSH bounds", "concept": "Shift operations with large/negative counts or shifts exceeding bit width.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Shift by 64 or -1. Mechanism: `adjust_scalar_min_max_vals` checks `umax_val >= insn_bitness`. Impact: Undefined behavior in hardware/JIT if check is loose.", "classification": "logic-bypass", "impact": "unexpected behavior", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:adjust_scalar_min_max_vals"], "proposed_fix_summary": "Strict shift count checks."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0015", "title": "Packet Pointer comparison with different bases", "concept": "Comparing pointers from different packets (if possible via map storage) or manipulated pointers.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Store packet ptr to map. Read back in another run. Compare. Mechanism: `check_ptr_to_packet_access`. Packet pointers are scoped to program run. Storing to map is forbidden.", "classification": "logic-bypass", "impact": "UAF", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_mem_access"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0016", "title": "bpf_sk_release Double Free via Pruning", "concept": "Pruning might hide a double free if the release state is not part of the pruning key.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Acquire sk. Branch. Release. Merge. Mechanism: `release_reference` clears ID. `regsafe` checks IDs. If `rold` released and `rcur` not, `check_ids` fails. Safe.", "classification": "double-free", "impact": "corruption", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:regsafe"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0017", "title": "Iter destructive read", "concept": "Reading an iterator stack slot might destroy it, but if passed to helper as ARG_PTR_TO_MEM?", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: `bpf_iter_new`. Pass slot to helper. Mechanism: `check_mem_access` should prevent writing to `STACK_ITER`. Read is fine. Impact: None.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_mem_access"], "proposed_fix_summary": "N/A"}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0018", "title": "Uninitialized Stack Read via padding", "concept": "Reading structs from stack that have padding bytes.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Struct with padding. Write fields. Read whole struct to map. Mechanism: `check_stack_read` checks `STACK_MISC` or `STACK_ZERO`. Padding is `STACK_INVALID` if not written. Impact: Info leak (kernel stack).", "classification": "info-leak", "impact": "info leak", "likelihood": "medium", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:check_stack_read"], "proposed_fix_summary": "Force zero-init of padding or reject read."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0019", "title": "Speculative Store Bypass (SSB)", "concept": "Spectre v4. Store to stack, load from stack. CPU speculates load before store.", "attacker_model": "local_unprivileged", "preconditions": ["speculation"], "description": "Vulnerability Path: Setup: Store sensitive data. Store overwrite. Load. Mechanism: `bypass_spec_v4`. If mitigation is disabled or ineffective. Impact: Info leak via side channel.", "classification": "side-channel", "impact": "info leak", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:bypass_spec_v4"], "proposed_fix_summary": "Enforce SSB mitigation."}
{"file": "kernel/bpf/verifier.c", "scenario_id": "kernel/bpf/verifier.c-0020", "title": "regsafe ignoring active_lock changes", "concept": "If lock state changes but `regsafe` ignores it.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Acquire lock. Branch. Release. Merge. Mechanism: `regsafe` checks `active_lock_id`. Impact: If check is missing, broken locking semantics.", "classification": "race-condition", "impact": "deadlock", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["kernel/bpf/verifier.c:regsafe"], "proposed_fix_summary": "N/A"}
