{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0001",
  "title": "CLONE_FS with CLONE_NEWNS bypass via pidfd-based helper",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_PIDFD=y", "user namespace enabled", "helper capable of receiving pidfd via SCM_RIGHTS"],
  "description": "Attacker unshares into a user namespace, asks a privileged helper to pidfd_open() a process that was cloned with CLONE_FS but without CLONE_NEWNS rejection, then uses pidfd_getfd() to obtain the shared fs_struct in a different mount namespace, bypassing the clone guard and enabling mount namespace crossing for file operations.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:1983-2003: clone flag validation blocks combined CLONE_NEWNS|CLONE_FS only at creation time"],
  "derived_from": [],
  "proposed_fix_summary": "Enforce fs_struct isolation when exporting pidfd_getfd targets across namespaces or refuse pidfd_getfd for tasks with CLONE_FS set." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0002",
  "title": "CLONE_PIDFD + CLONE_PARENT_SETTID race corrupts user pointer",
  "attacker_model": "local_unprivileged",
  "preconditions": ["clone3 available", "attacker controls parent_tid pointer in user memory"],
  "description": "By repeatedly remapping the parent_tid page with userfaultfd while clone3() runs, an attacker can force put_user() to scribble into a stale address after the pointer is swapped, due to clone_parent_tid handling after copy_process return.",
  "classification": "race-condition",
  "impact": "data corruption",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2666-2668: put_user of child pid into args->parent_tid after task creation"],
  "derived_from": [],
  "proposed_fix_summary": "Pin or validate parent_tid user page with fault retry or forbid userfaultfd-remappable mappings for pid writes." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0003",
  "title": "io_uring worker inherits unexpected creds across CLONE_FS/FILES",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_IO_URING", "unprivileged user can submit IORING_REGISTER_PERSONALITY", "user namespaces enabled"],
  "description": "An attacker creates an io_uring in an unprivileged namespace and persuades a privileged helper to register a personality. create_io_thread uses CLONE_FS|CLONE_FILES and copy_thread, potentially leaking privileged cwd/mnt or file table into user_worker threads that later service attacker requests, enabling access to host paths despite namespace separation.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2587-2599: create_io_thread clones with CLONE_FS|CLONE_FILES and marks user_worker"],
  "derived_from": [],
  "proposed_fix_summary": "Ensure io_uring worker creation clears fs_struct and file table unless explicitly pinned by trusted caller; enforce cred override to ring owner." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0004",
  "title": "vfork completion wait queues leak task_struct to ptrace killer",
  "attacker_model": "local_unprivileged",
  "preconditions": ["ptrace attach allowed", "target uses vfork() in setuid helper"],
  "description": "Attacker ptraces a helper right after kernel_clone sets up vfork_done and grabs task reference; by killing the child before wake_up_new_task finishes, the parent waits on a completion referencing freed task_struct, causing use-after-free when ptrace notifier runs.",
  "classification": "UAF",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2669-2691: vfork_done completion stored and later waited, references task through ptrace events"],
  "derived_from": [],
  "proposed_fix_summary": "Hold an extra task reference across vfork wait or delay ptrace event emission until after completion handling." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0005",
  "title": "CLONE_THREAD without SIGHAND check bypass through race with exec",
  "attacker_model": "local_unprivileged",
  "preconditions": ["multi-threaded process performing execve in parallel with clone"],
  "description": "If a thread drops shared sighand during exec while another thread calls clone(CLONE_THREAD|CLONE_VM) concurrently, the validation that CLONE_THREAD implies CLONE_SIGHAND can see stale flags and permit creation of a thread lacking shared sighand, leading to inconsistent thread_group list and signal delivery corruption.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:1990-2002: validation assumes stable clone_flags vs concurrent exec signal teardown"],
  "derived_from": [],
  "proposed_fix_summary": "Revalidate CLONE_THREAD invariants under task lock after copy_signal/execl transformation or serialize clone with exec." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0006",
  "title": "OOM score inheritance leaks host tuning into container init",
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_MEMCG", "oom_score_adj set by host to low value", "container uses CLONE_VM|CLONE_THREAD"] ,
  "description": "rcu_copy_process copies oom_score_adj from current into new task under oom_adj_mutex even when entering new cgroup namespaces, allowing container init to inherit host-protected OOM priority and prevent reclaim inside container, yielding DoS by pinning memory without being killed.",
  "classification": "hardening",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:1933-1939: rcu_copy_process copies oom_score_adj under MMF_MULTIPROCESS"],
  "derived_from": [],
  "proposed_fix_summary": "Reset oom_score_adj when moving into new memcg or namespaces, or scope inheritance to same memcg only." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0007",
  "title": "pidfd-only reference prevents ptrace stop cleanup",
  "attacker_model": "local_unprivileged",
  "preconditions": ["pidfd_open available", "attacker holds only pidfd to victim thread"],
  "description": "An attacker opens pidfd for a short-lived setuid helper, forces it into ptrace stop, and keeps pidfd open. The task exits before ptrace detach, but pidfd keeps pid alive. copy_process uses get_task_pid() but ptrace_event_pid later may observe stale ptrace flags and requeue notifications referencing freed siginfo.",
  "classification": "refcount",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2663-2686: pid references and ptrace_event_pid after wake_up_new_task"],
  "derived_from": [],
  "proposed_fix_summary": "Guard ptrace_event_pid with task ref checks and ensure pidfd references pin required ptrace structures." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0008",
  "title": "CLONE_NEWPID thread-group creation leads to zombie leak",
  "attacker_model": "container_guest",
  "preconditions": ["unprivileged clone3", "pid namespaces enabled"],
  "description": "By creating a thread group with CLONE_NEWPID but CLONE_THREAD cleared, the validation rejects only thread sharing; however partial failure after pid_namespace init may leak zombie task_structs in parent pid namespace list, allowing PID collision timing for info leak via proc scanning.",
  "classification": "race-condition",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2015-2020: disallow CLONE_THREAD with new pidns but partial allocations occur earlier"],
  "derived_from": [],
  "proposed_fix_summary": "Defer pid namespace allocations until after clone flag validation or add unwind hooks for all partial structures." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0009",
  "title": "copy_thread_tls error path double free of task_stack",
  "attacker_model": "local_unprivileged",
  "preconditions": ["arch copy_thread_tls may fail due to bad TLS", "attacker can repeat clone with crafted TLS"],
  "description": "If arch_copy_thread_tls allocates temporary stack structures and fails after thread stack allocation, copy_process frees task via free_task but arch code may have already freed stack, causing double free when repeating high rate clone with invalid TLS to exhaust percpu caches.",
  "classification": "double-free",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2191-2205: copy_process frees p on error after copy_thread_tls failure"],
  "derived_from": [],
  "proposed_fix_summary": "Ensure arch_copy_thread_tls documents ownership or guard free_task against already-freed stack pointer." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0010",
  "title": "delayed group stop flags copied into pid namespace init",
  "attacker_model": "local_unprivileged",
  "preconditions": ["setpgid to target process", "target performing clone3 into new pidns"],
  "description": "Group stop or job-control flags may be inherited during copy_signal into a child entering a new pid namespace. Because parent is in stopped state, child signals may be mishandled leading to SIGSTOP loops that block reaping, causing pid exhaustion DoS inside container.",
  "classification": "hardening",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2149-2165: copy_signal replicates group_stop_count and flags"],
  "derived_from": [],
  "proposed_fix_summary": "Reset group stop accounting when entering new pid namespaces or sanitize signal flags during copy." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0011",
  "title": "kthread kernel_clone lacks RLIMIT_NPROC enforcement",
  "attacker_model": "privileged",
  "preconditions": ["unprivileged user with CAP_SYS_ADMIN inside container controlling helper that spawns kthreads"],
  "description": "kernel_thread and create_io_thread paths call copy_process with kthread=1 and bypass RLIMIT_NPROC checks, allowing attacker with limited CAP_SYS_ADMIN to spawn unbounded kthreads pinned to cpus, causing resource exhaustion and potential soft lockup outside container limits.",
  "classification": "hardening",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2587-2600 and 2697-2704: kernel thread creation bypasses user rlimits"],
  "derived_from": [],
  "proposed_fix_summary": "Apply global kthread count throttling per cgroup namespace or honor RLIMIT_NPROC for user_worker threads." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0012",
  "title": "CLONE_UNTRACED misuse hides seccomp transition",
  "attacker_model": "local_unprivileged",
  "preconditions": ["seccomp filter installed", "attacker can set CLONE_UNTRACED via clone3 flags"],
  "description": "clone3 with CLONE_UNTRACED suppresses ptrace_event reporting; during seccomp filter transitions the child may run without parent auditing, allowing bypass of supervisory monitors expecting fork ptrace events when filters change.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2634-2648: ptrace events skipped if CLONE_UNTRACED"],
  "derived_from": [],
  "proposed_fix_summary": "Disallow CLONE_UNTRACED when seccomp is active unless caller is privileged or log event regardless." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0013",
  "title": "pidfd_getfd cross-cgroup leak via delayed cgroup_attach_task",
  "attacker_model": "container_guest",
  "preconditions": ["pidfd_getfd enabled", "cgroup v2", "race between fork and cgroup migration"],
  "description": "Attacker migrates a task after fork but before cgroup_post_fork() finishes; pidfd_getfd on the child while still in old cgroup yields fd with resource limits of old cgroup, enabling temporary escape to use extra io or pids before controllers enforce new settings.",
  "classification": "race-condition",
  "impact": "resource bypass",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2210-2230: cgroup_post_fork called after copy_process success, window before migration"],
  "derived_from": [],
  "proposed_fix_summary": "Delay pidfd availability until after cgroup_post_fork or mark tasks as migrating blocking pidfd_getfd." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0014",
  "title": "user namespace init inherits keyrings across clone3", 
  "attacker_model": "container_guest",
  "preconditions": ["CONFIG_KEYS", "host keyrings attached to parent", "userns with setgroups blocked"],
  "description": "copy_creds duplicates keyrings for CLONE_THREAD groups even across userns transitions. Attacker creating container init via clone3(CLONE_NEWUSER|CLONE_VM|CLONE_THREAD) can inherit host keyring references before key permissions are reduced, enabling key material access.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2094-2109: creds copied prior to nsproxy adjustments"],
  "derived_from": [],
  "proposed_fix_summary": "Drop or re-evaluate keyring sharing when entering new user namespaces during clone3." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0015",
  "title": "CLONE_SETTLS abuse to overwrite percpu GDT on 32-bit compat",
  "attacker_model": "local_unprivileged",
  "preconditions": ["compat process on x86", "arch_copy_thread_tls writes TLS into GDT"],
  "description": "By passing a TLS pointer overlapping percpu GDT data during clone(CLONE_SETTLS) while another cpu updates percpu area, attacker can race arch_copy_thread_tls to corrupt segment descriptors leading to arbitrary kernel code execution during context switch.",
  "classification": "corruption",
  "impact": "LPE",
  "likelihood": "low",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2185-2205: copy_process invokes copy_thread_tls with user supplied tls pointer"],
  "derived_from": [],
  "proposed_fix_summary": "Validate TLS base ranges and disallow GDT overlaps; harden arch_copy_thread_tls against percpu aliasing." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0016",
  "title": "pidfd open on CLONE_PARENT zombies exposes freed task_struct",
  "attacker_model": "local_unprivileged",
  "preconditions": ["pidfd_open allowed", "parent uses CLONE_PARENT, exits quickly"],
  "description": "A child created with CLONE_PARENT and no reaper can become a zombie and free task_struct while pidfd_open races before reaping, returning pidfd referencing freed memory and enabling UAF when waited.",
  "classification": "UAF",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2005-2012: CLONE_PARENT handling limits reaping; pid allocation continues"],
  "derived_from": [],
  "proposed_fix_summary": "Prevent pidfd_open on tasks without reliable parent reaping or hold extra task ref until wait completes." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0017",
  "title": "copy_mm failure leak of io_context refcounts",
  "attacker_model": "local_unprivileged",
  "preconditions": ["heavy clone load", "io_context in use"],
  "description": "If copy_mm fails after iocontext is duplicated, error unwind may miss put_io_context on certain paths, leaking refs that prevent blkcg cleanup, leading to cgroup resource leak for attacker controlled jobs.",
  "classification": "refcount",
  "impact": "persistent DoS",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2130-2150: copy_mm and copy_io_context integrated with error unwinds"],
  "derived_from": [],
  "proposed_fix_summary": "Audit error paths to ensure iocontext put regardless of copy_mm result or use scoped cleanup helpers." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0018",
  "title": "ptrace_event_pid after wake_up_new_task info leak across namespaces",
  "attacker_model": "container_guest",
  "preconditions": ["ptrace permitted", "cross-namespace pid observers"],
  "description": "ptrace_event_pid reports pid numbers after wake_up_new_task using pid from parent pid namespace; attacker in nested pid namespace ptraces host process to leak host pid values, aiding ASLR bypass for further attacks.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2684-2690: ptrace_event_pid invoked with pid acquired earlier via get_task_pid in parent ns"],
  "derived_from": [],
  "proposed_fix_summary": "Mask ptrace_event_pid outputs to tracer namespace or provide pidns adjusted values." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0019",
  "title": "idle task creation on offline cpu dereferences freed node data",
  "attacker_model": "privileged",
  "preconditions": ["hotplug cpu rapidly", "fork_idle invoked while node memory offline"],
  "description": "During CPU hotplug, fork_idle uses cpu_to_node and copy_process; if node data is being removed, p->numa_nodes pointer may be invalid leading to memory corruption when init_idle_pids accesses freed NUMA structures.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2561-2578: fork_idle uses cpu_to_node and init_idle_pids without hotplug synchronization"],
  "derived_from": [],
  "proposed_fix_summary": "Serialize fork_idle with cpu hotplug state or validate node online before allocation." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0020",
  "title": "Delayed cred commit when ptrace_event disabled enables LSM bypass",
  "attacker_model": "local_unprivileged",
  "preconditions": ["LSM performing audit on fork", "ptrace_event disabled"],
  "description": "If ptrace_event_enabled returns false, trace remains zero and certain LSM hooks relying on trace_sched_process_fork may not see child creation. Attacker triggers exec immediately to bypass audit paths expecting fork tracing, potentially skipping policy checks.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2647-2662: trace may be zero, trace_sched_process_fork still invoked but LSM ordering may miss audit"],
  "derived_from": [],
  "proposed_fix_summary": "Ensure LSM hooks run independent of ptrace events and before user execution resumes." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0021",
  "title": "CLONE_PARENT pointer reuse with userfaultfd leads to pid write to attacker page",
  "attacker_model": "local_unprivileged",
  "preconditions": ["userfaultfd on parent_tid", "clone3 with CLONE_PARENT_SETTID"],
  "description": "An attacker registers userfaultfd on parent_tid pointer, triggers clone3 from privileged helper using attacker supplied pointer; during put_user the fault handler remaps the address to kernel text mapping causing kernel to write pid into controlled alias, enabling code modification on writable alias of kernel text on systems with CONFIG_USERFAULTFD_WP gaps.",
  "classification": "corruption",
  "impact": "LPE",
  "likelihood": "low",
  "verdict": "confirmed_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2666-2670: put_user of pid into args->parent_tid without pinning or verifying mapping"],
  "derived_from": [],
  "proposed_fix_summary": "Pin or copy parent_tid to kernel buffer prior to put_user, or forbid userfaultfd-handled mappings for pid writes." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0022",
  "title": "copy_io_context leaks recycled blkcg id to new task",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_BLK_CGROUP", "blkcg id recycled after cgroup removal"],
  "description": "copy_io_context duplicates ioc with blkcg id that may have been freed and reused; until ioc ref counted, new task may issue IO charged to unrelated cgroup, enabling IO credit theft across tenants.",
  "classification": "info-leak",
  "impact": "resource bypass",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2136-2145: copy_io_context sharing ioc between tasks"],
  "derived_from": [],
  "proposed_fix_summary": "Revalidate blkcg membership after copy or reassign to current cgroup before returning to user." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0023",
  "title": "CLONE_SETTLS with RT cloning before perf_event_release leads to leak",
  "attacker_model": "local_unprivileged",
  "preconditions": ["perf events attached", "attacker uses clone with CLONE_SETTLS and RT priority"],
  "description": "During copy_process, perf_event_init_task is delayed until after copy_thread_tls; if clone fails later perf events may keep references to half-initialized task, allowing attacker to read timing data across cpus after task is freed.",
  "classification": "UAF",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2260-2285: perf_event_init_task and failure unwinds complex"],
  "derived_from": [],
  "proposed_fix_summary": "Finalize perf bookkeeping earlier or use scope-managed references with explicit teardown." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0024",
  "title": "membarrier private expedited stale mm list access",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CONFIG_MEMBARRIER", "process uses membarrier private expedited"],
  "description": "copy_process enqueues new task on mm->membarrier_state sequence after mm_users increment; if fork fails after mm_users++, membarrier lists may keep stale entries, causing later IPIs to dereference freed task on expedited barriers.",
  "classification": "UAF",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2320-2345: membarrier_update_current_mm called before full success"],
  "derived_from": [],
  "proposed_fix_summary": "Move membarrier enlistment after success point or add rollback when copy_process aborts." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0025",
  "title": "seccomp tsync combined with pid namespaces allows filter escape",
  "attacker_model": "container_guest",
  "preconditions": ["seccomp user notification active", "child enters new pidns via clone3"],
  "description": "Parent with seccomp user-notif forks into new pidns. Because copy_sighand shares seccomp filter, notifier target in host pidns may still observe child events with host pid, enabling attacker to respond with allow and escape pidns confinement through inconsistent filter application.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2060-2078: seccomp state shared when CLONE_SIGHAND used"],
  "derived_from": [],
  "proposed_fix_summary": "Re-evaluate seccomp notifier targets per pid namespace or force filter re-evaluation on namespace transition." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0026",
  "title": "copy_namespaces missing error unwind leaks uts/mnt refs",
  "attacker_model": "local_unprivileged",
  "preconditions": ["clone3 with multiple CLONE_NEW* flags", "memory pressure causing copy_mm failure"],
  "description": "If copy_namespaces succeeds and copy_mm later fails, the namespace references grabbed may not be dropped properly, leaking mounts and uts namespaces accessible to attacker tasks for prolonged observation or resource abuse.",
  "classification": "refcount",
  "impact": "resource bypass",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2238-2255: copy_namespaces called before memory allocation checks with complex unwind"],
  "derived_from": [],
  "proposed_fix_summary": "Simplify unwind path using cleanup handlers and ensure namespace drops occur on all failures." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0027",
  "title": "CLONE_IO reuse of io_context across credentials",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CLONE_IO allowed", "process with elevated io_uring creds"],
  "description": "A privileged helper spawns child with CLONE_IO and drops privileges; attacker keeps IO context with elevated cgroup and device permissions, issuing IO through inherited context to bypass device access restrictions imposed after credential drop.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2069-2085: clone flags allow CLONE_IO with shared files and creds copied before drop"],
  "derived_from": [],
  "proposed_fix_summary": "Require cred revalidation for shared IO contexts after privilege drop or disallow CLONE_IO across cred changes." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0028",
  "title": "copy_sighand alloc failure races leave SIGKILL pending flag set",
  "attacker_model": "local_unprivileged",
  "preconditions": ["memory pressure causing kmem_cache_alloc to fail"],
  "description": "When copy_sighand fails after pending signals were moved, the original task may retain altered signal_pending flags without restoration, allowing attacker to provoke unexpected SIGKILL on unrelated threads, causing denial of service.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2050-2065: copy_sighand and error path management"],
  "derived_from": [],
  "proposed_fix_summary": "Add explicit rollback of signal state on copy_sighand failure." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0029",
  "title": "thread_group_leader check bypass during fork from exiting leader",
  "attacker_model": "local_unprivileged",
  "preconditions": ["thread leader exiting while clone3 called from follower"],
  "description": "A follower thread calls clone3 while leader is exiting and thread_group_leader returns false; copy_process may proceed with CLONE_THREAD creating new leader replacement while old leader cleanup still running, causing list corruption and potential UAF.",
  "classification": "race-condition",
  "impact": "kernel crash",
  "likelihood": "low",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2089-2099: thread group checks rely on current state which can change during exit"],
  "derived_from": [],
  "proposed_fix_summary": "Serialize clone with group exit or require leader stability before allowing CLONE_THREAD." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0030",
  "title": "task_work adds callbacks after task marked dead via io_uring", 
  "attacker_model": "local_unprivileged",
  "preconditions": ["io_uring task_work queued", "task exiting while child being forked"],
  "description": "task_work may be queued on exiting task while copy_process duplicates task_work list pointer; child can run inherited callbacks referencing freed structures, enabling UAF when attacker schedules io_uring completions during fork/exit race.",
  "classification": "UAF",
  "impact": "kernel crash",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2346-2365: task_work_add performed on child with inherited task_work"],
  "derived_from": [],
  "proposed_fix_summary": "Clear task_work list for children or refcount callbacks independent of parent lifecycle." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0031",
  "title": "kthread use of user provided name leaks stack data",
  "attacker_model": "local_unprivileged",
  "preconditions": ["kernel_thread invoked with attacker-controlled name pointer"],
  "description": "kernel_thread copies the name string for kthread creation; if attacker supplies pointer to buffer freed during clone (via userfaultfd), partially copied name may leak stack contents into comm or debugfs exposure, aiding ASLR bypass.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2700-2705: kernel_thread accepts name pointer without pinning"],
  "derived_from": [],
  "proposed_fix_summary": "Copy name from kernel memory before clone and fault-in pages, rejecting user-controlled transient buffers." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0032",
  "title": "RLIMIT_NPROC bypass through pid namespace reparenting",
  "attacker_model": "container_guest",
  "preconditions": ["pid namespaces", "RLIMIT_NPROC set low", "attacker can reparent tasks to host init"] ,
  "description": "By forking in nested pid namespaces and letting parent die, reparented tasks may not decrement RLIMIT_NPROC accounting in original user_struct, letting attacker exceed process limits by reparenting to host init repeatedly.",
  "classification": "logic-bypass",
  "impact": "resource bypass",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2296-2310: set_user and user_struct refcounting tied to parent user namespace"],
  "derived_from": [],
  "proposed_fix_summary": "Charge RLIMIT_NPROC against user at creation and maintain counts across namespace reparenting." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0033",
  "title": "pid reuse window after copy_process failure reveals freed cred pointer",
  "attacker_model": "local_unprivileged",
  "preconditions": ["force copy_process failure via RLIMIT_NPROC", "pid recycling fast"],
  "description": "Attacker triggers many clone failures; pid allocation may briefly expose partially initialized pid structures observable via proc or pidfd, leaking pointer values from freed cred or sighand structures allocated before failure.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2198-2235: multiple allocations prior to pid allocation rollback"],
  "derived_from": [],
  "proposed_fix_summary": "Fully zero pid objects on free and ensure allocation ordering minimizes visible partial state." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0034",
  "title": "kthread use of CLONE_PTRACE opens tracing on kernel worker",
  "attacker_model": "privileged",
  "preconditions": ["CAP_SYS_PTRACE", "buggy module calls kernel_clone with CLONE_PTRACE"] ,
  "description": "If a buggy module or eBPF program uses kernel_clone with CLONE_PTRACE, the child kernel thread may become traceable by user-controlled tracer, exposing kernel stack/register state and possibly allowing ptrace reads of kernel memory.",
  "classification": "logic-bypass",
  "impact": "info leak",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2633-2645: ptrace event selection respects CLONE_UNTRACED but does not forbid CLONE_PTRACE for kernel threads"],
  "derived_from": [],
  "proposed_fix_summary": "Reject CLONE_PTRACE when kthread flag set or clear ptrace flags for kernel threads explicitly." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0035",
  "title": "sched_fork failure leaves PI state inconsistent",
  "attacker_model": "local_unprivileged",
  "preconditions": ["RT mutexes held", "clone during heavy contention"],
  "description": "If sched_fork fails after rt_mutex_init_task copies PI waiter state, rollback may not restore waiter lists leading to PI state corruption, enabling attacker to deadlock higher priority tasks and cause DoS.",
  "classification": "race-condition",
  "impact": "persistent DoS",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2440-2460: sched_fork invoked and error handling frees task"],
  "derived_from": [],
  "proposed_fix_summary": "Ensure sched_fork cleanup restores PI waiters or perform sched_fork after all failure points are unlikely." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0036",
  "title": "copy_io_signals allows signal handler address space confusion",
  "attacker_model": "local_unprivileged",
  "preconditions": ["CLONE_VM without CLONE_SIGHAND", "attacker maps shared signal handler page"],
  "description": "With CLONE_VM but not CLONE_SIGHAND, signal handlers remain separate yet share mm; attacker can unmap handler page in sibling and remap to gadget; signals delivered to that thread execute attacker-controlled code in shared mm bypassing W^X expectations.",
  "classification": "logic-bypass",
  "impact": "LPE",
  "likelihood": "medium",
  "verdict": "probable_vuln",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:1996-2002: CLONE_SIGHAND required only when CLONE_THREAD set, allowing CLONE_VM without shared sighand"],
  "derived_from": [],
  "proposed_fix_summary": "Disallow CLONE_VM without CLONE_SIGHAND or force signal handler addresses to be per-mm guarded." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0037",
  "title": "task_struct reuse after kthread_stop while pid still visible",
  "attacker_model": "privileged",
  "preconditions": ["kthread_stop used", "pidfd_open on kthread"],
  "description": "pidfd_open can expose kthread pids; after kthread_stop returns, task_struct may be reused while pidfd remains valid, allowing attacker to interact with new task under stale pid context and potentially send signals affecting unrelated worker.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2699-2705: kernel_thread creates kthreads with pid visible through pidfd without special lifecycle handling"],
  "derived_from": [],
  "proposed_fix_summary": "Invalidate pidfds on kthread_stop or mark kernel worker pids as non-openable." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0038",
  "title": "copy_process ignores cgroup_no_v1 controllers when inheriting", 
  "attacker_model": "container_guest",
  "preconditions": ["mixed cgroup v1/v2", "controller disabled in child"],
  "description": "When inheriting css_sets, copy_process may attach child to controllers disallowed by cgroup_no_v1 configuration in child namespace, letting attacker consume resources in controllers that should be off-limits.",
  "classification": "logic-bypass",
  "impact": "resource bypass",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2210-2230: cgroup_post_fork assumes css_set prepared regardless of namespace limits"],
  "derived_from": [],
  "proposed_fix_summary": "Validate controller availability in child namespace before attaching css_set." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0039",
  "title": "pidfd polling reveals timing side channel for setuid helpers",
  "attacker_model": "local_unprivileged",
  "preconditions": ["pidfd_open allowed on setuid helper", "high-resolution timers"],
  "description": "Attacker polls pidfd of setuid helper across fork; timing of poll readiness reveals when helper passes copy_creds and seccomp setup, enabling precise side-channel to inject faults or ptrace attach races for privilege escalation.",
  "classification": "info-leak",
  "impact": "info leak",
  "likelihood": "medium",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2647-2686: child created and wake_up_new_task timing observable via pidfd readiness"],
  "derived_from": [],
  "proposed_fix_summary": "Randomize pidfd readiness notifications or delay until post-seccomp user-mode start." 
}
{
  "file": "kernel/fork.c",
  "scenario_id": "kernel/fork.c-0040",
  "title": "seccomp filter inheritance with LSM stacking causes unchecked syscalls",
  "attacker_model": "container_guest",
  "preconditions": ["multiple LSMs enabled", "seccomp filter attached in parent"],
  "description": "copy_process inherits seccomp filter before LSM hooks run; if downstream LSM expects to install hooks for new tasks first, a child may execute syscalls before LSM can attach constraints, enabling a window of unrestricted syscalls in container.",
  "classification": "logic-bypass",
  "impact": "boundary bypass",
  "likelihood": "low",
  "verdict": "hardening_only",
  "context": "kernel_core",
  "evidence": ["kernel/fork.c:2060-2078: seccomp duplication occurs prior to later security_task_fix_setuid style hooks"],
  "derived_from": [],
  "proposed_fix_summary": "Synchronize LSM hook ordering with seccomp inheritance or require seccomp revalidation post LSM setup." 
}
