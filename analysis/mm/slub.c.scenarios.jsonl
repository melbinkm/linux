{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0001", "title": "Barn Overflow via Concurrent Sheaf Return", "concept": "The `node_barn` limits sheaves to `MAX_FULL_SHEAVES`. The check `barn->nr_full >= MAX_FULL_SHEAVES` is performed outside the lock. Concurrent threads can race past this check, acquire the lock, and increment `nr_full` beyond the limit.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_SLUB", "CONFIG_SMP"], "description": "Vulnerability Path: Setup: Many CPUs/threads. Trigger: Massively return full sheaves to the barn (e.g. via migration or explicit flush). Mechanism: `barn_put_full_sheaf` checks `nr_full` locklessly. If N threads see `nr_full=9` and `MAX=10`, all proceed. They serialize on lock, incrementing `nr_full` to 9+N. Impact: Unbounded growth of barn, memory exhaustion DoS.", "classification": "race-condition", "impact": "persistent DoS", "likelihood": "medium", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["mm/slub.c:barn_put_full_sheaf"], "proposed_fix_summary": "Recheck `nr_full` inside the lock in `barn_put_full_sheaf`."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0002", "title": "Integer Overflow in calculate_sizes", "concept": "Calculation of slab object size `size` involves adding headers/footers and alignment. If `s->object_size` is near `UINT_MAX`, these additions can overflow `unsigned int size`, resulting in a small `s->size` but large `s->object_size`.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_SLUB_DEBUG", "CAP_SYS_ADMIN or specific subsystem access"], "description": "Vulnerability Path: Setup: Create cache with size near UINT_MAX. Trigger: `kmem_cache_create`. Mechanism: `calculate_sizes` adds padding. `size` wraps. Cache created with small slab size. Allocation succeeds. User writes `s->object_size` bytes. Heap corruption. Impact: Heap overflow.", "classification": "integer-overflow", "impact": "kernel crash", "likelihood": "low", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["mm/slub.c:calculate_sizes"], "proposed_fix_summary": "Check for overflow in `calculate_sizes` or enforce max object size limit earlier."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0003", "title": "UAF in sysfs_slab_alias vs kmem_cache_destroy", "concept": "Race between `kmem_cache_destroy` and `sysfs_slab_alias` (or other sysfs ops) accessing the cache pointer.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_SYSFS"], "description": "Vulnerability Path: Setup: Cache A exists. Trigger: Thread 1 calls `sysfs_slab_alias(A, ...)`. Thread 2 calls `kmem_cache_destroy(A)`. Mechanism: `sysfs_slab_alias` might dereference `s` after it is freed by Thread 2. `slab_mutex` usually protects this, but check alias creation path logic.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:sysfs_slab_alias"], "proposed_fix_summary": "Ensure locking covers full lifetime."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0004", "title": "Double Free in kfree_nolock", "concept": "`kfree_nolock` is a lockless version of kfree. If called concurrently on same object, it might corrupt freelist if `cmpxchg` logic doesn't catch it (ABA problem or similar).", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Obj X. Trigger: Thread 1 `kfree_nolock(X)`. Thread 2 `kfree_nolock(X)`. Mechanism: `do_slab_free` uses `cmpxchg`. If `tid` matches, both might succeed if one is fast enough? No, `tid` protects. But if `slab_free_hook` is called twice? KASAN might catch it. If KASAN disabled? Metadata corruption.", "classification": "double-free", "impact": "corruption", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:kfree_nolock"], "proposed_fix_summary": "Ensure `kfree_nolock` is not used concurrently on same object (caller responsibility)."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0005", "title": "Sheaf Flush Race with CPU Hotplug", "concept": "Flushing sheaves during CPU hotplug might race with ongoing allocations if migration is not properly disabled or if remote flushing logic is flawed.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_HOTPLUG_CPU"], "description": "Vulnerability Path: Setup: CPU offline. Trigger: `slub_cpu_dead`. Mechanism: `__pcs_flush_all_cpu` flushes sheaves. If any other thread has a reference to `pcs` (unlikely as it is per-cpu), use after free or corruption.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["mm/slub.c:slub_cpu_dead"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0006", "title": "Infinite Loop in slab_alloc_node (retry logic)", "concept": "Allocation fastpath retries on failure. If a condition persistently causes failure but `___slab_alloc` keeps retrying fastpath, infinite loop.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Fragmented memory. Trigger: Alloc. Mechanism: `slab_alloc_node` calls `__slab_alloc_node` which loops on `cmpxchg`. If interrupt storm or contention prevents success indefinitely. DoS.", "classification": "DoS", "impact": "core hang", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:slab_alloc_node"], "proposed_fix_summary": "Limit retries."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0007", "title": "freelist_ptr_decode Hardening Bypass", "concept": "Freelist pointer obfuscation uses `ptr ^ s->random ^ ptr_addr`. If attacker knows `ptr_addr` and `ptr` (via leak), they can derive `s->random`.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_SLAB_FREELIST_HARDENED"], "description": "Vulnerability Path: Setup: Info leak of heap content (freelist ptr). Trigger: Calculate random cookie. Mechanism: XOR algebra. Impact: Bypass hardening, enable freelist corruption attacks.", "classification": "crypto-weakness", "impact": "mitigation bypass", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:freelist_ptr_decode"], "proposed_fix_summary": "Re-key random frequently or use stronger obfuscation."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0008", "title": "Memory Leak in alloc_slab_obj_exts failure", "concept": "If `alloc_slab_obj_exts` fails, `slab->obj_exts` might be left in inconsistent state or leak memory if partial allocation happened.", "attacker_model": "local_unprivileged", "preconditions": ["CONFIG_SLAB_OBJ_EXT"], "description": "Vulnerability Path: Setup: Fail allocation. Mechanism: `alloc_slab_obj_exts`. Check error path.", "classification": "memory-leak", "impact": "resource exhaustion", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:alloc_slab_obj_exts"], "proposed_fix_summary": "Audit error path."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0009", "title": "get_any_partial Nodelist Iteration Race", "concept": "Iterating `node_zonelist` while zones are changing (hotplug) without lock.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_NUMA"], "description": "Vulnerability Path: Setup: Memory hotplug. Trigger: `get_any_partial`. Mechanism: Access `zonelist`.", "classification": "race-condition", "impact": "crash", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:get_any_partial"], "proposed_fix_summary": "Use proper sequencing/locking for zonelist access."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0010", "title": "slab_out_of_memory Log Flooding", "concept": "OOM reporting prints extensive details. If triggered rapidly, can flood logs/console.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Trigger OOM. Mechanism: `slab_out_of_memory` uses `pr_warn`. Ratelimit exists but might be bypassable or high limit.", "classification": "DoS", "impact": "log flooding", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:slab_out_of_memory"], "proposed_fix_summary": "Tune ratelimit."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0011", "title": "kmem_cache_destroy vs Object Use", "concept": "Destroying cache while objects still in use. SLUB checks `slab->inuse`, but race might exist.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Use object. Destroy cache. Mechanism: `shutdown_cache` checks partial/full lists. If object is on per-cpu freelist? `flush_all` is called. Race window?", "classification": "UAF", "impact": "corruption", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["mm/slub.c:kmem_cache_destroy"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0012", "title": "validate_slab_cache long runtime", "concept": "Validating large cache iterates all objects. Can cause CPU stall.", "attacker_model": "local_privileged", "preconditions": ["CONFIG_SLUB_DEBUG"], "description": "Vulnerability Path: Setup: Huge cache. Trigger: `validate_slab_cache` via sysfs. Mechanism: Loop over all nodes, slabs, objects. No cond_resched? Impact: Soft lockup.", "classification": "DoS", "impact": "stall", "likelihood": "medium", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:validate_slab_cache"], "proposed_fix_summary": "Add cond_resched."}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0013", "title": "sysfs store buffer overflow", "concept": "Sysfs store handlers copying data.", "attacker_model": "local_privileged", "preconditions": [], "description": "Vulnerability Path: Setup: Write to sysfs. Mechanism: `slab_attr_store`. Check bounds. `kstrtoul` is safe. Unlikely.", "classification": "buffer-overflow", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["mm/slub.c:slab_attr_store"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0014", "title": "alloc_from_pcs_bulk corruption", "concept": "Bulk alloc from sheaves. If `size` calculation or pointer arithmetic is wrong.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Bulk alloc. Mechanism: `alloc_from_pcs_bulk` uses `memcpy`. Check bounds. `batch = min(size, main->size)`. Safe.", "classification": "logic-bypass", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["mm/slub.c:alloc_from_pcs_bulk"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0015", "title": "kmem_cache_prefill_sheaf oversize", "concept": "Prefilling sheaf larger than capacity.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Request huge size. Mechanism: `kmem_cache_prefill_sheaf` allocates new struct. `__kmem_cache_alloc_bulk` fills it. Return it. When returned, `kmem_cache_return_sheaf` sees `sheaf->capacity != s->sheaf_capacity` and frees it. Safe logic.", "classification": "resource-exhaustion", "impact": "none", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["mm/slub.c:kmem_cache_prefill_sheaf"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0016", "title": "kfree_rcu_sheaf race with cache destruction", "concept": "RCU callback executing after cache is destroyed.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: kfree_rcu. Cache destroy. Mechanism: `kmem_cache_shutdown` calls `rcu_barrier()`. This waits for callbacks. Safe.", "classification": "race-condition", "impact": "UAF", "likelihood": "low", "verdict": "not_feasible", "context": "kernel_core", "evidence": ["mm/slub.c:kmem_cache_shutdown"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0017", "title": "kmalloc_large_node order calculation", "concept": "Integer overflow in `get_order` or size calc for large allocs.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: `kmalloc` huge size. Mechanism: `kmalloc_large_node`. `get_order(size)`. If size is huge, order might be invalid? `kmalloc` limits size via `KMALLOC_MAX_CACHE_SIZE` usually, or page allocator handles it.", "classification": "integer-overflow", "impact": "none", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:___kmalloc_large_node"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0018", "title": "free_large_kmalloc double free", "concept": "Double free of large kmalloc object.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Free twice. Mechanism: `free_large_kmalloc` checks `PageLargeKmalloc`. Clears it. Second free sees `!PageLargeKmalloc` and warns. Safe.", "classification": "double-free", "impact": "warning", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:free_large_kmalloc"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0019", "title": "prefetch_freepointer OOB", "concept": "Prefetching next object pointer might access unmapped memory if random garbage is in freelist.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Corrupt freelist (UAF write). Trigger: Alloc. Mechanism: `prefetch_freepointer` dereferences garbage. Impact: Crash (minor) or side channel?", "classification": "memory-corruption", "impact": "crash", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:prefetch_freepointer"], "proposed_fix_summary": "N/A"}
{"file": "mm/slub.c", "scenario_id": "mm/slub.c-0020", "title": "slab_lock bit spinlock starvation", "concept": "Bit spinlock on `slab->flags` can starve if held long.", "attacker_model": "local_unprivileged", "preconditions": [], "description": "Vulnerability Path: Setup: Heavy contention on single slab. Mechanism: `slab_lock` uses `bit_spin_lock`. No fairness. Impact: CPU hang / starvation.", "classification": "DoS", "impact": "stall", "likelihood": "low", "verdict": "hardening_only", "context": "kernel_core", "evidence": ["mm/slub.c:slab_lock"], "proposed_fix_summary": "Use queued spinlocks if possible or limit hold time."}
