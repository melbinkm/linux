{ "file": "net/ipv4/ip_output.c", "scenario_id": "net/ipv4/ip_output.c-0001", "title": "VLAN Tag Leak via IP Fragmentation Metadata Loss", "concept": "State Management: `ip_copy_metadata` fails to copy `vlan_tci` and `vlan_proto` from the original SKB to fragments, causing fragments to be sent untagged if the output device is not VLAN-aware (e.g., native interface in passthrough mode).", "attacker_model": "local_unprivileged | container_guest", "preconditions": ["Output interface MTU < Packet Size (Fragmentation required)", "Packet has hardware VLAN tag (vlan_tci set)", "Output device does not automatically re-tag based on destination (e.g. bridging or passthrough)"], "description": "Vulnerability Path: Setup: User sends a large VLAN-tagged packet (e.g., via AF_PACKET, or routed from a VLAN interface) that requires fragmentation. Trigger: `ip_output` calls `ip_finish_output` -> `ip_fragment` -> `ip_do_fragment`. Mechanism: `ip_do_fragment` calls `ip_frag_next` to create fragments. `ip_frag_next` allocates a new skb (`alloc_skb` zeros metadata) and calls `ip_copy_metadata` to copy properties. `ip_copy_metadata` copies fields like `priority`, `mark`, `dev`, but misses `vlan_tci` and `vlan_proto`. Result: The fragments are created without the VLAN tag. When `ip_finish_output2` sends them to the device driver, if the driver/device relies on `vlan_tci` to insert the tag, the fragments go out untagged (Native VLAN). Impact: Traffic leaks from the intended VLAN to the native VLAN, bypassing network isolation.", "classification": "info-leak", "impact": "boundary bypass", "likelihood": "medium", "verdict": "confirmed_vuln", "context": "kernel_core", "evidence": ["net/ipv4/ip_output.c:488: static void ip_copy_metadata(struct sk_buff *to, struct sk_buff *from)", "net/ipv4/ip_output.c:699: ip_copy_metadata(skb2, skb);"], "derived_from": [], "proposed_fix_summary": "Update `ip_copy_metadata` to copy `vlan_tci`, `vlan_proto`, and `vlan_present` using `__vlan_hwaccel_copy_tag` or similar helper." }
{ "file": "net/ipv4/ip_output.c", "scenario_id": "net/ipv4/ip_output.c-0002", "title": "Integer Underflow in ip_do_fragment via frag_max_size", "concept": "Input Validation: `ip_do_fragment` uses `IPCB(skb)->frag_max_size` to limit fragment size but fails to ensure it is larger than the IP header length, leading to integer underflow.", "attacker_model": "local_unprivileged | remote", "preconditions": ["Ability to set `IPCB(skb)->frag_max_size` to a small value (< 20) via tunnel encapsulation or LWT BPF"], "description": "Vulnerability Path: Setup: A packet enters `ip_do_fragment` with `IPCB(skb)->frag_max_size` set to a small value (e.g., 8). Trigger: `ip_do_fragment` executes. Mechanism: The code calculates `mtu` based on `frag_max_size`: `if (frag_max_size < mtu) mtu = frag_max_size;`. Then `hlen = iph->ihl * 4` (e.g., 20). Then `mtu = mtu - hlen`. If `mtu` was 8, `mtu - 20` underflows to a huge positive integer. `ip_frag_init` is called with this huge MTU. `ip_frag_next` sees `len < state->mtu` and creates a single fragment containing the entire payload. Impact: The packet is not fragmented correctly and might exceed the real physical MTU, potentially crashing downstream parsers or drivers that expect strictly fragmented packets when `frag_max_size` is enforced.", "classification": "logic-bypass", "impact": "DoS", "likelihood": "low", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["net/ipv4/ip_output.c:780: if (IPCB(skb)->frag_max_size && IPCB(skb)->frag_max_size < mtu) mtu = IPCB(skb)->frag_max_size;", "net/ipv4/ip_output.c:787: mtu = mtu - hlen;"], "derived_from": [], "proposed_fix_summary": "Ensure `mtu` (derived from `frag_max_size`) is at least `hlen + 8` before subtraction." }
{ "file": "net/ipv4/ip_output.c", "scenario_id": "net/ipv4/ip_output.c-0003", "title": "TSO/GSO Amplification Denial of Service", "concept": "Resource Abuse: Malicious TSO packets from a guest can force the host to perform expensive software segmentation and fragmentation, consuming disproportionate CPU resources.", "attacker_model": "container_guest", "preconditions": ["Virtio networking with TSO enabled", "Route to destination with low MTU (e.g. IPIP tunnel)"], "description": "Vulnerability Path: Setup: Guest sends maximum sized TSO packets (64KB). Host routes these packets to an interface with small MTU (e.g. 1280 bytes). Trigger: `ip_finish_output` sees GSO packet larger than destination MTU. Mechanism: `ip_finish_output_gso` is called. It calls `skb_gso_segment` to split TSO packet into MSS-sized segments (software segmentation). If MSS > MTU, it then iterates over segments and calls `ip_fragment` for each one. `ip_fragment` fragments each segment further. 1 TSO packet (1 VM exit) results in ~45 segments, each potentially fragmented into 2 packets -> ~90 packets processed by host IP stack and driver. Impact: Significant CPU consumption on the host (amplification factor ~90x), leading to Denial of Service for other tenants.", "classification": "resource-exhaustion", "impact": "persistent DoS", "likelihood": "high", "verdict": "hardening_only", "context": "driver", "evidence": ["net/ipv4/ip_output.c:320: segs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);", "net/ipv4/ip_output.c:328: skb_list_walk_safe(segs, segs, nskb) { ... ip_fragment(...) }"], "derived_from": [], "proposed_fix_summary": "Validate GSO MSS against egress MTU earlier or strictly limit software segmentation overhead." }
{ "file": "net/ipv4/ip_output.c", "scenario_id": "net/ipv4/ip_output.c-0004", "title": "Queue Mapping Loss in IP Fragmentation", "concept": "Subsystem Impedance Mismatch: `ip_copy_metadata` fails to copy `queue_mapping` from the original SKB to fragments.", "attacker_model": "local_unprivileged", "preconditions": ["Multi-queue NIC", "Fragmentation required"], "description": "Vulnerability Path: Setup: Packet is assigned to a specific TX queue (e.g. via XPS or socket option). Trigger: Packet is fragmented in `ip_output`. Mechanism: `ip_copy_metadata` does not copy `skb->queue_mapping`. Fragments have `queue_mapping = 0`. Result: Fragments are sent via TX queue 0 instead of the intended queue. Impact: Packet reordering (if some packets are not fragmented and go to queue N), performance degradation (lock contention on queue 0), and bypass of QoS policies tied to queues.", "classification": "logic-bypass", "impact": "data corruption", "likelihood": "medium", "verdict": "probable_vuln", "context": "kernel_core", "evidence": ["net/ipv4/ip_output.c:488: static void ip_copy_metadata(...)"], "derived_from": [], "proposed_fix_summary": "Copy `skb->queue_mapping` in `ip_copy_metadata`." }
