{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0001","title":"Raw socket hash table DoS via unbounded skb_clone","attacker_model":"remote","preconditions":["Target enables raw sockets bound to protocol","Attacker can send high-rate packets"],"description":"raw_v4_input() clones every matching skb for each raw socket without per-destination rate limiting. A remote peer can flood packets to a host with multiple raw listeners to exhaust skb memory and CPU via repeated skb_clone() and sock_queue_rcv_skb work.","classification":"resource-exhaustion","impact":"Kernel memory exhaustion and packet processing DoS","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:163-198","net/ipv4/raw.c:189-194"],"derived_from":[],"proposed_fix_summary":"Apply per-socket/namespace receive limits or drop early when rmem is full before cloning."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0002","title":"ICMP filter ignores types >=32 allowing control plane reflection","attacker_model":"remote","preconditions":["Victim raw socket sets filter","Attacker sends uncommon ICMP types"],"description":"icmp_filter() only checks hdr->type < 32. ICMP types above 31 bypass the bitmap and are always delivered. An attacker can craft oversized ICMP extensions (e.g., experimental types) to reach privileged raw listeners despite filter settings, enabling reflection or unexpected parser bugs.","classification":"filter-bypass","impact":"Unexpected packet delivery to privileged raw consumers","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:137-155"],"derived_from":[],"proposed_fix_summary":"Allow filters to block all types by default and extend bitmap or add drop-all option."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0003","title":"Lack of per-sdif check allows loopback spoof with VRF","attacker_model":"container_guest","preconditions":["Multiple VRFs or devices share raw protocol","Attacker can set IP_PKTINFO"],"description":"raw_v4_match() uses raw_sk_bound_dev_eq() with dif/sdif but raw_v4_input() computes sdif via inet_sdif(), which may return 0 on loopback. In VRF setups an attacker sending loopback packets can reach sockets bound to other VRFs because sdif comparison is skipped, allowing cross-VRF sniffing or injection.","classification":"logic-bypass","impact":"Network namespace isolation bypass for raw traffic","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:119-130","net/ipv4/raw.c:163-198"],"derived_from":[],"proposed_fix_summary":"Honor loopback l3mdev indexes when computing sdif and enforce VRF match strictly."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0004","title":"raw_err ignores connected state when recverr disabled","attacker_model":"remote","preconditions":["Socket not connected","IP_RECVERR disabled"],"description":"raw_err() only reports errors when RECVERR is set or sk_state==TCP_ESTABLISHED. For unconnected sockets with recverr off, ICMP errors are silently dropped, enabling blind spoofing attacks (e.g., path MTU blackhole) because applications never see EMSGSIZE or redirects.","classification":"error-handling","impact":"Traffic blackhole and policy bypass","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:208-270"],"derived_from":[],"proposed_fix_summary":"Provide optional notifications for ICMP errors even on unconnected sockets or rate-limit but surface important ones like PMTU."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0005","title":"raw_hash_sk uses global lock causing CAP_NET_RAW starvation","attacker_model":"local_unprivileged","preconditions":["Attacker holds CAP_NET_RAW","Frequent bind/unbind of raw sockets"],"description":"raw_hash_sk() and raw_unhash_sk() hold a global spinlock for the hash bucket. A local attacker can churn socket creation to hold the lock and delay other operations in softirq contexts handling packets, causing latency spikes and potential RCU stalls.","classification":"DoS","impact":"Packet processing latency and softirq backlog","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:91-118"],"derived_from":[],"proposed_fix_summary":"Use finer-grained locking or percpu lists for raw sockets to reduce contention from untrusted creators."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0006","title":"sock_rcvbuf exceeded path counts drops but keeps cloning","attacker_model":"remote","preconditions":["Raw socket with small rcvbuf","High packet rate"],"description":"raw_v4_input() checks sk_rmem_alloc against sk_rcvbuf but still clones the skb before queueing. Even when the queue is full, clones are allocated and then dropped, allowing a remote attacker to force repeated allocations and frees, wasting CPU and memory.","classification":"resource-exhaustion","impact":"CPU/memory pressure without delivering packets","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:174-195"],"derived_from":[],"proposed_fix_summary":"Test receive limits before cloning or defer clone until after sk_rmem_alloc check."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0007","title":"IP_HDRINCL fragmentation ambiguity leads to IDS evasion","attacker_model":"remote","preconditions":["Application uses IP_HDRINCL","Attacker can send crafted fragments"],"description":"raw_send_hdrinc() accepts caller-supplied IP headers and only checks total length vs MTU. A malicious user can craft overlapping fragments or inconsistent header fields (len vs ihl) to send on the wire, potentially bypassing firewall/IDS expectations from applications relying on kernel header construction.","classification":"logic-bypass","impact":"Evasion of network security controls","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:326-419"],"derived_from":[],"proposed_fix_summary":"Validate IP_HDRINCL headers for consistency and consider reassembly checks or stricter capability gating."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0008","title":"raw_sendmsg accepts len>0xFFFF silently returns error late","attacker_model":"local_unprivileged","preconditions":["CAP_NET_RAW holder crafts huge msghdr"],"description":"raw_sendmsg() rejects len>0xFFFF but only after allocating ipcm_cookie and parsing address data. An attacker can repeatedly issue oversized sends to waste CPU in validation and routing lookups, causing DoS for other CAP_NET_RAW users.","classification":"resource-exhaustion","impact":"CPU burn for capability holders","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:482-520"],"derived_from":[],"proposed_fix_summary":"Fail fast on oversize len before any routing or option parsing."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0009","title":"ICMP type probing leaks filter bitmap via timing","attacker_model":"remote","preconditions":["Raw ICMP listener with custom filter","Attacker measures response timing"],"description":"icmp_filter() performs skb_header_pointer and filter lookup. By sending varying ICMP types and measuring packet processing delay (drop vs delivery), a remote attacker can infer the socket's filter bitmap, learning application behavior or triggering cache side channels.","classification":"side-channel","impact":"Information leak about firewall filter configuration","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:137-155"],"derived_from":[],"proposed_fix_summary":"Add uniform fast-path handling or randomized delays for filtered types."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0010","title":"Missing skb linearization before raw_rcv_skb","attacker_model":"remote","preconditions":["GRO or non-linear skbs delivered to raw sockets"],"description":"raw_rcv_skb() enqueues skbs without ensuring linear data. Some raw consumers may assume linear payloads and directly access skb->data from userspace via packet mmap, allowing crafted fragmented skbs to trigger out-of-bounds reads in applications or zero-copy paths.","classification":"hardening","impact":"Potential crash in user raw consumers and kernel helpers","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:296-324"],"derived_from":[],"proposed_fix_summary":"Linearize or enforce checks before delivering skbs to raw sockets when hdrincl/packet mmap is used."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0011","title":"PMTU errors suppressed allow amplification of blackhole","attacker_model":"remote","preconditions":["raw socket sets IP_PMTUDISC_WANT","Attacker injects ICMP frag needed"],"description":"raw_err() updates PMTU only when type/code matches FRAG_NEEDED and recverr handling applies. If RECVERR is off and socket unconnected, PMTU changes are ignored, letting an attacker perpetually blackhole large packets while application never learns new MTU, causing persistent DoS.","classification":"logic-bypass","impact":"Sustained loss of connectivity for raw sender","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:208-255"],"derived_from":[],"proposed_fix_summary":"Optionally notify unconnected sockets of PMTU updates or clamp MTU on repeated ICMP events."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0012","title":"raw_getfrag uses skb->csum accumulation path sensitive to msg mutation","attacker_model":"local_unprivileged","preconditions":["Concurrent msg buffer modifications while sendmsg in progress"],"description":"raw_getfrag() computes checksum incrementally from user msghdr without locking or copy. If the user buffer is modified concurrently (e.g., shared memory), checksum and payload diverge, causing on-wire corruption that could be exploited to smuggle crafted packets past simple integrity checks.","classification":"race-condition","impact":"Transmission of forged packets with inconsistent checksum","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:431-479"],"derived_from":[],"proposed_fix_summary":"Copy user data into kernel buffer before checksum or pin pages to prevent concurrent modification."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0013","title":"raw_v4_input skips drop reason accounting for filter drops","attacker_model":"remote","preconditions":["Attacker floods filtered traffic","Operators rely on drop stats"],"description":"When sk_rcvbuf is exceeded or icmp_filter drops packets, raw_v4_input() increments sk_drops but does not propagate drop reasons to the network stack. This hinders detection and allows an attacker to hide a flood by avoiding global drop counters, reducing observability of attack traffic.","classification":"observability","impact":"Reduced visibility into attack drops","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:174-195"],"derived_from":[],"proposed_fix_summary":"Integrate drop_reason reporting or per-net counters for filtered raw input."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0014","title":"Routing cache use after free risk in raw_send_hdrinc","attacker_model":"local_unprivileged","preconditions":["CAP_NET_RAW holder triggers route changes concurrently"],"description":"raw_send_hdrinc() stores a rtable pointer from ip_route_output_flow() and uses it after potential route changes without holding dst reference until after skb allocation. Rapid routing updates (NETLINK) might free the route before use, leading to dereference of stale dst in rare races.","classification":"race-condition","impact":"Potential kernel crash or memory corruption","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:326-359"],"derived_from":[],"proposed_fix_summary":"Hold dst reference immediately after lookup and revalidate after allocations or retry on route change."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0015","title":"raw_sendmsg IP options copy lacks size validation before memcpy_from_msg","attacker_model":"local_unprivileged","preconditions":["CAP_NET_RAW set","Attacker supplies malformed IP options"],"description":"raw_sendmsg() copies IP options into opt_copy before verifying msg_iovlen boundaries. Malformed cmsghdr or truncated iov could lead to copying beyond user buffer into kernel stack, risking stack disclosure or fault loops.","classification":"memory-corruption","impact":"Potential kernel stack exposure or crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:482-520"],"derived_from":[],"proposed_fix_summary":"Validate cmsghdr lengths and iov size before any memcpy_from_msg into kernel option buffer."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0016","title":"IP_HDRINCL checksum trust enables reflection with spoofed source","attacker_model":"remote","preconditions":["Victim application sends raw replies using IP_HDRINCL","Attacker can inject packets"],"description":"When HDRINCL is set, the kernel trusts user-supplied checksum and source address. An attacker that compromises a raw-sending process or injects data into its shared buffer can force packets with spoofed source and valid checksums to be emitted, enabling reflection/amplification attacks bypassing kernel anti-spoofing.","classification":"spoofing","impact":"Network abuse and traffic amplification","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:326-419"],"derived_from":[],"proposed_fix_summary":"Recompute checksum and enforce source address binding even with IP_HDRINCL unless CAP_NET_ADMIN permits spoofing."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0017","title":"raw_v4_hashinfo exposed via EXPORT_SYMBOL enables BPF gadget discovery","attacker_model":"local_unprivileged","preconditions":["Attacker can load BPF or access /proc/kallsyms"],"description":"raw_v4_hashinfo is exported to modules, making its address visible to BPF with ksym access. Knowing the hash table layout aids exploitation by enabling targeted spraying or KASLR bypass for raw socket structures referenced from predictable offsets.","classification":"info-leak","impact":"KASLR reduction and exploitation aid","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:88-107"],"derived_from":[],"proposed_fix_summary":"Restrict ksym exports of raw_v4_hashinfo or randomize hash seeds per namespace."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0018","title":"procfs raw socket stats missing per-namespace isolation","attacker_model":"container_guest","preconditions":["/proc/net/raw readable in container","Host shares network namespace? maybe host"],"description":"If a container is run without network namespace isolation, /proc entries for raw sockets leak details of all raw listeners including addresses and protocols. Attackers can map services or craft targeted packets based on this data.","classification":"info-leak","impact":"Enumeration of host raw sockets","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:36-78"],"derived_from":[],"proposed_fix_summary":"Ensure /proc/net/raw is namespaced and enforce permissions or hide entries for other netns."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0019","title":"raw_icmp_error uses skb->data without linearity check","attacker_model":"remote","preconditions":["Non-linear skb delivered to error handler"],"description":"raw_icmp_error() casts skb->data to struct iphdr without ensuring linear headroom. A crafted ICMP error with small headlen could trigger access beyond linear data, leading to garbage header parsing and possibly kernel WARN or leak through subsequent raw_err processing.","classification":"hardening","impact":"Potential crash on malformed ICMP errors","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:272-294"],"derived_from":[],"proposed_fix_summary":"Require pskb_may_pull() before casting skb->data in raw_icmp_error."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0020","title":"Missing MSG_TRUNC support misleads applications on dropped tail","attacker_model":"remote","preconditions":["Attacker sends oversized packets to small recv buffers"],"description":"raw_rcv_skb() enqueues packets without marking truncation; applications reading via recvmsg may not learn that data was cut when rcvbuf limits triggered drops. Attackers can exploit this to cause protocol desynchronization or bypass simple length checks in userland parsers expecting full packets.","classification":"hardening","impact":"Application-level logic errors and potential parsing bugs","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:296-309","net/ipv4/raw.c:174-195"],"derived_from":[],"proposed_fix_summary":"Set MSG_TRUNC or return length indicators when data is dropped due to rmem limits."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0021","title":"Raw socket bind allows VRF cross-leak via sdif mismatch","attacker_model":"container_guest","preconditions":["Host uses VRF devices","Attacker has CAP_NET_RAW inside container but shares namespace"],"description":"raw_v4_match compares sk_bound_dev_if via raw_sk_bound_dev_eq using sdif/dif. On VRF ingress, sdif may be 0 causing match on sockets bound to other VRFs. Attacker can receive packets from host VRF not intended for container, leaking traffic or injecting responses with IP_HDRINCL.","classification":"logic-bypass","impact":"Traffic sniffing/injection across VRFs","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:119-129: raw_v4_match uses raw_sk_bound_dev_eq with sdif","net/ipv4/raw.c:163-198: raw_v4_input iterates matches without VRF guard"] ,"derived_from":[],"proposed_fix_summary":"Enforce vrf aware matching using l3mdev_idx for sdif/dif to prevent cross-VRF delivery."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0022","title":"raw_v4_input cloning loop can exhaust skb clones under memory pressure","attacker_model":"remote","preconditions":["Many sockets listening on same protocol/address","Low sk_rmem limits"],"description":"raw_v4_input clones skb for each listener without global cap besides sk_rcvbuf check. An attacker flooding crafted packets can force repeated skb_clone allocations leading to atomic pool exhaustion and system-wide packet loss or soft lockups.","classification":"DoS","impact":"Network packet loss and soft lockup due to clone exhaustion","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:172-195: raw_v4_input clones per match when sk_rmem_alloc < sk_rcvbuf"] ,"derived_from":[],"proposed_fix_summary":"Throttle cloning per skb or rate-limit per source; drop after threshold to protect pool."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0023","title":"ICMP error handling reads beyond linear data on GSO fragments","attacker_model":"remote","preconditions":["Attacker sends fragmented ICMP errors for GSO packet","Non-linear skb"],"description":"raw_icmp_error casts skb->data to iphdr without ensuring linearized headroom. For GSO-generated ICMP errors, skb may be non-linear leading to out-of-bounds read or garbage addresses used in raw_err queueing, causing crash or info leak.","classification":"race-condition","impact":"Potential crash or leak via malformed ICMP error","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:272-294: raw_icmp_error uses skb->data directly without pskb_may_pull"] ,"derived_from":["net/ipv4/raw.c-0019"],"proposed_fix_summary":"Call pskb_may_pull before parsing ICMP error headers for raw sockets."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0024","title":"Raw sendmsg with IP_HDRINCL bypasses rpfilter on local routes","attacker_model":"local_unprivileged","preconditions":["CAP_NET_RAW in namespace","rp_filter enabled"],"description":"When IP_HDRINCL is set, raw_send_hdrinc builds packet and sends via ip_route_output_flow. Reverse path filtering may be bypassed because skb is built with caller-supplied addresses and rpfilter uses routing cache that may accept spoofed source for local routes. Attacker can inject packets with spoofed source bypassing rp_filter.","classification":"logic-bypass","impact":"Source spoofing despite rp_filter","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:506-563: raw_send_hdrinc crafts skb with caller IP header","net/ipv4/raw.c:449-504: raw_probe_proto_opt only validates checksum"] ,"derived_from":[],"proposed_fix_summary":"Re-run rp_filter on constructed packets or restrict IP_HDRINCL to privileged contexts."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0025","title":"Race between raw_unhash_sk and packet receive","attacker_model":"local_unprivileged","preconditions":["Multicore system","Socket closes while packets arriving"] ,"description":"raw_unhash_sk removes socket under spinlock but RCU readers in raw_v4_input continue using sk without sock_flag(SOCK_DEAD) check before raw_rcv. Attacker floods packets while closing socket to hit use-after-free after sk_del_node_init_rcu when refcount drops rapidly.","classification":"race-condition","impact":"Use-after-free leading to crash or potential arbitrary read/write via freed sock","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:108-116: raw_unhash_sk uses sk_del_node_init_rcu","net/ipv4/raw.c:172-195: raw_v4_input uses sk without refcount bump beyond RCU"] ,"derived_from":[],"proposed_fix_summary":"Take ref on sk before raw_rcv or delay free until grace period after unhash completes."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0026","title":"raw_sendmsg route lookup uses outdated flowi4 on concurrent bind","attacker_model":"local_unprivileged","preconditions":["Thread binds socket while another thread sends"],"description":"raw_sendmsg builds flowi4 from inet->inet_saddr/daddr before acquiring socket lock. Concurrent bind or connect can change addresses leading to packets constructed with inconsistent header vs route, possibly sending to unexpected interface and bypassing policy routing.","classification":"race-condition","impact":"Policy routing bypass and potential info leak across interfaces","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:339-419: raw_sendmsg collects inet fields then routes","net/ipv4/raw.c:421-448: lock taken after flow computed"] ,"derived_from":[],"proposed_fix_summary":"Hold socket lock while building flow or re-evaluate route after binding changes."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0027","title":"msg_name parsing ignores trailing cmsg allowing memory disclosure","attacker_model":"local_unprivileged","preconditions":["recvmsg with MSG_PEEK and crafted msg_control"],"description":"raw_recvmsg copies address info into user msghdr without sanitizing padding. Attackers using MSG_PEEK and short buffers can read uninitialized stack padding from raw_recvmsg address fields or control messages due to missing memset of sockaddr_in and ipcm_cookie.","classification":"info-leak","impact":"Disclosure of kernel stack data via recvmsg","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:582-660: raw_recvmsg fills sockaddr and msg_control without memset"] ,"derived_from":[],"proposed_fix_summary":"Zero sockaddr and control buffers before filling; enforce msg_namelen limits with memset."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0028","title":"raw_err queue delivers stale skb after interface down","attacker_model":"remote","preconditions":["Interface goes down while ICMP errors queued"],"description":"raw_err processes skb error queue without checking device state beyond inet_addr_type. If interface is down and freed, queued skb references dev pointer freed later, leading to use-after-free when delivering error to userland.","classification":"race-condition","impact":"Kernel crash on error delivery","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:294-334: raw_icmp_error queues errors using skb_clone","net/ipv4/raw.c:564-580: raw_recvmsg dequeues without device validity checks"] ,"derived_from":[],"proposed_fix_summary":"Validate device presence when dequeuing raw_err and drop skb when netif_device_present fails."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0029","title":"Lack of per-namespace limit on raw sockets","attacker_model":"container_guest","preconditions":["Unprivileged user namespace with CAP_NET_RAW","Ability to create many raw sockets"],"description":"raw_hash_sk increases sock_prot_inuse but there is no per-namespace limit. A container can open thousands of raw sockets consuming prot memory and hash buckets, causing DoS for host network stack.","classification":"DoS","impact":"Resource exhaustion and network disruption","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:91-116: hash/unhash increment prot usage but no max enforced"] ,"derived_from":[],"proposed_fix_summary":"Enforce per-netns max raw sockets or tie to sysctl."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0030","title":"raw_v4_input lacks skb secpath validation allowing IPsec bypass","attacker_model":"remote","preconditions":["IPsec policies requiring auth","Raw socket opened without IPsec"],"description":"Raw delivery bypasses transport layer processing and does not enforce secpath presence. Attackers can inject packets that should be dropped by IPsec policies directly to raw sockets, obtaining plaintext and bypassing authentication.","classification":"logic-bypass","impact":"Policy bypass revealing unauthenticated packets","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:163-198: raw_v4_input delivers before IPsec policy enforcement in upper layers"] ,"derived_from":[],"proposed_fix_summary":"Check secpath or enforce xfrm policy for raw sockets when policies exist."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0031","title":"raw_getfrag copies user data without fault-in causing soft lockup","attacker_model":"local_unprivileged","preconditions":["User supplies iov to slow FUSE file","CAP_NET_RAW present"],"description":"raw_getfrag is invoked under BH-disabled context during sendmsg. If user buffer resides on FUSE or huge faulting memory, repeated faults can hang softirq context leading to soft lockups and watchdog resets.","classification":"DoS","impact":"Soft lockup during raw sendmsg","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:204-234: raw_getfrag called under bh_lock_sock with copy_from_user"] ,"derived_from":[],"proposed_fix_summary":"Prefault or use skb_copy_datagram_from_iter with sleepable context or limit buffer size."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0032","title":"Checksum offload assumptions allow injection with wrong csum","attacker_model":"remote","preconditions":["Raw socket with CHECKSUM_UNNECESSARY on device","Attacker on same L2"] ,"description":"raw_sendmsg may set CHECKSUM_NONE leaving checksum calculation to device. On devices marking skb->ip_summed = CHECKSUM_UNNECESSARY, packets with incorrect checksum may be transmitted. Receiving stack may still accept due to checksum offload, enabling injection or corruption of upper-layer protocols expecting checksum verification.","classification":"logic-bypass","impact":"Injection of corrupt packets past checksum validation","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:449-504: raw_probe_proto_opt sets ip_summed based on user flags"] ,"derived_from":[],"proposed_fix_summary":"Force checksum computation in software for raw sockets unless explicitly allowed by capability."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0033","title":"raw_recvmsg MSG_PEEK leaks kernel headers after error","attacker_model":"local_unprivileged","preconditions":["recvmsg MSG_PEEK with small buffer","sk_err set from ICMP"] ,"description":"When sk_err is set, raw_recvmsg may still copy address and control info before returning error, and MSG_PEEK prevents dequeuing. Attacker loops to read partially initialized data from skb_clone in error queue, leaking kernel memory from skb metadata.","classification":"info-leak","impact":"Kernel memory disclosure via control headers","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:564-660: raw_recvmsg handles skb errors and MSG_PEEK without clearing buffers"] ,"derived_from":[],"proposed_fix_summary":"Zero address/control buffers before returning errors and drop skb when MSG_PEEK with error."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0034","title":"TTL handling with IP_HDRINCL enables routing loop DoS","attacker_model":"local_unprivileged","preconditions":["CAP_NET_RAW","Can set low TTL"],"description":"raw_send_hdrinc honors user-specified TTL without enforcing minimum. Attacker crafts packets with TTL 1 to local router addresses causing continuous ICMP Time Exceeded storms toward victim or router CPU exhaustion.","classification":"DoS","impact":"Amplified ICMP traffic and router CPU exhaustion","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:506-563: TTL taken from user header"] ,"derived_from":[],"proposed_fix_summary":"Enforce minimum TTL or rate limit low-TTL IP_HDRINCL packets."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0035","title":"raw_bind allows INADDR_ANY without capability in userns","attacker_model":"container_guest","preconditions":["User namespace with CAP_NET_RAW","No restriction on bind address"] ,"description":"raw_bind permits binding INADDR_ANY regardless of namespace restrictions, allowing container to sniff host traffic when namespaces shared. Without per-netns control, attacker can bind to unspecified address and receive packets destined to host interfaces.","classification":"logic-bypass","impact":"Traffic sniffing across shared network namespace","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:707-750: raw_bind allows INADDR_ANY unless multicast check fails"] ,"derived_from":[],"proposed_fix_summary":"Restrict INADDR_ANY binds for raw sockets in shared namespaces or require CAP_NET_ADMIN."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0036","title":"raw_recvmsg drops timestamping metadata permitting replay desync","attacker_model":"remote","preconditions":["SO_TIMESTAMPING enabled","Attacker floods packets"] ,"description":"raw_recvmsg copies timestamp ancillary data but if skb_ts_get() fails or drops due to lack of space, user loses ordering cues. Attackers can exploit to inject replayed packets indistinguishable from originals, impacting custom protocols relying on timestamps for freshness.","classification":"hardening","impact":"Replay confusion and logic errors in user protocols","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:620-660: ancillary data copying without guarantee of presence"] ,"derived_from":[],"proposed_fix_summary":"Indicate dropped timestamp metadata to user or enforce buffer sizing before copy."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0037","title":"raw_getsockopt IP_HDRINCL leaks kernel stack padding","attacker_model":"local_unprivileged","preconditions":["getsockopt on RAW socket","Small optlen"],"description":"raw_getsockopt copies ip_options into user buffer via memcpy without zeroing structure beyond optlen. If user supplies shorter buffer, copy_to_user may include padding bytes from kernel stack, disclosing memory.","classification":"info-leak","impact":"Kernel stack disclosure","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/raw.c:768-823: ip_options copied to user without memset of stack buffer"] ,"derived_from":[],"proposed_fix_summary":"Zero temp structures before copy_to_user and clamp optlen."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0038","title":"raw_sendmsg ignores cgroup egress BPF verdicts","attacker_model":"container_guest","preconditions":["cgroup egress BPF configured","Raw socket sendmsg"],"description":"Raw sendmsg constructs skb and passes to ip_append_data/ip_push_pending_frames without cgroup egress BPF hook enforcement, allowing container processes to bypass network policy set by administrators.","classification":"policy-bypass","impact":"Policy enforcement bypass and data exfiltration","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:339-448: sendmsg path lacks cgroup_bpf_enabled checks"] ,"derived_from":[],"proposed_fix_summary":"Invoke cgroup egress BPF hooks for raw sockets or document exclusion."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0039","title":"raw_err queue can grow unbounded on persistent ICMP floods","attacker_model":"remote","preconditions":["Attacker sends ICMP unreachable to closed ports","Application slow to read error queue"],"description":"raw_icmp_error enqueues cloned skb for each error without per-socket limit besides memory pressure. Attackers can flood ICMP unreachable causing large error queue and memory exhaustion leading to DoS.","classification":"DoS","impact":"Memory exhaustion via raw error queue","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:294-334: error cloning without per-socket cap","net/ipv4/raw.c:564-580: recvmsg drains but may lag"] ,"derived_from":[],"proposed_fix_summary":"Cap raw_err queue length or drop errors when exceeding threshold."}
{"file":"net/ipv4/raw.c","scenario_id":"net/ipv4/raw.c-0040","title":"Lack of namespace isolation in /proc/net/raw","attacker_model":"container_guest","preconditions":["/proc mounted","Host shares net namespace"] ,"description":"/proc/net/raw exposes all raw sockets without per-net namespace scoping when namespaces are shared inadvertently. Containers can enumerate host sockets, aiding further attacks or info gathering.","classification":"info-leak","impact":"Enumeration of host raw sockets","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/raw.c:36-78: proc creation global without netns gating"] ,"derived_from":["net/ipv4/raw.c-0018"],"proposed_fix_summary":"Restrict /proc/net/raw visibility per netns or require capabilities."}
