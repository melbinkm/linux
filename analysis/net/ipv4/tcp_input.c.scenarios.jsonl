{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0001","title":"Sock_ops unknown-option storm stalls epollers","concept":"BPF sock_ops parsing triggers extra callbacks on unknown TCP options without rate limiting","attacker_model":"remote","preconditions":["CONFIG_CGROUP_BPF","BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG set via cgroup program"],"description":"Setup: attacker targets service with sock_ops program enabling PARSE_UNKNOWN_HDR_OPT to inspect unknown TCP options. Trigger: send streams with crafted unknown options on many connections while peer runs epoll. Mechanism: tcp_rcv_established calls bpf_skops_parse_hdr() early (lines 146-180) before validating flags, and unknown options force BPF callbacks under sock lock; excessive invocations can stall the receive path and hold the socket lock, delaying ACKs and user wakeups, leading to head-of-line blocking and resource exhaustion.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:146-180: bpf_skops_parse_hdr invoked on established sockets under lock for unknown options"],"derived_from":[],"proposed_fix_summary":"Rate-limit or bound BPF parse callbacks for unknown options and drop packets after budget; consider deferring parsing from softirq to workqueue."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0002","title":"TLS device clean_acked double-enable race","concept":"Deferred static key for TLS clean_acked callbacks can be toggled concurrently with sk reuse","attacker_model":"local_unprivileged","preconditions":["CONFIG_TLS_DEVICE","ability to flip TCP_ULP to tls on reused sockets"],"description":"Setup: attacker reuses a socket via SO_REUSEPORT and toggles TLS ULP on/off rapidly while triggering resets. Trigger: concurrent clean_acked_data_enable/disable (lines 121-144) can increment/decrement the deferred static key while the socket moves between listeners. Mechanism: lack of serialization with listener teardown lets clean_acked_data_enabled stay true with tp->tcp_clean_acked NULL, so subsequent acks dereference NULL via cad hook from data paths, causing crash or controlled NULL call.","classification":"logic-bypass","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:121-144: deferred static key toggled with tp->tcp_clean_acked assignments without global serialization"],"derived_from":[],"proposed_fix_summary":"Guard clean_acked_data_enable/disable with sock lock and check static key state before dereference; reset key on ULP teardown."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0003","title":"Header prediction bypass under timestamp parsing failure","concept":"Fast path timestamp parsing drops to slow path after state changes with stale ts_recent","attacker_model":"remote","preconditions":["Timestamps enabled","peer supports TCP options"],"description":"Setup: attacker races timestamp fields near wraparound. Trigger: send in-window ACK-only packets with malformed aligned timestamp so tcp_parse_aligned_timestamp() fails after __tcp_replace_ts_recent was already evaluated. Mechanism: in tcp_rcv_established fast path lines 6333-6354 the code accepts packets and may update ts_recent based on delta before checksum failures detected later, potentially allowing PAWS bypass or unexpected window acceptance leading to data injection when slow path uses updated ts_recent.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6333-6354: fast path timestamp handling updates delta before checksum and may jump to slow path"],"derived_from":[],"proposed_fix_summary":"Delay ts_recent replacement until packet fully validated or re-verify PAWS state after checksum/parsing errors."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0004","title":"PAWS challenge ack amplification via ACcecn option","concept":"accecn_reflector path sends challenge ACKs without rate limiting on repeated SYNs","attacker_model":"remote","preconditions":["CONFIG_TCP_AO disabled","accecn support negotiated"],"description":"Setup: remote peer negotiates accecn options then floods spoofed in-window SYNs with ACcecn option set. Trigger: tcp_validate_incoming handles SYN in established state and sends challenge ACK via tcp_send_challenge_ack (lines 6220-6244) with accecn_reflector true. Mechanism: lacking global per-flow rate limit in this path, attacker can force unbounded ACK reflection, consuming bandwidth and possibly triggering reflection attacks.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6220-6244: challenge ack on SYN with accecn_reflector without explicit rate guard"],"derived_from":[],"proposed_fix_summary":"Apply challenge ACK throttling for accecn reflector path or drop repeated SYNs after threshold."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0005","title":"ACK-only fast path leaks delayed rtt state on aborted checksum","concept":"Fast path sets rcv_rtt_last_tsecr before checksum validation completion","attacker_model":"remote","preconditions":["timestamps enabled"],"description":"Setup: attacker sends ACK-only packet with corrupted payload checksum but otherwise in-window. Trigger: fast path branch handles len==tcp_header_len and directly sets tp->rcv_rtt_last_tsecr and frees skb (lines 6356-6383) before validating payload checksum. Mechanism: If checksum later deemed invalid by lower layers, stale rtt sample persists, influencing RTO and cwnd leading to aggressive retransmission and potential congestion collapse or self-DoS.","classification":"logic-bypass","impact":"kernel crash","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6356-6383: fast path uses rtt stamp and frees skb on header-only packet without verifying data checksum"],"derived_from":[],"proposed_fix_summary":"Only record rtt and free skb after checksum validation success; guard rcv_rtt_last_tsecr updates."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0006","title":"Zero-copy driver truesize underrun enabling window inflation","concept":"truesize_adjust permits negative adjustments letting attacker overrun rcv_ssthresh","attacker_model":"remote","preconditions":["driver supplies page frags with zero headlen","CONFIG_HIGHMEM drivers"],"description":"Setup: attacker targets NIC with zero-copy frags producing skb_headlen==0. Trigger: send many small-frag packets; truesize_adjust subtracts headroom (lines 669-678) potentially lowering truesize below skb->len if driver bugged. Mechanism: tcp_grow_window uses adjusted truesize (lines 682-709) to raise rcv_ssthresh, letting attacker advertise larger window than memory budget, leading to RX queue blowup and memory pressure bypass.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:669-709: truesize_adjust may reduce truesize and feed tcp_grow_window to inflate receive window"],"derived_from":[],"proposed_fix_summary":"Clamp truesize_adjust to skb->truesize minimum and validate driver-provided skb layout before window growth."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0007","title":"Window clamp confusion during early memory pressure","concept":"tcp_grow_window uses tcp_under_memory_pressure heuristic without synchronizing with memcg limits","attacker_model":"container_guest","preconditions":["memcg limits enforced","high RTT path"],"description":"Setup: attacker in container controls many sockets, filling memcg near limit. Trigger: attack sends data bursts to push tcp_grow_window in fast path (lines 682-717) while memcg pressure changes asynchronously. Mechanism: tcp_under_memory_pressure uses global per-net pressures; mismatch with memcg leads to rcv_ssthresh boost despite memcg being reclaimed, causing refaults and socket drops that can be leveraged to induce cross-tenant packet loss or knock out other workloads sharing memcg.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:682-717: window growth decision ignores per-memcg reclaim state"],"derived_from":[],"proposed_fix_summary":"Include memcg pressure in tcp_under_memory_pressure and clamp rcv_ssthresh when memcg is near limit."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0008","title":"CUBIC sndbuf_expand unchecked growth via custom ca_ops","concept":"sndbuf_expand callback may return large multiplier without bounds","attacker_model":"container_guest","preconditions":["custom congestion control module exposing sndbuf_expand"] ,"description":"Setup: privileged container loads custom congestion control implementing sndbuf_expand returning large values. Trigger: tcp_rcv_space_adjust path uses ca_ops->sndbuf_expand (lines 604-616) to increase sk_sndbuf. Mechanism: absence of sanity checks allows arbitrary sndbuf inflation, letting attacker pin large wmem regardless of sysctl limits, leading to kernel memory exhaustion and potential DoS to other sockets.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:604-616: sndbuf_expand callback result directly applied to sk->sk_sndbuf with minimal cap"],"derived_from":[],"proposed_fix_summary":"Bound sndbuf_expand return values to sysctl_tcp_wmem[2] and require capabilities for custom ca_ops modules."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0009","title":"Busy-poll bypass of TCP small queue limits","concept":"Busy poll path processes skbs before sk_forward_alloc checks leading to queue growth","attacker_model":"remote","preconditions":["SO_BUSY_POLL enabled on socket","busy_poll budget large"],"description":"Setup: service enables busy-poll for latency. Trigger: attacker floods small packets; tcp_rcv_established fast path accepts skb and processes before step5 checks (lines 6394-6401). Mechanism: busy-poll pulls packets in process context, bypassing sk_forward_alloc enforcement momentarily, allowing rx queue to grow and deplete forward_alloc causing allocation fallback and possible soft lockups.","classification":"resource-exhaustion","impact":"kernel crash","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6394-6401: fast path returns before sk_forward_alloc enforcement when skb already pulled"],"derived_from":[],"proposed_fix_summary":"Enforce sk_forward_alloc budget prior to busy-poll dequeue or cap busy-poll budget based on socket memory."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0010","title":"Delayed challenge ACK suppresses PAWS drop","concept":"__tcp_replace_ts_recent called before validation allows stale timestamp acceptance","attacker_model":"remote","preconditions":["Timestamps enabled","fast path conditions met"],"description":"Setup: attacker sends segment with small data and timestamp just above ts_recent. Trigger: fast path updates ts_recent via __tcp_replace_ts_recent when tp->rcv_nxt==tp->rcv_wup (lines 6363-6368, 6406-6410) before PAWS revalidation. Mechanism: Later slow path may be skipped, so attacker can advance ts_recent to accept older packets, enabling replays or injection in edge cases.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6363-6370 and 6406-6410: ts_recent replacement occurs in fast path before full validation"],"derived_from":[],"proposed_fix_summary":"Delay ts_recent updates until after packet validation and PAWS check completion."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0011","title":"Data queue acceptance with stale dst leads to misrouted packets","concept":"Fast path sets rx_dst lazily without RCU stabilization","attacker_model":"remote","preconditions":["Multipath route changes or VRF movement"],"description":"Setup: attacker triggers route change or VRF move while connection active. Trigger: tcp_rcv_established sees !sk_rx_dst and sets it via sk_rx_dst_set (lines 6295-6299) without RCU grace before using; concurrent fib change may free old dst. Mechanism: subsequent uses dereference freed dst leading to use-after-free or misrouting of ACKs, potentially leaking packets across VRFs.","classification":"race-condition","impact":"info leak","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6295-6299: sets sk_rx_dst under fast path without explicit RCU synchronization with route changes"],"derived_from":[],"proposed_fix_summary":"Validate dst via rcu_dereference_protected or relookup after locking, and hold dst reference before assignment."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0012","title":"Receive window validation bypass using overlapping SACK","concept":"validate_incoming can be skipped when fast path consumes data before SACK recheck","attacker_model":"remote","preconditions":["SACK enabled","high reordering tolerance"],"description":"Setup: attacker sends crafted overlapping SACK blocks with data in fast path conditions. Trigger: tcp_queue_rcv consumes skb and sets FLAG_DATA, then ack path may avoid tcp_validate_incoming (lines 6416-6435) because packet already queued. Mechanism: overlapping SACK ranges accepted without bound check can move rcv_nxt forward, allowing injection of out-of-window data and later collapsing that overwrites user data.","classification":"logic-bypass","impact":"data corruption","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6416-6435: fast path queues data and may avoid validate_incoming on already-consumed skb"],"derived_from":[],"proposed_fix_summary":"Re-run validate_incoming on queued data with SACK blocks or enforce strict SACK range overlap checks."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0013","title":"ACK first then data ready wake race","concept":"tcp_data_ready may run after ack update with freed skb fragments","attacker_model":"remote","preconditions":["gro with fragstolen true","application busy"],"description":"Setup: attacker crafts GRO packets leading to fragstolen path. Trigger: fast path queue_rcv returns eaten with fragstolen set (lines 6390-6439), kfree_skb_partial frees fragments while tcp_data_ready runs after ack adjustments. Mechanism: data_ready callbacks (e.g., splice or ULP) may reference skb fields after partial free, causing UAF or panic.","classification":"UAF","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6390-6439: fragstolen handling frees skb after ack processing but before data_ready"],"derived_from":[],"proposed_fix_summary":"Delay kfree_skb_partial until after data_ready or ensure callbacks cannot access freed fragments."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0014","title":"Zero window probe race with rx dst refresh","concept":"validate_incoming uses outdated pred_flags when rx_dst refreshed mid-path","attacker_model":"remote","preconditions":["Zero window advertised","rx_dst changes"],"description":"Setup: attacker forces zero window then moves peer across VRF. Trigger: rx_dst reassign in fast path (6295-6299) while zero window path triggers slow path step5 (6456-6459). Mechanism: pred_flags assumptions may no longer match new route MSS, leading to accept of oversized segments during zero window probes and buffer overflow in out_of_order queue.","classification":"logic-bypass","impact":"data corruption","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6295-6299 and 6456-6459: rx_dst set before slow path validation when zero window engaged"],"derived_from":[],"proposed_fix_summary":"Recompute pred_flags and MSS after rx_dst changes before processing queued probe data."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0015","title":"ECE counter misuse under mixed accecn/tcp_ecn","concept":"tcp_ecn_received_counters called with inconsistent flags leading to stale ECN state","attacker_model":"remote","preconditions":["ECN and ACCECN negotiation allowed"],"description":"Setup: attacker negotiates accecn then switches to classic ECN marking mid-connection. Trigger: fast path calls tcp_ecn_received_counters with len and flag assumptions (6369-6420) while accecn_reflector toggled earlier. Mechanism: counters updated without consistent state leads to window reduction bypass or spurious congestion window collapse, letting attacker control victim throughput or cause self-inflicted retransmissions.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6369-6420: ECN counters updated in fast path without reconciling accecn state"] ,"derived_from":[],"proposed_fix_summary":"Synchronize ECN mode flags and validate before updating counters; reset on option changes."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0016","title":"MPTCP subflow option parsing pre-ack race","concept":"bpf_skops_established can run before validation on MPTCP options","attacker_model":"remote","preconditions":["CONFIG_MPTCP","BPF sock_ops program installed"],"description":"Setup: attacker uses MPTCP options on early packets. Trigger: bpf_skops_established invoked for established connections (182-199) even when skb is NULL in repair paths; with BPF program that rewrites options, race exists before tcp_validate_incoming verifies flags. Mechanism: program may alter header parsing assumptions leading to later mis-validation and acceptance of invalid MPTCP options that corrupt subflow state.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:182-199: bpf_skops_established runs with optional skb before validation"],"derived_from":[],"proposed_fix_summary":"Defer BPF sock_ops callbacks until after tcp_validate_incoming for MPTCP-enabled sockets."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0017","title":"Fastopen disable path leaks active data segments","concept":"tcp_fastopen_active_disable triggered by out-of-order RST without clearing data_segs_in","attacker_model":"remote","preconditions":["TCP Fast Open client","syn_data enabled"],"description":"Setup: client uses TFO with data in SYN. Trigger: attacker injects out-of-order RST with max_sack past syn range causing path at 6205-6214 to disable fastopen if no data received. Mechanism: data_segs_in may have been incremented earlier; disable path not synchronized with retransmission queue leading to queued data being processed without authentication, potentially causing data corruption or info leak when reused connection assumes clean state.","classification":"logic-bypass","impact":"data corruption","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6205-6214: fastopen disable triggered on RST before data handling synchronized"],"derived_from":[],"proposed_fix_summary":"Clear fastopen-related counters and purge data queues when disabling due to RST before continuing."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0018","title":"ACK reordering causes window update misclassification","concept":"FLAG_WIN_UPDATE vs FLAG_DATA mis-set leads to early cwnd growth","attacker_model":"remote","preconditions":["high reordering path","delayed ACK enabled"],"description":"Setup: attacker reorders ACKs carrying window updates only. Trigger: fast path sets FLAG_WIN_UPDATE based on lack of data (89-112) but does not check reordered ack_seq earlier; cwnd grows via tcp_ack on stale ACK (6374-6435). Mechanism: cwnd expansion without new data lets attacker inflate sender rate causing queue buildup and eventual drop/DoS.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:89-112 and 6374-6435: flag computation assumes monotonic ack_seq"],"derived_from":[],"proposed_fix_summary":"Revalidate ack_seq monotonicity before treating ACK as pure window update; clamp cwnd if stale."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0019","title":"TLP DSACK confusion leaks packet counts","concept":"FLAG_DSACK_TLP toggled without sanitizing acked ranges","attacker_model":"remote","preconditions":["Tail Loss Probe enabled","SACK permitted"],"description":"Setup: attacker sends duplicate ACKs with DSACK blocks during TLP recovery. Trigger: flag FLAG_DSACK_TLP set (100-107) and tcp_ack interprets acked retransmissions incorrectly when blocks fabricated. Mechanism: DSACK miscount drives spurious retransmission reductions or cwnd drop, enabling throughput degradation attack.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:100-107: DSACK flags set without verifying DSACK block validity"],"derived_from":[],"proposed_fix_summary":"Validate DSACK ranges against retransmit queue before setting DSACK_TLP flag during ack processing."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0020","title":"RCU-less skb freeing after challenge ACK drop","concept":"tcp_drop_reason path frees skb without RCU grace while helpers may still inspect","attacker_model":"remote","preconditions":["skb extensions in use (kcm, tls)"] ,"description":"Setup: attacker triggers challenge ack drop path repeatedly. Trigger: tcp_validate_incoming discards and calls tcp_drop_reason then returns (6252-6259). Mechanism: skb freed immediately even if extensions (e.g., TLS offload) still referenced by upper layers in same softirq, causing UAF with extension consumers and potential crash.","classification":"UAF","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6252-6259: discard path frees skb without synchronizing with extension users"],"derived_from":[],"proposed_fix_summary":"Defer freeing via kfree_skb_reason or RCU call when extensions may be referenced; audit extension lifetimes."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0021","title":"Rapid ack_mode toggling breaks pred_flags","concept":"pred_flags not recomputed when tcp_header_len changes after fast path check","attacker_model":"remote","preconditions":["TCP-AO or timestamp options toggled mid-connection"],"description":"Setup: attacker changes options (AO key updates) causing header len growth. Trigger: fast path pred_flags uses cached tcp_header_len (6316-6323) and assumes constant; when option expands header, fast path may still run and mis-parse payload leading to skb_pull of wrong length (6416-6419) and data misalignment into receive queue.","classification":"type-confusion","impact":"data corruption","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6316-6323 and 6416-6419: pred_flags assumes fixed header len, pulls based on cached size"],"derived_from":[],"proposed_fix_summary":"Invalidate pred_flags when options change; recompute tcp_header_len each packet before fast path."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0022","title":"tcp_rcv_established missing LSM hook for early drops","concept":"Discard path bypasses LSM auditing for invalid packets","attacker_model":"remote","preconditions":["LSM auditing required"],"description":"Setup: system relies on LSM auditing of dropped packets. Trigger: tcp_validate_incoming fails and jumps to discard (6252-6259) without security hooks. Mechanism: attacker can craft invalid packets to evade audit trails and hide scanning or exploitation attempts.","classification":"hardening","impact":"boundary bypass","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6252-6259: discard path drops silently after tcp_drop_reason"],"derived_from":[],"proposed_fix_summary":"Invoke security_inet_conn_request-style hook or tracepoint before discard to allow LSM visibility."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0023","title":"ECN fallback mis-detect with buggy middleboxes","concept":"accecn option failure increments counters but leaves tp->rx_opt.accecn inconsistent","attacker_model":"remote","preconditions":["ACCECN attempted negotiation"],"description":"Setup: attacker sends malformed accecn option once. Trigger: tcp_validate_incoming sees accecn option and calls tcp_accecn_option_init, failing and calling tcp_accecn_saw_opt_fail_recv (6223-6231). Mechanism: fallback not synchronized with existing ECN state causing later ECN marks misinterpreted; attacker can cause mis-cwnd adjustments or disable ECN silently.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6223-6231: accecn option failure path toggles state without resetting ECN expectations"],"derived_from":[],"proposed_fix_summary":"Reset ECN/accecn state coherently on option failure; send notification to peer."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0024","title":"ACK splitting bypasses quickack scheduling","concept":"tcp_rcv_established quickack bit set without cap enabling ack flood","attacker_model":"remote","preconditions":["ACK splitting attacker","quickack conditions"],"description":"Setup: attacker splits data into 1-byte segments triggering quickack. Trigger: tcp_grow_window sets quickack in fast path (706-710) when rcv_ssthresh raised. Mechanism: repeated small packets keep quickack set, forcing host to send many ACKs and bypassing delayed ACK policy, leading to amplification and potential reflection abuse.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:706-710: quickack flag set on window growth without rate control"],"derived_from":[],"proposed_fix_summary":"Throttle quickack resets per connection and re-enable delayed ACK after budget."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0025","title":"Memory pressure shrink race with per-socket rmem","concept":"tcp_adjust_rcv_ssthresh may be called after skb queued, leading to negative window","attacker_model":"remote","preconditions":["memory pressure event concurrent with heavy receive"],"description":"Setup: attacker floods connection while system experiences memory pressure. Trigger: tcp_grow_window enters pressure branch and calls tcp_adjust_rcv_ssthresh (712-716) after skb accepted. Mechanism: rcv_ssthresh may shrink below already-queued data causing negative available window and potential immediate RST or drop, leading to connection resets attacker can exploit for DoS.","classification":"race-condition","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:712-716: rcv_ssthresh adjusted post-queue under pressure without reconciling queued data"],"derived_from":[],"proposed_fix_summary":"Recalculate window after shrink and ensure no negative window; defer shrink until queue drained."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0026","title":"recv window growth across namespace move","concept":"rcv_ssthresh uses sock_net parameters even after netns migration","attacker_model":"container_guest","preconditions":["process moves socket across netns via setns with SO_REUSEPORT"],"description":"Setup: socket created in init netns then moved to container netns using setns and reuseport trick. Trigger: tcp_grow_window uses sock_net(sk)->ipv4.sysctl_tcp_rmem (645-652) even though netns move may have changed limits after creation. Mechanism: mismatched rmem allows container to consume host limits or smaller container limits to be bypassed, leading to cross-namespace resource leak or unexpected drops.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:645-652: rmem limits taken from sock_net(sk) without verifying netns change during socket lifetime"],"derived_from":[],"proposed_fix_summary":"Re-evaluate rmem/wmem limits on netns move or disallow moving established TCP sockets across namespaces."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0027","title":"Challenge ACK reflection from spoofed TFO RST","concept":"RST path sends challenge ACK even when cookie never validated","attacker_model":"remote","preconditions":["TCP Fast Open enabled"],"description":"Setup: TFO server uses cookies. Trigger: attacker spoofs RST with seq==max_sack during cookie validation (6200-6214). Mechanism: code sends challenge ACK and disables fastopen, reflecting traffic to victim and forcing CPU work without validating cookie, enabling reflection/amplification attack.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6200-6214: RST in TFO path triggers challenge ack without cookie validation"],"derived_from":[],"proposed_fix_summary":"Require valid cookie state before sending challenge ACK; drop silently otherwise."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0028","title":"SACK reneging mis-detection during DSACK","concept":"FLAG_SACK_RENEGING may be set from DSACK causing incorrect retransmission","attacker_model":"remote","preconditions":["SACK enabled","loss recovery ongoing"],"description":"Setup: attacker crafts DSACK blocks acknowledging already sacked data. Trigger: flag computations (89-112) set FLAG_SACK_RENEGING when snd_una advances to sacked seq. Mechanism: tcp_ack may treat as reneging and retransmit unnecessarily, allowing throughput degradation and possible cwnd collapse.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:89-112: flag SACK_RENEGING computed based on snd_una without DSACK distinction"],"derived_from":[],"proposed_fix_summary":"Differentiate DSACK from reneging and avoid retransmission triggers when DSACK detected."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0029","title":"Early skb checksum skip with VRF handoff","concept":"tcp_checksum_complete may be skipped for packets assumed in-window leading to corrupted data","attacker_model":"remote","preconditions":["checksum offload NIC","VRF migration mid-connection"],"description":"Setup: attacker times VRF change while sending data with intentionally bad checksum but valid sequence. Trigger: fast path bypasses checksum when skb->truesize below sk_forward_alloc and seq within window (6392-6401). Mechanism: corrupted data accepted into queue and delivered, enabling data corruption or triggering user-space parsing vulnerabilities.","classification":"logic-bypass","impact":"data corruption","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6392-6401: checksum bypass when skb fits forward_alloc and seq within window"],"derived_from":[],"proposed_fix_summary":"Force checksum verification after VRF/dst change or when offload state uncertain."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0030","title":"race between tcp_data_snd_check and data_ready","concept":"ACK processing may send new data before app consumed old, violating ordering","attacker_model":"remote","preconditions":["full-duplex connection"],"description":"Setup: attacker coordinates ack and data to create cross-queue interactions. Trigger: fast path ack updates and tcp_data_snd_check (6374-6435) run before tcp_data_ready, potentially transmitting new data while application still expects ordering. Mechanism: with BPF or ULP rewriting, this can cause data observed out of order, facilitating injection or replay confusion.","classification":"race-condition","impact":"data corruption","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6374-6439: ack processing and data_ready ordering"],"derived_from":[],"proposed_fix_summary":"Ensure data_ready callbacks complete before triggering tcp_data_snd_check transmissions when both paths active."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0031","title":"tcp_data_queue fast path bypasses urgent data validation","concept":"Fast path ignores URG/PSH combination leading to missing urgent pointer checks","attacker_model":"remote","preconditions":["peer sets URG pointer","fast path active"],"description":"Setup: attacker sends in-order data with URG flag but with fast path conditions satisfied. Trigger: fast path ignores PSH/URG bits (6273-6277) and proceeds to queue data. Mechanism: urgent pointer not validated against sequence space, allowing overwriting of user data or leak of adjacent memory if application interprets urgent data differently.","classification":"logic-bypass","impact":"data corruption","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6273-6277 and subsequent fast path ignoring urgent data expectations"],"derived_from":[],"proposed_fix_summary":"Disable fast path when URG flag present or validate urgent pointer before queueing."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0032","title":"Evil GRO fragment stealing with partial frees","concept":"fragstolen true path may free shared page before other readers finished","attacker_model":"remote","preconditions":["GRO enabled","drivers using page_pool"],"description":"Setup: attacker crafts GRO packets causing fragstolen to be set. Trigger: tcp_queue_rcv returns eaten with fragstolen true (6390-6439) and kfree_skb_partial frees shared frags. Mechanism: other sockets sharing page_pool pages may still reference them, leading to cross-flow data corruption or crash.","classification":"UAF","impact":"data corruption","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6390-6439: fragstolen handling frees frags after queue_rcv without refcount guarantees"],"derived_from":[],"proposed_fix_summary":"Add page refcount checks before freeing fragstolen pages; synchronize with page_pool recycling."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0033","title":"High-latency RTT cheating via timestamp reuse","concept":"Attacker replays old timestamp with seq==rcv_nxt to collapse RTO","attacker_model":"remote","preconditions":["timestamps enabled","fast path triggered"],"description":"Setup: attacker replays earlier ACK with valid seq/ack and old timestamp delta positive. Trigger: fast path accepts and updates rcv_rtt_last_tsecr (6374-6382) without verifying monotonicity beyond delta>=0. Mechanism: artificially small RTT recorded reduces RTO, making connection prone to spurious retransmits and allowing DoS by minor loss injection.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6374-6382: rtt update based on timestamp delta without monotonic check"],"derived_from":[],"proposed_fix_summary":"Require monotonic timestamp progression for RTT samples; ignore reused tsecr values."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0034","title":"Attack via malicious ca_ops sndbuf_expand returning zero","concept":"Zero sndbuf_expand collapses sndbuf leading to send stalls and RSTs","attacker_model":"container_guest","preconditions":["custom congestion module loaded"],"description":"Setup: attacker loads ca_ops with sndbuf_expand returning 0. Trigger: tcp_rcv_space_adjust applies sndmem=0 (604-616), potentially shrinking sk_sndbuf unexpectedly. Mechanism: send buffer underflow triggers ENOBUFS and spurious retransmissions, enabling DoS against services by forcing repeated RST on send failures.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:604-616: sndbuf_expand result applied without lower bound"],"derived_from":[],"proposed_fix_summary":"Enforce minimum sndbuf size regardless of sndbuf_expand result; validate congestion modules."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0035","title":"Quickack setting leaks timing via side channel","concept":"Setting quickack flag observable by attacker through RTT timing enabling inference of socket memory state","attacker_model":"remote","preconditions":["victim uses delayed ack"],"description":"Setup: attacker measures RTT variations. Trigger: tcp_grow_window sets quickack when window increases (706-710). Mechanism: quickack behavior changes ACK timing; attacker can infer when victim under memory pressure or window clamp reached, aiding traffic analysis and adaptive attacks.","classification":"info-leak","impact":"info leak","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:706-710: quickack toggled based on window growth"],"derived_from":[],"proposed_fix_summary":"Randomize quickack decisions or mask from untrusted peers; avoid revealing memory state via timing."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0036","title":"tcp_drop_reason path double kfree with skb_shared_info","concept":"discard path frees skb without checking if already detached from shared skbs","attacker_model":"remote","preconditions":["GSO/TSO segments with shared frags"],"description":"Setup: attacker sends malformed packets leading to discard. Trigger: tcp_drop_reason then __kfree_skb(skb) (6252-6259) even if skb shared; other references may free later. Mechanism: double free possible under driver bugs or extensions referencing same skb, leading to crash.","classification":"double-free","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6252-6259: discard path directly frees skb without refcount check"],"derived_from":[],"proposed_fix_summary":"Use kfree_skb_reason with refcounting; ensure skb_unshare before discard freeing."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0037","title":"ACK loop via ACcecn reflector during SYN flood","concept":"accecn_reflector causes reciprocal ACK storms when attacker spoofing","attacker_model":"remote","preconditions":["ACCECN enabled"],"description":"Setup: attacker spoofs SYNs with ACcecn to victim server. Trigger: validation sets accecn_reflector and sends challenge ack (6220-6244) for each packet. Mechanism: attacker forges source to third party causing reflection/amplification; lack of global rate limit leads to ACK loop between victims.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"high","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:6220-6244: challenge ack sent for each accecn SYN"],"derived_from":[],"proposed_fix_summary":"Rate-limit accecn challenge acks and validate cookies before reflection."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0038","title":"Busy poll with BPF sock_ops deadlock","concept":"sock_owned_by_me enforced while BPF program may sleep causing soft lockup","attacker_model":"remote","preconditions":["CONFIG_CGROUP_BPF","BPF program with potential sleep"],"description":"Setup: attacker triggers bpf_skops_parse_hdr during busy-poll. Trigger: function asserts sock_owned_by_me (170) and runs BPF program (179) which may call helpers that sleep. Mechanism: sleeping while socket lock held under busy-poll context can deadlock or starve softirq processing, enabling DoS.","classification":"resource-exhaustion","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:170-180: bpf_skops_parse_hdr holds socket lock and invokes BPF program"],"derived_from":[],"proposed_fix_summary":"Disallow sleepable helpers in this hook or run parse callback outside of lock/busy-poll context."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0039","title":"Recv window inflation via fraudulent MSS in header prediction","concept":"Header prediction path trusts advertised MSS and increments window disproportionately","attacker_model":"remote","preconditions":["MSS option received with small value","header prediction active"],"description":"Setup: attacker sends small MSS option packets to reduce per_mss. Trigger: tcp_rcv_space_adjust uses per_mss to compute sndmem (601-616). Mechanism: crafted small MSS still increases sndmem via sndbuf_expand leading to large sk_sndbuf relative to MSS, enabling attacker to force high memory use per connection for small payload, causing DoS.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:601-616: sndmem computed from per_mss without lower MSS bound"],"derived_from":[],"proposed_fix_summary":"Clamp MSS used for sndmem calculations to sane minimum; recompute after option changes."}
{"file":"net/ipv4/tcp_input.c","scenario_id":"net/ipv4/tcp_input.c-0040","title":"TCP orphan limit bypass via sysctl_tcp_max_orphans race","concept":"sysctl_tcp_max_orphans globally caps orphans but fast path allocations happen before check","attacker_model":"container_guest","preconditions":["unprivileged process can open many TCP sockets"],"description":"Setup: attacker creates many TCP connections then forces orphaning via closing in namespace with high limit. Trigger: incoming packets processed in tcp_rcv_established may allocate skb and queue before orphan accounting hits global sysctl_tcp_max_orphans (87). Mechanism: temporary bypass allows more orphans than limit, enabling memory exhaustion and DoS to host before reclaim occurs.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/ipv4/tcp_input.c:87: sysctl_tcp_max_orphans static limit; fast path queues before enforcement elsewhere"],"derived_from":[],"proposed_fix_summary":"Enforce orphan limit earlier in receive path and per-memcg to prevent transient spikes."}
