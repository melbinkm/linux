{"selected_target_file":"net/netfilter/nf_tables_api.c"}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0001","title":"Commit mutex leak on unbound set rejection","concept":"nf_tables commit returns early on unbound set/chain without releasing the commit_mutex, permanently blocking future nftables changes","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN in target netns","Netlink access to nftables"],"description":"Setup: attacker in a network namespace creates a ruleset with an anonymous set that remains unbound and issues a netlink batch that drives the transaction into commit. Trigger: the batch causes nf_tables_commit() to hit the unbound-set warning path and return -EINVAL before any cleanup. Mechanism: nf_tables_valid_genid() grabs nft_net->commit_mutex and leaves it held when commit returns error; the early return at the unbound-set check (lines 10890-10909) skips nf_tables_module_autoload_* and the unlock path, leaving commit_mutex locked for all subsequent nf_tables operations in that netns, causing a permanent denial-of-service on rule updates.","classification":"logic-bypass","impact":"persistent DoS","likelihood":"medium","verdict":"confirmed_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10890-10909: commit rejects unbound new set/chain with return -EINVAL before unlock","net/netfilter/nf_tables_api.c:11497-11505: commit_mutex is taken in nf_tables_valid_genid and must be released by commit/abort"],"proposed_fix_summary":"Ensure commit error paths release commit_mutex, e.g., invoke abort cleanup or drop back to nf_tables_abort when unbound objects are detected."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0002","title":"Catchall expiry flood drives unbounded GC work","concept":"Expired catchall set elements are queued into a global GC worklist without per-net limiting, allowing a single netns to flood the worker","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN in netns","Ability to create timeout-based sets"],"description":"Setup: attacker creates a timeout-based map with many catchall elements and extremely small timeouts. Trigger: allow the entries to expire en masse and repeatedly refill them. Mechanism: nft_trans_gc_catchall_async/sync walks the catchall_list and pushes each expired element to nf_tables_gc_list via nft_trans_gc_queue_work() (lines 10625-10677, 10559-10566) with no throttle or per-net accounting. A single netns can schedule unbounded GC work items and allocate new trans batches (10573-10585), consuming workqueue and memory resources and delaying other nets' GC, leading to packet path stalls.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10559-10566: expired elems are queued onto global nf_tables_gc_list and work scheduled","net/netfilter/nf_tables_api.c:10625-10677: catchall expiry loops queue each expired element without rate limit"],"proposed_fix_summary":"Add per-net limits to GC queue growth, batch catchall expiry, and make GC list per-net or back-pressure element creation on exhaustion."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0003","title":"Catchall GC races with abort-set teardown","concept":"Synchronous catchall GC walks set lists under commit lock while abort can mark the set dead and drop RCU protection, risking elem reuse","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Concurrent nft rule churn with timeouts"],"description":"Setup: attacker drives many transactions adding timeout catchall elements, then forces nfnetlink abort via validation failure. Trigger: while nf_tables_abort() tears down an unbound set and drops it from the lists, another CPU runs nft_trans_gc_catchall_sync() during commit generation because gc_seq was bumped before abort. Mechanism: the sync GC path assumes commit lock held (10660) and dereferences catchall->elem and nft_set_elem_ext() (10662-10676), but abort sets can still be freed after synchronize_rcu() later in abort (11455-11461), leaving elem_priv queued for GC without backing set memory, leading to UAF when nft_setelem_data_deactivate() touches freed storage.","classification":"UAF","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10652-10676: catchall GC dereferences elements assuming set persists under commit lock","net/netfilter/nf_tables_api.c:11452-11461: abort frees transactions after synchronize_rcu, allowing GC batches queued earlier to run on dead sets"],"proposed_fix_summary":"Cancel pending GC batches on abort before freeing sets or hold explicit set refcounts across GC walks and abort teardown."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0004","title":"Flowtable hook rollback race leaves dangling unregister","concept":"Flowtable delete/update uses different hook lists in commit vs abort, risking unregister on freed list when transactions interleave","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CONFIG_NF_FLOW_TABLE=y","CAP_NET_ADMIN","Offload hooks enabled"],"description":"Setup: attacker creates a flowtable and immediately deletes it in a separate netlink batch while another thread triggers abort by failing validation. Trigger: commit path for DELFLOWTABLE chooses between nft_trans_flowtable_hooks(trans) and flowtable->hook_list (11147-11166), while abort path for NEWFLOWTABLE/DELFLOWTABLE splices or unregisters hooks in reverse order (11424-11446). Mechanism: mismatched lists allow abort to call nft_unregister_flowtable_net_hooks() on hook_list already spliced into the base object, or to reuse nft_trans_flowtable_hooks after commit freed it via nft_hooks_destroy, producing double-unregister or dangling pointers passed to the unregister helper under RCU.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11147-11166: commit removes flowtable hooks choosing different list heads depending on update flag","net/netfilter/nf_tables_api.c:11424-11446: abort path also splices/unregisters hooks without coordination with commit decisions"],"proposed_fix_summary":"Serialize flowtable hook teardown, track ownership of hook lists explicitly, and guard unregister calls with state flags to avoid double removal."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0005","title":"Rule HW offload destroy double invocation across abort/commit","concept":"Flow offload rules are destroyed both on abort rollback and on commit paths when transactions interleave, risking double free in offload backend","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CONFIG_NFT_FLOW_OFFLOAD or HW offload","CAP_NET_ADMIN","Use of HW_OFFLOAD chains"],"description":"Setup: attacker installs a hw-offloaded chain, then issues rule deletions while racing a validation-induced abort (EAGAIN). Trigger: abort path for NEWRULE/DELRULE destroys nft_flow_rule when chain->flags has HW_OFFLOAD (11343-11352) even though commit path for the same transaction would also call nft_flow_rule_destroy() (11038-11052). Mechanism: if abort fires after commit_prepare allocates the flow_rule but before commit completes, both abort and later commit retry can destroy the same offload object because ownership is not cleared after abort, yielding double-free or backend pointer corruption inside the driver.","classification":"double-free","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11038-11052: commit frees nft_flow_rule for hw offload chains on rule add/del","net/netfilter/nf_tables_api.c:11343-11352: abort also destroys nft_flow_rule without state bit indicating prior free"],"proposed_fix_summary":"Track flow_rule lifetime explicitly per transaction and guard abort/commit against double destruction, clearing the pointer once freed."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0006","title":"Set pending_update list reuse without serialization","concept":"Same set can be enqueued on pending_update list multiple times across transactions because membership is unguarded, corrupting list links","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Set type with commit callbacks"],"description":"Setup: attacker issues overlapping NEWSETELEM and DELSETELEM transactions for the same set from different netlink sockets. Trigger: during commit, each transaction checks list_empty(&set->pending_update) before list_add_tail but without locking (11089-11106), while earlier passes may still have the node on the list from previous rounds (10844-10850 clears only once). Mechanism: concurrent commit contexts can add the same list_head twice, leading to list corruption and RCU traversal of freed pointers inside set->ops->commit callbacks, causing crashes or potential corruption depending on callback implementation.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10844-10851: pending_update list is walked and cleared without external locking","net/netfilter/nf_tables_api.c:11089-11106: commit enqueues set->pending_update based on list_empty without lock, allowing double add"],"proposed_fix_summary":"Protect pending_update with commit_mutex or per-set spinlock, or track membership with a flag to prevent multiple enqueues."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0007","title":"Validation retry uses already deactivated rules","concept":"nf_tables_validate returning -EAGAIN leaves rules deactivated in commit_list, so retried commits operate on half-removed objects","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Netlink batching with validation failures"],"description":"Setup: attacker sends a batch with rule deletions and invalid expressions that cause nf_tables_validate() to fail. Trigger: commit aborts with -EAGAIN (10817-10921) but leaves commit_list entries such as DELRULE with rule already deactivated via nft_delrule_deactivate()/nft_rule_expr_deactivate (656-715). Mechanism: subsequent retry using the same commit_list treats the rule as inactive and returns -ENOENT or skips reactivation, leaving the rule dangling on chain list with refcounts decremented, exposing use-after-free when packet path still holds pointers to the rule.","classification":"UAF","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:656-715: rule delete path deactivates rule and expressions before commit","net/netfilter/nf_tables_api.c:10817-10921: commit returns -EAGAIN on validation failure without rolling back commit_list objects"],"proposed_fix_summary":"If validation fails, run abort to reactivate objects or discard commit_list before retrying validation."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0008","title":"Module autoload releases commit mutex mid-transaction","concept":"nf_tables_module_autoload() drops commit_mutex while commit_list still holds in-flight transactions, allowing concurrent netlink updates to race with commit","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Expression autoload paths used"],"description":"Setup: attacker crafts a transaction that requires autoloading an expression module, causing module_list to be populated. Trigger: during abort or commit the code calls nf_tables_module_autoload() which explicitly mutex_unlock(&nft_net->commit_mutex) while request_module runs (11184-11197). Mechanism: with the lock dropped, another thread can issue more nft netlink commands that append to commit_list or modify binding lists while the original commit continues afterwards, violating ordering assumptions and leading to use-after-free when the first commit later walks a list that has been mutated by the second actor.","classification":"race-condition","impact":"kernel crash","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11184-11197: module autoload unlocks commit_mutex while commit_list/module_list live"],"proposed_fix_summary":"Avoid dropping commit_mutex during autoload or snapshot and block concurrent nf_tables netlink traffic until autoload completes."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0009","title":"Abort clears table owner allowing hijack","concept":"Table flags __NFT_TABLE_F_WAS_ORPHAN are reset during abort, clearing nlpid and owner state even though transaction failed","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN in shared netns","Existing table owned by another controller"],"description":"Setup: attacker submits a table update that marks the table orphan/dormant but triggers abort via validation failure or permissions. Trigger: abort path for NEWTABLE sees __NFT_TABLE_F_WAS_ORPHAN and clears NFT_TABLE_F_OWNER and nlpid (11274-11289). Mechanism: after abort completes, the table remains in place but owner tracking is cleared, so a different netlink portid can subsequently re-bind or delete the table without coordination with the original controller, bypassing ownership isolation between management agents.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"medium","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11274-11290: abort path clears OWNER flag and nlpid when __NFT_TABLE_F_WAS_ORPHAN is set"],"proposed_fix_summary":"Only clear ownership on successful commits or when explicitly requested with authorization; restore previous owner info on abort."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0010","title":"GC worker locks commit_mutex for attacker-sized batches","concept":"GC work acquires commit_mutex and walks attacker-controlled element batches, starving control-plane operations and other GC","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Ability to add many timed-out elements"],"description":"Setup: attacker fills a set with thousands of timed-out elements to push large nft_trans_gc batches. Trigger: trans_gc_work() drains nf_tables_gc_list and for each batch calls nft_trans_gc_work_done(), which takes nft_net->commit_mutex and iterates all priv[] entries (10490-10507). Mechanism: commit_mutex is held for the full batch removal and deletion path (10490-10507) and batches can be attacker-sized up to NFT_TRANS_GC_BATCHCOUNT repeatedly, preventing other netlink transactions from acquiring commit_mutex and stalling rule updates and garbage collection, effectively a persistent DoS.","classification":"resource-exhaustion","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10490-10507: GC worker holds commit_mutex while iterating attacker-controlled batch"],"proposed_fix_summary":"Bound batch processing time or drop commit_mutex before per-element teardown, introducing scheduling points or work rescheduling."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0011","title":"Anonymous set use ref underflow during commit delete","concept":"Commit decrements table use for anonymous sets with bindings even when delete fails, letting attacker drive use count negative and bypass busy checks","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Anonymous sets with bound elements"],"description":"Setup: attacker creates an anonymous map and binds it to rules, then issues a delete in the same batch as other operations that later fail validation. Trigger: commit path for NEWSET cleanup on failure branches calls nft_use_dec(&table->use) for anonymous bound sets (11069-11071) before commit succeeds or rollback is invoked. Mechanism: repeated retries decrement use without corresponding increments, potentially underflowing the use count and later allowing table deletion or set destruction while references still exist, leading to use-after-free in packet path.","classification":"refcount","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11064-11072: anonymous bound set path decrements table use during commit handling even on failure"],"proposed_fix_summary":"Move use-count adjustments to successful commit paths or pair them with rollback increments when commit aborts."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0012","title":"GC sequence race preserves expired elements","concept":"If gc_seq changes before GC worker runs, expired elements are skipped and destroy path not executed, leaving attacker-controlled stale entries active","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Timeout sets with many expirations","Concurrent nft transactions"],"description":"Setup: attacker fills a timeout set and forces frequent commits/aborts to bump gc_seq (10854-10868). Trigger: GC work dequeues a batch and finds gc_seq mismatch in nft_trans_gc_work_done() (10490-10500), destroying the batch without calling nft_setelem_data_deactivate/remove. Mechanism: expired elements remain linked in the set because the destroy path is skipped when gc_seq changed, letting attacker keep stale entries resident and potentially match packets beyond their timeout, bypassing policy and leaking memory until manual cleanup.","classification":"logic-bypass","impact":"data corruption","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10490-10500: GC worker drops batch when gc_seq mismatch without removing elements","net/netfilter/nf_tables_api.c:10854-10868: gc_seq increments on every commit/abort, attacker-controlled via netlink traffic"],"proposed_fix_summary":"Replay skipped batches or reschedule GC when gc_seq mismatches instead of simply discarding the elements."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0013","title":"Per-CPU chain stats freed on abort but reused on retry","concept":"Abort of NEWCHAIN frees per-CPU stats and name buffers while leaving transaction structures reused on retry, leading to use-after-free","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Basechain with counters enabled"],"description":"Setup: attacker adds a basechain with counters requiring per-CPU stats allocation, but intentionally triggers validation failure to force abort. Trigger: abort path for NEWCHAIN frees nft_trans_chain_stats and chain name (11302-11310) when update flag set. Mechanism: if user retries the same transaction object (e.g., via nfnetlink batching/GENID reuse) the commit_prepare logic may still reference chain->stats pointer that was freed, because the transaction was kept on commit_list until abort cleanup after synchronize_rcu, resulting in UAF when notifying or offloading uses the freed per-CPU array.","classification":"UAF","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11302-11310: abort frees per-CPU stats and name allocations for new chains when update flag set"],"proposed_fix_summary":"Invalidate transaction after abort or nullify freed pointers so retries must reallocate stats before reuse."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0014","title":"Unhandled binding types bypass commit sanity","concept":"Binding list iteration only handles NEWSET/NEWCHAIN and WARN_ONCEs otherwise, letting unknown types proceed without validation and corrupt commit flow","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Ability to craft raw netlink batches"],"description":"Setup: attacker injects crafted nftables netlink messages with manipulated msg_type values on the binding_list, e.g., via crafted nla that slips through parsing bugs. Trigger: nf_tables_commit() iterates binding_list and only validates NEWSET/NEWCHAIN, issuing WARN_ONCE for others but continuing (10892-10914). Mechanism: unvalidated binding transactions may lack required preparation (IDs, hooks) and later stages operate on partially initialized objects, leading to NULL deref or memory corruption when commit assumes bindings were set up, because no error/abort is executed after the warning.","classification":"logic-bypass","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10892-10914: default branch only WARN_ONCE on unexpected binding types and continues commit"],"proposed_fix_summary":"Reject unhandled binding msg_types with proper abort/cleanup instead of continuing after WARN_ONCE."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0015","title":"Set removal skips element deactivation for non-map flags","concept":"nft_delset only deactivates elements for MAP/OBJECT flags, allowing other timeout sets to be list_del_rcu while elements stay active","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Use of timeout/interval sets without MAP flag"],"description":"Setup: attacker creates a timeout interval set without NFT_SET_MAP flag and installs it in rules. Trigger: attacker deletes the set via netlink; nft_delset() only calls nft_map_deactivate() for MAP or OBJECT flags (826-840) before marking the set dead and dec table use. Mechanism: active elements in other set types stay visible to packet path even after list_del_rcu(&set->list), with GC racing later. Packets may continue to match stale elements referencing freed data once GC runs, leading to potential UAF or policy bypass.","classification":"UAF","impact":"data corruption","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:826-840: nft_delset deactivates only MAP/OBJECT sets before list_del"],"proposed_fix_summary":"Deactivate elements for all set types prior to list removal or ensure GC completes before detaching the set from lists."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0016","title":"Validate state stuck at SKIP after error","concept":"nft_validate_state_update can leave validate_state at SKIP even after validation errors, letting subsequent transactions bypass checks","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Trigger validation warnings"],"description":"Setup: attacker causes validation failure that sets table->validate_state to NFT_VALIDATE_DO, then injects crafted transactions that call nft_validate_state_update(table, NFT_VALIDATE_SKIP) through control flow that ignores the WARN_ON (33-57). Mechanism: because WARN_ON_ONCE does not change control flow, validate_state may be downgraded to SKIP while ruleset still inconsistent, causing nf_tables_validate() to be skipped in later commits, letting malformed expressions or rule blobs be committed without full verification.","classification":"logic-bypass","impact":"data corruption","likelihood":"low","verdict":"hardening_only","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:33-57: nft_validate_state_update silently sets validate_state even on invalid transitions"] ,"proposed_fix_summary":"Enforce strict state machine transitions and refuse to drop to SKIP when validation previously failed until a full re-validate succeeds."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0017","title":"Flowtable flags updated without device capability checks","concept":"Commit copies user-provided flowtable flags directly into data.flags, permitting namespace-local admins to toggle offload features on host devices","attacker_model":"container_guest","preconditions":["CONFIG_NF_TABLES=y","CONFIG_NF_FLOW_TABLE=y","CAP_NET_ADMIN in container","Shared host netdevice exposed"],"description":"Setup: container with CAP_NET_ADMIN creates a flowtable bound to a host-exposed interface. Trigger: attacker issues NEWFLOWTABLE/NEWFLOWTABLE update with crafted flags; commit path assigns nft_trans_flowtable_flags(trans) directly to flowtable->data.flags (11128-11137) without per-device offload or namespace capability checks. Mechanism: container can enable hardware offload or change data-plane behavior on host interfaces, potentially impacting other tenants or enabling packet steering bypass of host firewalling.","classification":"logic-bypass","impact":"boundary bypass","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11128-11137: commit copies transaction flags into flowtable data without capability/device verification"],"proposed_fix_summary":"Validate flowtable flags against device capabilities and namespace policy, requiring host-level privileges for offload-related bits."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0018","title":"Missing commit lock before sync GC causes NULL deref","concept":"nft_trans_gc_queue_sync expects commit lock and returns NULL when missing, but callers often dereference without checking, enabling crash via user-triggered call path","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Trigger synchronous GC via nft set deletion"],"description":"Setup: attacker forces synchronous GC (e.g., DELSETELEM on timeout set) from a context where commit_mutex is not held, such as error paths. Trigger: nft_trans_gc_queue_sync() hits WARN_ON_ONCE and returns NULL (10597-10610). Mechanism: callers like nft_trans_gc_catchall_sync() immediately use the returned pointer (10668-10676) without NULL checks, leading to NULL dereference and kernel crash under attacker control when they can reach the path without commit lock.","classification":"DoS","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10597-10610: sync GC returns NULL when commit lock missing","net/netfilter/nf_tables_api.c:10668-10676: callers assume non-NULL gc and dereference"],"proposed_fix_summary":"Check return values from nft_trans_gc_queue_sync or enforce commit lock before invoking synchronous GC helpers."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0019","title":"Abort reactivates expressions already in use","concept":"Abort of rule delete calls nft_rule_expr_activate on rules still referenced in packet path, potentially double-incrementing expression refs","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Rules with stateful expressions"],"description":"Setup: attacker issues DELRULE transactions for stateful expressions while packets continue to reference the rule, then triggers abort via validation failure. Trigger: abort path for DELRULE/DESTROYRULE increments use via nft_use_inc_restore and calls nft_rule_expr_activate() (11346-11354) even though the expressions may already be active and referenced. Mechanism: repeated abort/commit cycles can double-activate expression state, inflating refcounts or timer references and preventing cleanup, leading to memory leaks or inconsistent state observable by packet processing.","classification":"refcount","impact":"persistent DoS","likelihood":"medium","verdict":"hardening_only","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:11346-11354: abort path reactivates rule expressions after restoring use count"] ,"proposed_fix_summary":"Track activation state to avoid reactivating already-live expressions on abort, or gate on nft_is_active flags."}
{"file":"net/netfilter/nf_tables_api.c","scenario_id":"net/netfilter/nf_tables_api.c-0020","title":"GC trans_free operates in wrong net namespace","concept":"nft_trans_gc_trans_free reads net pointer from set after RCU, allowing stale set reuse to execute element destroy in a different netns","attacker_model":"local_unprivileged","preconditions":["CONFIG_NF_TABLES=y","CAP_NET_ADMIN","Ability to force set reuse through rapid create/destroy"],"description":"Setup: attacker rapidly creates and destroys sets in multiple netns, forcing slab reuse of struct nft_set at same address. Trigger: a GC batch queued for the old set runs nft_trans_gc_trans_free() after RCU grace (10470-10479) and reads the net from set->net without verifying set->dead. Mechanism: if the set structure has been reallocated for another netns, GC will call nf_tables_set_elem_destroy() using the new net pointer but stale element priv pointers, leading to cross-namespace memory corruption or freeing objects belonging to the new owner.","classification":"type-confusion","impact":"kernel crash","likelihood":"low","verdict":"probable_vuln","context":"kernel_core","evidence":["net/netfilter/nf_tables_api.c:10470-10479: gc trans_free reads set->net and destroys elements after RCU without checking set->dead or generation"] ,"proposed_fix_summary":"Pin sets for GC lifetime or store the originating net pointer in the GC batch to avoid dereferencing potentially recycled set structures."}
