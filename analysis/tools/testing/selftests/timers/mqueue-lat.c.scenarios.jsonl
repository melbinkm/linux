{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0001","title":"Uninitialized mq_attr used for stack buffer sizing","description":"mq_getattr() return value is ignored; if it fails, attr.mq_msgsize remains uninitialized. The subsequent VLA 'char buf[attr.mq_msgsize];' can allocate an arbitrary stack size, leading to stack overflow or access to uninitialized memory depending on the garbage value.","classification":"error-handling","impact":"Process crash / possible memory disclosure","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/mqueue-lat.c:61-89"],"proposed_fix_summary":"Check mq_getattr() return code and default to a bounded msgsize or abort before using attr.mq_msgsize for allocation.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0002","title":"Attacker pre-creates /foo with oversized messages","description":"Because the queue name '/foo' is predictable and opened with O_CREAT | O_RDONLY, an attacker can pre-create the queue with an extremely large mq_msgsize. When the test opens it, attr.mq_msgsize inherits the oversized value and allocates a huge stack buffer per iteration, triggering stack exhaustion or kernel ENOMEM paths.","classification":"predictable-resource","impact":"Local denial of service or crash","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/mqueue-lat.c:61-89"],"proposed_fix_summary":"Use a unique, random queue name under /dev/mqueue and clamp attr.mq_msgsize to a sane upper bound before allocating buffers.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0003","title":"World-writable queue allows message injection","description":"The queue is created with mode 0666, allowing any local user to send messages while the test waits on mq_timedreceive(). Injected messages will make the receive return immediately, invalidating latency measurements and enabling other users to force the test to report false failures or passes.","classification":"access-control","impact":"Logic abuse / test result poisoning","likelihood":"high","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:66-89"],"proposed_fix_summary":"Restrict permissions (e.g., 0600) or generate per-user queue names to prevent untrusted writers during the measurement.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0004","title":"Persistent queue not unlinked after test","description":"mq_open() creates /foo but the test never calls mq_unlink(). The queue persists system-wide after the test completes, leaking kernel resources and enabling later attackers to reuse or spam the leftover queue path to disrupt future runs.","classification":"resource-leak","impact":"Kernel object leakage / future interference","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:66-98"],"proposed_fix_summary":"Call mq_unlink() in success and failure paths to ensure the temporary queue is removed after measurements.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0005","title":"No EINTR handling on mq_timedreceive","description":"Signals delivered during mq_timedreceive() cause it to return -1 with errno=EINTR, but the test treats any negative return other than ETIMEDOUT as fatal. A local attacker sending signals to the process can deterministically fail the test and abort CI runs.","classification":"signal-handling","impact":"Denial of service for the selftest","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:77-89"],"proposed_fix_summary":"Retry mq_timedreceive() when interrupted by EINTR and ignore unrelated signals during the measurement window.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0006","title":"CLOCK_REALTIME dependency enables NTP manipulation","description":"The timeout uses CLOCK_REALTIME, so an attacker with clock control (or an aggressive NTP step) can advance time to make mq_timedreceive() time out immediately or delay it by stepping time backward, producing misleading latency results and potentially hanging the loop until select times out.","classification":"time-manipulation","impact":"False latency readings / prolonged hangs","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:80-95"],"proposed_fix_summary":"Use CLOCK_MONOTONIC timeouts for mq_timedreceive() or detect large wall-clock adjustments and abort the measurement.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0007","title":"VLA allocation repeated without limit","description":"Each of the 100 iterations allocates a variable-length array on the stack based on mq_msgsize with no cap. When combined with an attacker-controlled mq_msgsize, this can repeatedly exhaust stack guards and trigger unpredictable behavior across loops.","classification":"resource-exhaustion","impact":"Stack exhaustion / crash","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/mqueue-lat.c:74-89"],"proposed_fix_summary":"Replace the VLA with a fixed-size buffer bounded to a safe maximum and fail fast if mq_msgsize exceeds that maximum.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0008","title":"Lack of queue attribute validation","description":"The test trusts attr.mq_maxmsg and mq_msgsize from mq_getattr() without checking for zero or extreme values. A maliciously crafted queue (created by another user) with mq_maxmsg=0 or tiny mq_msgsize can force mq_timedreceive() to fail instantly, skipping latency checks and skewing results.","classification":"input-validation","impact":"Logic abuse / unreliable metrics","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:71-89"],"proposed_fix_summary":"Validate mq_attr values against reasonable bounds before using them and regenerate the queue if they are outside limits.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0009","title":"Shared queue name collides with concurrent runs","description":"Multiple instances of the test share the same /foo queue. Concurrent runs can interfere by consuming each other's timeouts or leaving messages that alter measured latency, producing flaky results or causing unexpected wakes.","classification":"concurrency","impact":"Flaky or incorrect latency measurements","likelihood":"high","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:66-98"],"proposed_fix_summary":"Generate unique queue names per process (e.g., using getpid()) and ensure mq_unlink() cleans them up.","derived_from":[]}
{"file":"tools/testing/selftests/timers/mqueue-lat.c","scenario_id":"tools/testing/selftests/timers/mqueue-lat.c-0010","title":"Return-path lacks cleanup on early failure","description":"If mq_timedreceive() errors out mid-loop, the code returns -1 without closing or unlinking the queue. File descriptors and kernel queue objects remain allocated, enabling resource leakage across repeated runs and potential exhaustion of mq limits by an attacker inducing failures.","classification":"resource-leak","impact":"File descriptor and mqueue exhaustion","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/mqueue-lat.c:66-98"],"proposed_fix_summary":"Use cleanup handlers to close and unlink the queue on all error exits so attackers cannot accumulate leaked mq objects.","derived_from":[]}
