{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0001","title":"Absolute nanosleep bypass via privileged clock rollback","description":"Attacker with CAP_SYS_TIME or virtualization control rolls CLOCK_REALTIME backward immediately after the absolute target is computed. clock_nanosleep() may return early because the target is now in the past, and the subsequent in_order check still passes because the clock was rewound, masking early-wake regressions the test was meant to catch.","classification":"time-manipulation","impact":"Test false negative / hides early-wake regressions","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:93-116","tools/testing/selftests/timers/nanosleep.c:171-208"],"proposed_fix_summary":"For CLOCK_REALTIME cases, record monotonic timestamps and enforce a minimum sleep duration regardless of wall-clock jumps.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0002","title":"Clock forward jump turns nanosleep into busy loop","description":"While testing CLOCK_REALTIME, an attacker advances the clock far into the future so that each clock_nanosleep(TIMER_ABSTIME) returns immediately. The loop multiplies length and reissues tests without any backoff, potentially spinning with repeated zero-length sleeps and consuming CPU instead of actually measuring latency.","classification":"resource-exhaustion","impact":"CPU exhaustion of test host","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:190-202"],"proposed_fix_summary":"Track wall-clock deltas and abort if the effective sleep time is near-zero for successive iterations, or use CLOCK_MONOTONIC for timing the loop.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0003","title":"Timer creation failure leaves SIGALRM handler installed","description":"If timer_create() fails (e.g., rlimit/NSS or seccomp), nanosleep_test_remaining() returns -1 without restoring SIGALRM to SIG_DFL. Any later code in the process inherits the dummy handler, potentially masking real alarms or interfering with other tests executed in the same binary.","classification":"state-contamination","impact":"Cross-test interference / logic abuse","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/nanosleep.c:124-159"],"proposed_fix_summary":"Ensure SIGALRM disposition is restored in all early-return paths, ideally by registering a cleanup handler or using sigaction in a finally block equivalent.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0004","title":"Unhandled SIGALRM during state reset corrupts rmtp check","description":"If a spurious SIGALRM arrives between timer_delete() and the restoration of SIGALRM disposition, rmtp may be left unchanged and subsequent in_order comparisons can succeed even though nanosleep returned for the wrong signal source, hiding timing regressions.","classification":"signal-race","impact":"Test false negative / inconsistent results","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:151-166"],"proposed_fix_summary":"Block SIGALRM around teardown or set SA_RESTART to avoid spurious EINTR while restoring defaults.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0005","title":"No bounds on SIGALRM rate can starve nanosleep test","description":"An attacker can flood the process with SIGALRM (or any unblocked signal) while the loop executes. Each EINTR causes a ksft_exit_fail(), allowing a local user to cause deterministic test failure and potential CI disruption without exhausting traditional resources.","classification":"denial-of-service","impact":"Selftest abort / CI disruption","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:178-209"],"proposed_fix_summary":"Mask unexpected signals during test sections and retry nanosleep when interrupted by unrelated signals instead of exiting immediately.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0006","title":"Relative sleep uses user-controlled ns without saturation","description":"The loop multiplies 'length' by 100 until it exceeds 10 seconds. If ported or reused with user-supplied values, timespec_add() does not enforce an upper bound before adding, so large ns values could wrap tv_sec or overflow when converted by clock_nanosleep().","classification":"integer-overflow","impact":"Undefined behavior / potential negative timeouts","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:190-201","tools/testing/selftests/timers/nanosleep.c:79-87"],"proposed_fix_summary":"Clamp requested nanoseconds to a sane maximum before calling timespec_add() and reject values that would overflow tv_sec.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0007","title":"Uninitialized rmtp use if clock_nanosleep fails early","description":"nanosleep_test_remaining() only initializes rmtp to zero. If clock_nanosleep() returns an immediate error other than EINTR (e.g., invalid clockid injected via fault-injection), rmtp remains zeroed and in_order comparisons still succeed, masking the failure reason and producing misleading passes.","classification":"error-handling","impact":"False success masking kernel error paths","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:124-166"],"proposed_fix_summary":"Validate return codes explicitly and fail the test if clock_nanosleep() does not return EINTR, without relying on rmtp ordering checks.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0008","title":"SIGALRM handler not async-signal-safe if expanded","description":"The dummy_event_handler currently does nothing, but if extended with printf or other logic, it would run in an async signal context without safety guarantees. The test infrastructure provides no guardrails, so future modifications could introduce deadlocks or corruption triggered by timer expiration.","classification":"signal-safety","impact":"Potential deadlock or crash on handler expansion","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:119-133"],"proposed_fix_summary":"Document and enforce async-signal-safe operations in handlers, or switch to signalfd to avoid traditional signal pitfalls.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0009","title":"Lack of monotonic reference for latency assertions","description":"The test assumes clock_gettime() before and after nanosleep reflects elapsed time, but uses the same clock that is being tested. If the clock is slewed or stepped during the sleep, assertions about in_order may produce false negatives or positives, making the test unreliable under adversarial NTP adjustments.","classification":"time-manipulation","impact":"False failures or passes under clock slew","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:93-116","tools/testing/selftests/timers/nanosleep.c:171-205"],"proposed_fix_summary":"Measure elapsed duration with CLOCK_MONOTONIC_RAW alongside the tested clock to detect external adjustments and flag the test as inconclusive instead of failing silently.","derived_from":[]}
{"file":"tools/testing/selftests/timers/nanosleep.c","scenario_id":"tools/testing/selftests/timers/nanosleep.c-0010","title":"Process-level signal handler shared across iterations","description":"The SIGALRM handler is installed once per nanosleep_test_remaining() call but affects the entire process. In multi-threaded invocations or when other selftests run in the same process, timer signals can be delivered to unintended threads, producing flaky EINTR paths and potential data races.","classification":"concurrency","impact":"Flaky failures or mismeasured latency","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/nanosleep.c:124-159"],"proposed_fix_summary":"Use per-thread timers (clock_nanosleep with SIGEV_THREAD_ID) or block SIGALRM in other threads to contain handler scope during the test.","derived_from":[]}
