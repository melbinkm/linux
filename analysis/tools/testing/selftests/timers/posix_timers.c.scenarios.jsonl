{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0001","title":"Unbounded brk growth if timer signal never flips done","description":"Attacker runs the selftest while interfering with signal delivery (e.g., masking SIGPROF) so that the SIGPROF handler never sets the global 'done' flag. The kernel_loop() helper then repeatedly calls brk() to move the program break forward and back without any upper bound, consuming virtual memory until the process or system runs out of resources.","classification":"resource-exhaustion","impact":"Denial of service via memory exhaustion","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/posix_timers.c:59-66","tools/testing/selftests/timers/posix_timers.c:107-128"],"proposed_fix_summary":"Bound the number of brk() iterations or add a wall-clock timeout so the loop exits even if the signal is suppressed.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0002","title":"Async-signal-unsafe functions in SIGALRM handler","description":"The SIGALRM handler ctd_sighandler() invokes pthread_self() and mutates shared counters. If the signal interrupts a libpthread critical section, calling pthread_self() from an asynchronous signal context can deadlock or corrupt internal state, crashing the test binary. An attacker can deliver SIGALRM at controlled moments to trigger the undefined behavior and terminate the process.","classification":"signal-safety","impact":"Process crash / denial of service","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/posix_timers.c:169-174"],"proposed_fix_summary":"Use only async-signal-safe operations in handlers (e.g., write to sig_atomic_t flags) or handle timer signals via signalfd instead of traditional handlers.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0003","title":"Data races on shared counters controlling termination","description":"Globals 'done', 'ctd_count', and 'ctd_failed' are plain volatile ints shared between signal handlers and worker threads. On SMP systems they can be updated concurrently without atomic operations, so increments/decrements may be lost. An adversary running the test under high thread preemption could cause ctd_count to underflow or never reach zero, leaving threads spinning forever and burning CPU.","classification":"concurrency","impact":"Denial of service via CPU spin","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:45","tools/testing/selftests/timers/posix_timers.c:167-175","tools/testing/selftests/timers/posix_timers.c:194-195"],"proposed_fix_summary":"Use atomic counters or condition variables with proper synchronization to coordinate thread termination reliably.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0004","title":"Global SIGALRM handler reused across tests without restoration","description":"check_timer_create() overwrites the process-wide SIGALRM disposition using signal() and never restores the previous handler. If another component in the same process set its own handler, running this test hijacks SIGALRM delivery and can make that component misbehave. An attacker embedding the selftest into a larger harness could intentionally disrupt other modules by invoking the test repeatedly.","classification":"logic","impact":"Denial of service / logic interference","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:148-149"],"proposed_fix_summary":"Save and restore prior SIGALRM handlers or run the test in an isolated process to avoid cross-test contamination.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0005","title":"Timer targeted to uninitialized thread id","description":"check_sig_ign() programs SIGEV_THREAD_ID timers using a tid harvested from a helper thread. The tid is stored into 'tid' before the thread has actually entered its loop, and the main thread only sleeps 1s before using it. If scheduling delays prevent the helper from calling gettid() in time, the tid could remain zero, causing timer_create() to target the wrong thread or fail. An attacker inducing heavy load can exploit the race to redirect SIGUSR1 to an unintended thread in the process.","classification":"race","impact":"Logic abuse / unexpected signal delivery","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/posix_timers.c:269-295"],"proposed_fix_summary":"Synchronize on the helper thread publishing a valid tid (e.g., with a barrier or condition variable) before arming the SIGEV_THREAD_ID timer.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0006","title":"Timer continues after target thread cancellation","description":"In the SIGEV_THREAD_ID branch of check_sig_ign(), the helper thread is cancelled while the timer remains active; the timer is only deleted after joining. Between cancellation and timer_delete(), SIGUSR1 signals may be delivered to a reused tid if the kernel recycles the numeric tid quickly. A local attacker who can create threads in the process could race to occupy that tid, receiving the signal unexpectedly and potentially interrupting unrelated code.","classification":"race","impact":"Unexpected signal delivery / DoS","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:314-333"],"proposed_fix_summary":"Disarm or delete the timer before cancelling the target thread, or block the signal process-wide until cleanup completes.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0007","title":"Busy-wait helpers can spin forever if signals suppressed","description":"user_loop(), kernel_loop(), and the ctd loop use tight while loops that rely solely on shared flags flipped by signal handlers. If an attacker masks the corresponding signals or sends them before the loops start, the flags never change and the program spins on a core indefinitely, causing CPU denial of service.","classification":"robustness","impact":"CPU exhaustion","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:48-51","tools/testing/selftests/timers/posix_timers.c:62-65","tools/testing/selftests/timers/posix_timers.c:194-195"],"proposed_fix_summary":"Add maximum wait durations or additional exit conditions (e.g., wall-clock deadlines) to ensure the loops terminate even if signals are lost.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0008","title":"PR_TIMER_CREATE_RESTORE_IDS left enabled on error path","description":"check_timer_create_exact() enables PR_TIMER_CREATE_RESTORE_IDS but only turns it off after successful timer creation and deletion. If prctl(PR_TIMER_CREATE_RESTORE_IDS_ON) succeeds but subsequent timer_create() fails, the function returns via fatal_error() without restoring the prctl state, leaving the process configured to force exact timer IDs. That persistent state can break later code in the same process that assumes default ID allocation.","classification":"state-leak","impact":"Logic malfunction / subsequent failures","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:627-666"],"proposed_fix_summary":"Use a scoped cleanup (e.g., a finally block or atexit handler) to always disable PR_TIMER_CREATE_RESTORE_IDS even when earlier calls fail.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0009","title":"SIGUSR1 overruns accumulate silently during ignored phase","description":"During check_sig_ign() the timer fires repeatedly while SIGUSR1 is blocked, then the handler is switched to SIG_IGN and the timer keeps running for another second. Overrun counts are never reset or drained before the handler is restored, so a sudden burst of queued overruns could surprise code that assumes few pending signals. An attacker could flood the queue with overruns to skew subsequent timing assertions or create unexpected latency when signals are unblocked.","classification":"logic","impact":"Timing distortion / DoS","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:299-333"],"proposed_fix_summary":"Disarm the timer before switching to SIG_IGN or drain pending signals/overruns before re-enabling the handler.","derived_from":[]}
{"file":"tools/testing/selftests/timers/posix_timers.c","scenario_id":"tools/testing/selftests/timers/posix_timers.c-0010","title":"Potential negative diff from timeval subtraction without normalization","description":"check_diff() subtracts timeval fields directly without normalizing underflow, so if end.tv_usec < start.tv_usec the computed diff can be off by almost a second. An attacker influencing time adjustments (e.g., via adjtime if permitted) could cause the test to miscalculate negative differences and proceed even when timers fire far too early, masking regressions.","classification":"input-validation","impact":"False-negative test result","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/posix_timers.c:85-97"],"proposed_fix_summary":"Normalize timeval subtraction or switch to timespec and timespecsub helpers to handle underflow safely.","derived_from":[]}
