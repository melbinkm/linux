{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0001","title":"Async-unsafe operations in SIGRTMAX handler","description":"sigalarm() invokes clock_gettime() and manipulates globals without async-signal-safe guarantees. If the signal fires while libc holds internal locks (e.g., during malloc in printf), the handler can deadlock or corrupt state, letting an attacker using timer overrun signals crash the process.","classification":"signal-safety","impact":"Process crash / deadlock","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:85-101"],"proposed_fix_summary":"Limit the handler to sig_atomic_t updates or switch to signalfd/RTSIGHAND with dedicated thread processing.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0002","title":"Races on shared latency counters","description":"alarmcount, timer_fired_early, and max_latency_ns are written from the signal handler and read in the main thread without synchronization. Under heavy signal load the reads can observe torn or stale values, leading to incorrect pass/fail decisions that an attacker could trigger by sending asynchronous signals.","classification":"data-race","impact":"False test results / undefined behavior","likelihood":"high","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:40-44","tools/testing/selftests/timers/set-timer-lat.c:85-183"],"proposed_fix_summary":"Use atomic types or sig_atomic_t and fence after handler updates, or collect results via signalfd in a single thread.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0003","title":"Timer waits can hang if signal lost","description":"do_timer() busy-waits with sleep(1) until alarmcount reaches 5. If timer signals are blocked, delivered to another thread, or lost, the loop spins indefinitely, letting a local attacker block CI by inhibiting signal delivery (e.g., via ptrace or SIGRTMAX masking).","classification":"denial-of-service","impact":"Infinite loop / hung test run","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:198-214"],"proposed_fix_summary":"Add a wall-clock timeout or maximum iterations so the loop aborts if expected signals are not observed.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0004","title":"Global clock_id modified mid-test by signals","description":"clock_id is a global updated in the main loop before running each timer. Because SIGRTMAX can interrupt between assignments and timer_settime(), the handler may run with a partially updated or wrong clock_id, corrupting latency calculations and producing false alarms an attacker could exploit by racing signal delivery.","classification":"concurrency","impact":"Incorrect latency metrics / flakiness","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:40-44","tools/testing/selftests/timers/set-timer-lat.c:240-268"],"proposed_fix_summary":"Keep clock_id thread-local or block SIGRTMAX while updating globals and programming timers.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0005","title":"Unsupported clock early return leaves handler installed","description":"setup_timer() installs a SIGRTMAX handler once, and on timer_create() failure it returns 1 or -1 without removing the handler or restoring masks. Subsequent code (or other tests in the same process) continue running with SIGRTMAX bound to sigalarm, potentially hijacking unrelated realtime signals.","classification":"state-contamination","impact":"Cross-test interference / unexpected signal handling","likelihood":"medium","verdict":"probable_vuln","evidence":["tools/testing/selftests/timers/set-timer-lat.c:111-159"],"proposed_fix_summary":"Install the handler once in main with explicit teardown at exit, or register cleanup on failure paths to restore default dispositions.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0006","title":"CLOCK_REALTIME slews invalidate ABSTIME setup","description":"For TIMER_ABSTIME, start_time is captured using the same clock being tested. If CLOCK_REALTIME is stepped backward, the timer may fire immediately after creation, falsely setting timer_fired_early and inflating max_latency_ns. An attacker with clock control can force test failures without affecting kernel behavior.","classification":"time-manipulation","impact":"False failures / noise in results","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:141-156","tools/testing/selftests/timers/set-timer-lat.c:161-184"],"proposed_fix_summary":"Compare timer expirations against a monotonic reference or reject large wall-clock adjustments during the test.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0007","title":"SIGRTMAX handler lacks SA_RESTART leading to spurious failures","description":"The sigaction for SIGRTMAX sets sa_flags=0, so syscalls like select() in do_timer_oneshot() can return EINTR. The code treats EINTR as a fatal error, allowing an attacker to inject SIGRTMAX (or timer overruns) and force premature failures.","classification":"signal-handling","impact":"Deterministic test abort","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:216-237","tools/testing/selftests/timers/set-timer-lat.c:240-268"],"proposed_fix_summary":"Use SA_RESTART or explicitly retry EINTR-sensitive syscalls to avoid adversarial signal injection causing failures.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0008","title":"No cap on timer_fired_early increment","description":"Each timer tick increments alarmcount and can set timer_fired_early, but there is no limit on how many times the handler runs. If a timer is misconfigured to extremely fast intervals or overrun delivery, the handler may execute unboundedly, starving the main thread and causing denial of service.","classification":"resource-exhaustion","impact":"CPU starvation / unbounded signal handling","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:85-101","tools/testing/selftests/timers/set-timer-lat.c:198-214"],"proposed_fix_summary":"Cap the number of signal deliveries considered or disarm timers after the needed samples are collected.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0009","title":"Select timeout ignores elapsed time with monotonic skew","description":"do_timer_oneshot() waits up to five seconds in select() without considering whether the timer already expired or signals were missed. If the tested clock jumps backward, select waits the full interval even though the timer may be firing repeatedly, causing stale readings and potential hangs orchestrated via clock skew.","classification":"time-manipulation","impact":"Hang / stale metrics","likelihood":"low","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:216-237"],"proposed_fix_summary":"Use clock_nanosleep on CLOCK_MONOTONIC for bounded waits and break out early when alarmcount exceeds expectations.","derived_from":[]}
{"file":"tools/testing/selftests/timers/set-timer-lat.c","scenario_id":"tools/testing/selftests/timers/set-timer-lat.c-0010","title":"Shared SIGRTMAX handler affects other threads","description":"The process-wide sigaction is installed once in main and never reverted. Other threads in the same process will inherit SIGRTMAX delivery to sigalarm, which reads and writes globals without synchronization, allowing cross-thread interference or crashes if unrelated code uses SIGRTMAX.","classification":"state-contamination","impact":"Cross-thread interference / crashes","likelihood":"medium","verdict":"hardening_only","evidence":["tools/testing/selftests/timers/set-timer-lat.c:240-268","tools/testing/selftests/timers/set-timer-lat.c:85-101"],"proposed_fix_summary":"Scope the handler to the test by blocking SIGRTMAX in other threads or restoring the default disposition when the test completes.","derived_from":[]}
